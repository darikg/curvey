{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Curvey","text":"<p>Pythonic geometric processing of discrete planar closed curves</p> <ul> <li>See the GitHub repo for installation instructions</li> <li>See the tutorials for a casual introduction</li> <li>See the API documentation for exhaustive documentation</li> <li>See the bibliography for some references</li> </ul>"},{"location":"bibliography/","title":"Bibliography","text":"<ul> <li> <p>Keenan Crane's discrete differential geometry course. See in particular the lecture on discrete plane curves.</p> </li> <li> <p>Lectures in Discrete Differential Geometry 1 - Plane Curves, Etienne Vouga, 2014.</p> </li> <li> <p>Can Mean-Curvature Flow Be Made Non-Singular? Michael Kazhdan, Jake Solomon, and Mirela Ben-Chen. 2012.</p> </li> <li> <p>Mean Curvature Flow and Applications. Maria Eduarda Duarte and Leonardo Sacht. 2017.</p> </li> <li> <p>Robust Fairing via Conformal Curvature Flow. Keenan Crane, Ulrich Pinkall, and Peter Schr\u00f6der. 2014</p> </li> <li> <p>Rapid blending of closed curves based on curvature flow. Masahiro Hirano, Yoshihiro Watanabe, and Masatoshi Ishikawa. 2017.</p> </li> </ul>"},{"location":"api/","title":"Curvey API","text":"<ul> <li> <p><code>curvey.curve</code></p> <ul> <li>The main curve class</li> </ul> </li> <li> <p><code>curvey.curves</code></p> <ul> <li>A container of curves</li> </ul> </li> <li> <p><code>curvey.shape_structure_data</code></p> <ul> <li>Interface to the 2D Shape Structure Dataset</li> </ul> </li> <li> <p><code>curvey.flow</code></p> <ul> <li>Curve shortening flow, Willmore flow, etc.</li> </ul> </li> <li> <p><code>curvey.blend</code></p> <ul> <li>Linear and curvature blending for shape interpolation</li> </ul> </li> </ul>"},{"location":"api/blend/","title":"curvey.blend","text":""},{"location":"api/blend/#curvey.blend","title":"<code>blend</code>","text":"<p>Curve blending and shape interpolation</p>"},{"location":"api/blend/#curvey.blend.CurvatureShapeBlending","title":"<code>CurvatureShapeBlending</code>","text":"<p>Curvature-based shape blending</p> <p>Based on</p> <p>Rapid blending of closed curves based on curvature flow. Masahiro Hirano, Yoshihiro Watanabe, and Masatoshi Ishikawa. 2017.</p> <p>Parameters:</p> Name Type Description Default <code>processed0</code> <code>Processed</code> required <code>processed1</code> <code>Processed</code> <p>The processed pair storing the original curves and processed curves. Curvature flow interpolation requires the processed curves to have</p> <ol> <li>The same number of vertices</li> <li>The same total length</li> <li>Reasonably similar edge lengths between corresponding edge pairs.</li> </ol> required <code>initial</code> <code>Curve</code> <p>The initial curve to start targeted curvature flow from. If not supplied this defaults to <code>pair[0].processed</code>, but I find curvature blending to work best when the initial processed curve is Willmore-flowed to a circle.</p> required <code>flow</code> <code>WillmoreFlow | None</code> <p>The <code>WillmoreFlow</code> object to use for curvature flows. This can be supplied if some default parameters need to be overridden, but is usally left <code>None</code> by default for automatic construction</p> <code>None</code> <p>Examples:</p> <pre><code>n = 128\nsrc = Curve.circle(n=n)\ntgt = Curve.star(6, r0=1, r1=2).interpolate_n(n).scale(1.5)\ncsb = CurvatureShapeBlending.preprocess(src, tgt)\nt_interp = np.linspace(0, 1, 5)\ncurves = csb.interpolate(t=t_interp, stop_tol=1e-3, interp_size='area')\ncurves.subplots()\n</code></pre> Source code in <code>src\\curvey\\blend.py</code> <pre><code>class CurvatureShapeBlending:\n    \"\"\"Curvature-based shape blending\n\n    Based on\n\n    [*Rapid blending of closed curves based on curvature flow.*\n    Masahiro Hirano, Yoshihiro Watanabe, and Masatoshi Ishikawa. 2017.](\n        https://www.sciencedirect.com/science/article/pii/S016783961730016X)\n\n    Parameters\n    ----------\n    processed0\n    processed1\n        The processed pair storing the original curves and processed curves. Curvature flow\n        interpolation requires the processed curves to have\n\n        1. The same number of vertices\n        2. The same total length\n        3. Reasonably similar edge lengths between corresponding edge pairs.\n\n    initial\n        The initial curve to start targeted curvature flow from. If not supplied this\n        defaults to `pair[0].processed`, but I find curvature blending to work best when\n        the initial processed curve is Willmore-flowed to a circle.\n\n    flow\n        The `WillmoreFlow` object to use for curvature flows. This can be supplied if some default\n        parameters need to be overridden, but is usally left `None` by default for automatic\n        construction\n\n    Examples\n    --------\n    ```python\n    n = 128\n    src = Curve.circle(n=n)\n    tgt = Curve.star(6, r0=1, r1=2).interpolate_n(n).scale(1.5)\n    csb = CurvatureShapeBlending.preprocess(src, tgt)\n    t_interp = np.linspace(0, 1, 5)\n    curves = csb.interpolate(t=t_interp, stop_tol=1e-3, interp_size='area')\n    curves.subplots()\n    ```\n\n    \"\"\"\n\n    def __init__(\n        self,\n        processed0: Processed,\n        processed1: Processed,\n        initial: Curve,\n        flow: WillmoreFlow | None = None,\n    ):\n        self.processed0 = processed0\n        self.processed1 = processed1\n        self.initial = initial\n        self.flow = flow or WillmoreFlow(realign=False)\n        self.history: list[Curves | None] | None = None\n        self.curvature0 = self.flow.curvature_fn(processed0.processed)\n        self.curvature1 = self.flow.curvature_fn(processed1.processed)\n\n    @property\n    def processed(self) -&gt; tuple[Curve, Curve]:\n        \"\"\"The pair of processed `Curve`s\"\"\"\n        return self.processed0.processed, self.processed1.processed\n\n    @property\n    def original(self) -&gt; tuple[Curve, Curve]:\n        \"\"\"The pair of original `Curve`s\"\"\"\n        return self.processed0.original, self.processed1.original\n\n    def _interpolate_curvature(self, t: float) -&gt; ndarray:\n        return (1 - t) * self.curvature0 + t * self.curvature1\n\n    def _interpolate_length(self, t: float) -&gt; float:\n        c0, c1 = self.original\n        return (1 - t) * c0.length + t * c1.length\n\n    def _interpolate_area(self, t: float) -&gt; float:\n        c0, c1 = self.original\n        return (1 - t) * c0.area + t * c1.area\n\n    def _interpolate_position(self, t: float, mode: Literal[\"center\", \"centroid\"]) -&gt; ndarray:\n        c0, c1 = self.original\n        return (1 - t) * getattr(c0, mode) + t * getattr(c1, mode)\n\n    def _interpolate_once(\n        self, t: float, initial: Curve | None, exact_endpoints: tuple[bool, bool], **kwargs\n    ) -&gt; tuple[Curves | None, Curve]:\n        k_interp = self._interpolate_curvature(t)\n\n        flow = self.flow.with_tgt_curvature(k_interp)\n\n        if (t in (0, 1)) and exact_endpoints[int(t)]:\n            return None, self.processed[int(t)]\n\n        initial = initial or self.initial\n\n        solver = self._current_solver = flow.solver(\n            initial=initial,\n            history=self.history is not None,\n            **kwargs,\n        )\n\n        solver.log(\"Interpolating t = {}\", t)\n        solver.run()\n        curve = solver.current\n\n        # Get rid of flow-specific metadata\n        curve = curve.drop_data(\"willmore_energy\", \"step\", \"timestep\")\n\n        # Add interpolation-specific metadata\n        curve = curve.with_data(\n            time=t,\n            src_error=sqrt(flow.energy(curve=curve, tgt_curvature=self.curvature0)),\n            tgt_error=sqrt(flow.energy(curve=curve, tgt_curvature=self.curvature1)),\n            interp_error=sqrt(flow.energy(curve=curve, tgt_curvature=k_interp)),\n        )\n\n        return solver.history, curve\n\n    def interpolate(\n        self,\n        t: ndarray,\n        path_dependent: bool = False,\n        realign: bool = True,\n        interp_size: Literal[\"length\", \"area\"] | None = \"length\",\n        interp_pos: Literal[\"center\", \"centroid\"] | None = \"center\",\n        reregister: bool = False,\n        exact_endpoints: tuple[bool, bool] = (False, False),\n        post_process: Callable[[Curve], Curve] | None = None,\n        history: bool = False,\n        **kwargs,\n    ) -&gt; Curves:\n        \"\"\"Interpolate shape at the supplied time-points\n\n        Parameters\n        ----------\n        t\n            Vector of interpolation parameter values in [0, 1]\n\n        path_dependent\n            If True, the resulting interpolated curve from each timepoint is used as the starting\n            point for the next interpolation. Otherwise, each timepoint's flow is independently\n            started from the `self.initial` curve.\n\n        realign\n            If True, the curve after each interpolation step is aligned to the preceeding step.\n            This can account for changes in position and orientation. Realignment is performed\n            before transforming by the interpolated size or position.\n\n        interp_size\n            If not None, scale each interpolated curve to the area or length obtained by\n            interpolating the `self.pair.orig` curves' length or area.\n\n        interp_pos\n            If not None, translate the interpolated curves' center or centroid to the position\n            interpolated between the `self.pair.orig` curves' center or centroid.\n\n        reregister\n            If True, perform a final post-processing step as follows: register the final\n            interpolated curve against the original curve using the `Curve.register_to`\n            iterative closest point algorithm. The total change in position, orientation, and\n            scale is then interpolated by `t` for each interpolated curve. This generally assumes\n            that 1) t=0 and t=1 are included in the interpolation points, and 2) `interp_size`\n            and `interp_pos` are enabled so that the interpolated curve is close enough to the\n            original curve for ICP to be successful.\n\n        exact_endpoints\n            By default, the curves at t=0 and t=1 are found by the same targeted curvature flow\n            as for the interior time points. This skips that step and simply uses\n            `self.pair[t].processed` if `exact_endpoints[t] == True`, for `t = 0` and `t = 1`.\n\n        history\n            If true, the history of each interpolating flow is stored in `self.history`\n            as a length(t) `list[Curves]`.\n\n        post_process\n            An option function `Curve -&gt; Curve` to apply to each interpolated curve.\n\n        **kwargs\n            Additional kwargs passed to `WillmoreFlow.solver` every interpolation step.\n\n        Returns\n        -------\n        Curves\n            A `Curves` of length `len(t)`.\n        \"\"\"\n        curves = Curves()\n        self.history = [] if history else None\n        initial = self.initial\n        raw = []  # Before interpolating size, position, etc\n\n        for i, t_interp in enumerate(t):\n            history_i, c_interp = self._interpolate_once(\n                t=t_interp,\n                initial=initial,\n                exact_endpoints=exact_endpoints,\n                **kwargs,\n            )\n            raw.append(c_interp)\n\n            if i &gt; 0 and realign:\n                c_interp = c_interp.align_to(raw[-1])\n\n            if interp_size == \"length\":\n                c_interp = c_interp.to_length(self._interpolate_length(t_interp))\n            elif interp_size == \"area\":\n                c_interp = c_interp.to_area(self._interpolate_area(t_interp))\n\n            if interp_pos:\n                pos = self._interpolate_position(t_interp, mode=interp_pos)\n                c_interp = c_interp.translate(pos)\n\n            if post_process:\n                c_interp = post_process(c_interp)\n\n            curves.append(c_interp)\n\n            if path_dependent:\n                initial = raw[-1]\n\n            if self.history is not None:\n                self.history.append(history_i)\n\n        if reregister:\n            curves = self._reregister(curves, t=t)\n\n        return curves\n\n    def _reregister(self, curves: Curves, t: ndarray) -&gt; Curves:\n        # Register the final interpolated curve to the original curve\n        # A 3x3 transformation matrix\n        transform = curves[-1].register_to(\n            target=self.processed1.original,\n            allow_scale=True,\n            return_transform=True,\n        )\n\n        # Extract rotation, scale, and translation from the transform matrix\n        r_cos_theta, r_sin_theta = transform[:2, 0]\n        theta = arctan2(r_sin_theta, r_cos_theta)\n        scale_factor = sqrt(r_cos_theta**2 + r_sin_theta**2)\n        offset = transform[:2, 2]\n\n        out = Curves()\n        transform = eye(3)\n\n        for c, ti in zip(curves, t):\n            transform[:2, :2] = ((1 - ti) + scale_factor * ti) * rotation_matrix(theta * ti)\n            transform[:2, 2] = offset * ti\n            out.append(c.transform(transform))\n\n        return out\n\n    @staticmethod\n    def preprocess(\n        c0: Curve,\n        c1: Curve,\n        flow: WillmoreFlow | None = None,\n        circle_stop_tol=1e-3,\n    ) -&gt; CurvatureShapeBlending:\n        \"\"\"Preprocess a pair of curves for curvature shape blending\n\n        Scales both curves to a common length and optimizes their edge length distributions.\n        Also flows the first curve to a circle for use as the `initial` curve for flow-based\n        interpolation.\n        \"\"\"\n        _ = c0.check_same_n_vertices(c1)\n        o0, o1 = c0, c1\n        c0, c1 = c0.to_length(1.0), c1.to_length(1.0)\n        c1 = c1.optimize_edge_lengths_to(c0)\n        c0 = c0.optimize_edge_lengths_to(c1)\n        p0 = Processed(original=o0, processed=c0)\n        p1 = Processed(original=o1, processed=c1)\n\n        flow = flow or WillmoreFlow()\n        solver = flow.solver(initial=c1, stop_tol=circle_stop_tol, history=False)\n        initial = solver.run().current\n\n        return CurvatureShapeBlending(\n            processed0=p0,\n            processed1=p1,\n            initial=initial,\n            flow=flow,\n        )\n</code></pre>"},{"location":"api/blend/#curvey.blend.CurvatureShapeBlending.original","title":"<code>original: tuple[Curve, Curve]</code>  <code>property</code>","text":"<p>The pair of original <code>Curve</code>s</p>"},{"location":"api/blend/#curvey.blend.CurvatureShapeBlending.processed","title":"<code>processed: tuple[Curve, Curve]</code>  <code>property</code>","text":"<p>The pair of processed <code>Curve</code>s</p>"},{"location":"api/blend/#curvey.blend.CurvatureShapeBlending.interpolate","title":"<code>interpolate(t: ndarray, path_dependent: bool = False, realign: bool = True, interp_size: Literal['length', 'area'] | None = 'length', interp_pos: Literal['center', 'centroid'] | None = 'center', reregister: bool = False, exact_endpoints: tuple[bool, bool] = (False, False), post_process: Callable[[Curve], Curve] | None = None, history: bool = False, **kwargs) -&gt; Curves</code>","text":"<p>Interpolate shape at the supplied time-points</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Vector of interpolation parameter values in [0, 1]</p> required <code>path_dependent</code> <code>bool</code> <p>If True, the resulting interpolated curve from each timepoint is used as the starting point for the next interpolation. Otherwise, each timepoint's flow is independently started from the <code>self.initial</code> curve.</p> <code>False</code> <code>realign</code> <code>bool</code> <p>If True, the curve after each interpolation step is aligned to the preceeding step. This can account for changes in position and orientation. Realignment is performed before transforming by the interpolated size or position.</p> <code>True</code> <code>interp_size</code> <code>Literal['length', 'area'] | None</code> <p>If not None, scale each interpolated curve to the area or length obtained by interpolating the <code>self.pair.orig</code> curves' length or area.</p> <code>'length'</code> <code>interp_pos</code> <code>Literal['center', 'centroid'] | None</code> <p>If not None, translate the interpolated curves' center or centroid to the position interpolated between the <code>self.pair.orig</code> curves' center or centroid.</p> <code>'center'</code> <code>reregister</code> <code>bool</code> <p>If True, perform a final post-processing step as follows: register the final interpolated curve against the original curve using the <code>Curve.register_to</code> iterative closest point algorithm. The total change in position, orientation, and scale is then interpolated by <code>t</code> for each interpolated curve. This generally assumes that 1) t=0 and t=1 are included in the interpolation points, and 2) <code>interp_size</code> and <code>interp_pos</code> are enabled so that the interpolated curve is close enough to the original curve for ICP to be successful.</p> <code>False</code> <code>exact_endpoints</code> <code>tuple[bool, bool]</code> <p>By default, the curves at t=0 and t=1 are found by the same targeted curvature flow as for the interior time points. This skips that step and simply uses <code>self.pair[t].processed</code> if <code>exact_endpoints[t] == True</code>, for <code>t = 0</code> and <code>t = 1</code>.</p> <code>(False, False)</code> <code>history</code> <code>bool</code> <p>If true, the history of each interpolating flow is stored in <code>self.history</code> as a length(t) <code>list[Curves]</code>.</p> <code>False</code> <code>post_process</code> <code>Callable[[Curve], Curve] | None</code> <p>An option function <code>Curve -&gt; Curve</code> to apply to each interpolated curve.</p> <code>None</code> <code>**kwargs</code> <p>Additional kwargs passed to <code>WillmoreFlow.solver</code> every interpolation step.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Curves</code> <p>A <code>Curves</code> of length <code>len(t)</code>.</p> Source code in <code>src\\curvey\\blend.py</code> <pre><code>def interpolate(\n    self,\n    t: ndarray,\n    path_dependent: bool = False,\n    realign: bool = True,\n    interp_size: Literal[\"length\", \"area\"] | None = \"length\",\n    interp_pos: Literal[\"center\", \"centroid\"] | None = \"center\",\n    reregister: bool = False,\n    exact_endpoints: tuple[bool, bool] = (False, False),\n    post_process: Callable[[Curve], Curve] | None = None,\n    history: bool = False,\n    **kwargs,\n) -&gt; Curves:\n    \"\"\"Interpolate shape at the supplied time-points\n\n    Parameters\n    ----------\n    t\n        Vector of interpolation parameter values in [0, 1]\n\n    path_dependent\n        If True, the resulting interpolated curve from each timepoint is used as the starting\n        point for the next interpolation. Otherwise, each timepoint's flow is independently\n        started from the `self.initial` curve.\n\n    realign\n        If True, the curve after each interpolation step is aligned to the preceeding step.\n        This can account for changes in position and orientation. Realignment is performed\n        before transforming by the interpolated size or position.\n\n    interp_size\n        If not None, scale each interpolated curve to the area or length obtained by\n        interpolating the `self.pair.orig` curves' length or area.\n\n    interp_pos\n        If not None, translate the interpolated curves' center or centroid to the position\n        interpolated between the `self.pair.orig` curves' center or centroid.\n\n    reregister\n        If True, perform a final post-processing step as follows: register the final\n        interpolated curve against the original curve using the `Curve.register_to`\n        iterative closest point algorithm. The total change in position, orientation, and\n        scale is then interpolated by `t` for each interpolated curve. This generally assumes\n        that 1) t=0 and t=1 are included in the interpolation points, and 2) `interp_size`\n        and `interp_pos` are enabled so that the interpolated curve is close enough to the\n        original curve for ICP to be successful.\n\n    exact_endpoints\n        By default, the curves at t=0 and t=1 are found by the same targeted curvature flow\n        as for the interior time points. This skips that step and simply uses\n        `self.pair[t].processed` if `exact_endpoints[t] == True`, for `t = 0` and `t = 1`.\n\n    history\n        If true, the history of each interpolating flow is stored in `self.history`\n        as a length(t) `list[Curves]`.\n\n    post_process\n        An option function `Curve -&gt; Curve` to apply to each interpolated curve.\n\n    **kwargs\n        Additional kwargs passed to `WillmoreFlow.solver` every interpolation step.\n\n    Returns\n    -------\n    Curves\n        A `Curves` of length `len(t)`.\n    \"\"\"\n    curves = Curves()\n    self.history = [] if history else None\n    initial = self.initial\n    raw = []  # Before interpolating size, position, etc\n\n    for i, t_interp in enumerate(t):\n        history_i, c_interp = self._interpolate_once(\n            t=t_interp,\n            initial=initial,\n            exact_endpoints=exact_endpoints,\n            **kwargs,\n        )\n        raw.append(c_interp)\n\n        if i &gt; 0 and realign:\n            c_interp = c_interp.align_to(raw[-1])\n\n        if interp_size == \"length\":\n            c_interp = c_interp.to_length(self._interpolate_length(t_interp))\n        elif interp_size == \"area\":\n            c_interp = c_interp.to_area(self._interpolate_area(t_interp))\n\n        if interp_pos:\n            pos = self._interpolate_position(t_interp, mode=interp_pos)\n            c_interp = c_interp.translate(pos)\n\n        if post_process:\n            c_interp = post_process(c_interp)\n\n        curves.append(c_interp)\n\n        if path_dependent:\n            initial = raw[-1]\n\n        if self.history is not None:\n            self.history.append(history_i)\n\n    if reregister:\n        curves = self._reregister(curves, t=t)\n\n    return curves\n</code></pre>"},{"location":"api/blend/#curvey.blend.CurvatureShapeBlending.preprocess","title":"<code>preprocess(c0: Curve, c1: Curve, flow: WillmoreFlow | None = None, circle_stop_tol=0.001) -&gt; CurvatureShapeBlending</code>  <code>staticmethod</code>","text":"<p>Preprocess a pair of curves for curvature shape blending</p> <p>Scales both curves to a common length and optimizes their edge length distributions. Also flows the first curve to a circle for use as the <code>initial</code> curve for flow-based interpolation.</p> Source code in <code>src\\curvey\\blend.py</code> <pre><code>@staticmethod\ndef preprocess(\n    c0: Curve,\n    c1: Curve,\n    flow: WillmoreFlow | None = None,\n    circle_stop_tol=1e-3,\n) -&gt; CurvatureShapeBlending:\n    \"\"\"Preprocess a pair of curves for curvature shape blending\n\n    Scales both curves to a common length and optimizes their edge length distributions.\n    Also flows the first curve to a circle for use as the `initial` curve for flow-based\n    interpolation.\n    \"\"\"\n    _ = c0.check_same_n_vertices(c1)\n    o0, o1 = c0, c1\n    c0, c1 = c0.to_length(1.0), c1.to_length(1.0)\n    c1 = c1.optimize_edge_lengths_to(c0)\n    c0 = c0.optimize_edge_lengths_to(c1)\n    p0 = Processed(original=o0, processed=c0)\n    p1 = Processed(original=o1, processed=c1)\n\n    flow = flow or WillmoreFlow()\n    solver = flow.solver(initial=c1, stop_tol=circle_stop_tol, history=False)\n    initial = solver.run().current\n\n    return CurvatureShapeBlending(\n        processed0=p0,\n        processed1=p1,\n        initial=initial,\n        flow=flow,\n    )\n</code></pre>"},{"location":"api/blend/#curvey.blend.LinearBlending","title":"<code>LinearBlending</code>","text":"<p>Linear vertex position interpolation</p> <p>Source and target curves must have the same number of vertices.</p> Source code in <code>src\\curvey\\blend.py</code> <pre><code>class LinearBlending:\n    \"\"\"Linear vertex position interpolation\n\n    Source and target curves must have the same number of vertices.\n    \"\"\"\n\n    def __init__(self, src: Curve, tgt: Curve):\n        _ = src.check_same_n_vertices(tgt)\n        self.src = src\n        self.tgt = tgt\n\n    def interpolate(self, t: ndarray) -&gt; Curves:\n        r\"\"\"Interpolate curves at the requested times\n\n        Parameters\n        ----------\n        t\n            Vector of length `nt` with $0 \\le t \\le 1$ of times to interpolate at.\n\n        Returns\n        -------\n        curves\n            A `Curves` object with `nt` curves. The value of `t` at each point\n            is stored in the curve metadata parameter 'time'.\n\n        \"\"\"\n        t_ = t.reshape((-1, 1, 1))  # (nt, 1, 1)\n        src_pts = self.src.points[newaxis, :, :]  # (1, n, 2)\n        tgt_pts = self.tgt.points[newaxis, :, :]  # (1, n, 2)\n        pts = (1 - t_) * src_pts + t_ * tgt_pts  # (nt, n, 2)\n        return Curves(self.src.with_points(p).with_data(time=ti) for (p, ti) in zip(pts, t))\n</code></pre>"},{"location":"api/blend/#curvey.blend.LinearBlending.interpolate","title":"<code>interpolate(t: ndarray) -&gt; Curves</code>","text":"<p>Interpolate curves at the requested times</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>ndarray</code> <p>Vector of length <code>nt</code> with \\(0 \\le t \\le 1\\) of times to interpolate at.</p> required <p>Returns:</p> Type Description <code>curves</code> <p>A <code>Curves</code> object with <code>nt</code> curves. The value of <code>t</code> at each point is stored in the curve metadata parameter 'time'.</p> Source code in <code>src\\curvey\\blend.py</code> <pre><code>def interpolate(self, t: ndarray) -&gt; Curves:\n    r\"\"\"Interpolate curves at the requested times\n\n    Parameters\n    ----------\n    t\n        Vector of length `nt` with $0 \\le t \\le 1$ of times to interpolate at.\n\n    Returns\n    -------\n    curves\n        A `Curves` object with `nt` curves. The value of `t` at each point\n        is stored in the curve metadata parameter 'time'.\n\n    \"\"\"\n    t_ = t.reshape((-1, 1, 1))  # (nt, 1, 1)\n    src_pts = self.src.points[newaxis, :, :]  # (1, n, 2)\n    tgt_pts = self.tgt.points[newaxis, :, :]  # (1, n, 2)\n    pts = (1 - t_) * src_pts + t_ * tgt_pts  # (nt, n, 2)\n    return Curves(self.src.with_points(p).with_data(time=ti) for (p, ti) in zip(pts, t))\n</code></pre>"},{"location":"api/blend/#curvey.blend.Processed","title":"<code>Processed</code>  <code>dataclass</code>","text":"<p>Convenience class to store a curve in both its original and processed version</p> Source code in <code>src\\curvey\\blend.py</code> <pre><code>@dataclass\nclass Processed:\n    \"\"\"Convenience class to store a curve in both its original and processed version\"\"\"\n\n    original: Curve\n    \"\"\"The original untouched curve\"\"\"\n\n    processed: Curve\n    \"\"\"The curve after resampling and rescaling, etc\"\"\"\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}(original={self.original}, processed={self.processed})\"\n</code></pre>"},{"location":"api/blend/#curvey.blend.Processed.original","title":"<code>original: Curve</code>  <code>instance-attribute</code>","text":"<p>The original untouched curve</p>"},{"location":"api/blend/#curvey.blend.Processed.processed","title":"<code>processed: Curve</code>  <code>instance-attribute</code>","text":"<p>The curve after resampling and rescaling, etc</p>"},{"location":"api/curve/","title":"curvey.curve","text":""},{"location":"api/curve/#curvey.curve.Curve","title":"<code>Curve</code>","text":"<p>A discrete planar closed curve</p> <p>Parameters:</p> Name Type Description Default <code>pts</code> <code>ndarray | Sequence[Sequence[float] | tuple[float, float]] | ArrayLike</code> <p><code>(n, 2)</code> array of vertex coordinates.</p> required <code>**kwargs</code> <p>Metadata parameters in key=value format.</p> <code>{}</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>class Curve:\n    \"\"\"A discrete planar closed curve\n\n    Parameters\n    ----------\n    pts\n        `(n, 2)` array of vertex coordinates.\n\n    **kwargs\n        Metadata parameters in key=value format.\n    \"\"\"\n\n    def __init__(\n        self,\n        pts: ndarray | Sequence[Sequence[float] | tuple[float, float]] | ArrayLike,\n        _data: dict[str, Any] | None = None,\n        **kwargs,\n    ):\n        # Use `asanyarray` here to allow the user to pass in whatever they want as long as it obeys\n        # the numpy array protocol; in particular thinking of arrays of dual numbers for automatic\n        # differentiation\n        pts = asanyarray(pts)\n\n        if pts.ndim != 2:\n            msg = f\"Points array must be 2-dimensional, got pts.ndims={pts.ndim}\"\n            raise WrongDimensions(msg)\n\n        if pts.shape[1] != 2:\n            msg = f\"Points array must have 2 columns, got pts.shape={pts.shape}\"\n            raise WrongDimensions(msg)\n\n        if pts.shape[0] &lt; 3:\n            msg = f\"Need at least 3 points for a curve, got {pts.shape[0]}\"\n            raise NotEnoughPoints(msg)\n\n        self._pts: ndarray = pts\n\n        if kwargs and _data:\n            self._data = {**_data, **kwargs}\n        elif kwargs:\n            self._data = kwargs\n        elif _data:\n            self._data = _data\n        else:\n            self._data = {}\n\n    @cached_property\n    def points(self) -&gt; ndarray:\n        \"\"\"A `(n, 2)` array of curve vertex coordinates\"\"\"\n        # Because we rely so heavily on `cached_property`s, prevent confusion due to stuff\n        # like `curve.points *= 2` modifying the points array in place\n        # Could just set this flag on `Curve` construction but\n        #   1) The user owns the original array, not us, so don't set flag in place\n        #   2) Don't want to copy the points array on construction, that's needlessly wasteful\n        #   3) Assume a lot of curve construction happens from fluent chaining like\n        #      `curve.scale(2).translate([3, 3]).to_length(1) where the public `points` array is\n        #       never touched\n        pts = self._pts.view()\n        pts.flags[\"WRITEABLE\"] = False\n        return pts\n\n    def __getitem__(self, item: str) -&gt; Any:\n        \"\"\"Get curve metadata value by key name\n\n        `curve['foo']` returns the value of the metadata parameter 'foo'.\n\n        \"\"\"\n        return self._data[item]\n\n    @property\n    def data(self) -&gt; MappingProxyType[str, Any]:\n        \"\"\"A read-only view of the curve's metadata\"\"\"\n        return MappingProxyType(self._data)\n\n    def with_points(self, pts: ndarray) -&gt; Curve:\n        \"\"\"A curve with the newly supplied points array, but same metadata values\"\"\"\n        # We can share the data dict here without a copy because it's publicly read-only\n        return self.__class__(pts=pts, _data=self._data)\n\n    def with_data(self, **kwargs) -&gt; Curve:\n        \"\"\"A new curve with the same points and metadata appended with the supplied metadata\n\n        E.g. `curve.with_data(foo=1, bar=2).with_data(baz=3)` has metadata parameters\n        'foo', 'bar', and 'baz'.\n\n        This allows without complaint overwriting previous metadata.\n\n        Parameters\n        ----------\n        **kwargs\n            New metadata in key=value format\n\n        \"\"\"\n        return self.__class__(self._pts, _data={**self._data, **kwargs})\n\n    def drop_data(self, *args: str) -&gt; Curve:\n        \"\"\"Copy of the curve without the listed metadata parameters\n\n        Use `curve.drop_data(*curve.data.keys())` to drop all data.\n        \"\"\"\n        to_drop = set(args)\n        data = {k: v for k, v in self._data.items() if k not in to_drop}\n        return self.__class__(self._pts, _data=data)\n\n    @property\n    def n(self) -&gt; int:\n        \"\"\"The number of vertices\n\n        (or the number of edges, since this is a closed curve)\n\n        \"\"\"\n        return len(self._pts)\n\n    def __repr__(self):\n        typ = self.__class__.__name__\n\n        if self._data:\n            metadata = \", \".join(f\"{k}={v}\" for k, v in self._data.items())\n            return f\"{typ}(n={self.n}, {metadata})\"\n\n        return f\"{typ}(n={self.n})\"\n\n    @property\n    def x(self) -&gt; ndarray:\n        \"\"\"The x-component of the curve vertices\"\"\"\n        return self._pts[:, 0]\n\n    @property\n    def y(self) -&gt; ndarray:\n        \"\"\"The y-component of the curve vertices\"\"\"\n        return self._pts[:, 1]\n\n    @property\n    def closed_points(self) -&gt; ndarray:\n        \"\"\"A `(n+1, 2)` array of the vertex coordinates where the last row is equal to the first\n\n        Curvey uses an implicitly closed representation, assuming an edge exists between the last\n        and first point, i.e. in general `curve.points[0] != curve.points[-1]`. Sometimes\n        it's useful to have an explicit representation.\n\n        \"\"\"\n        return concatenate([self._pts, self._pts[[0]]], axis=0)\n\n    def reverse(self, keep_first=False) -&gt; Curve:\n        \"\"\"Reverse the curve orientation\n\n        Flips between clockwise and counter-clockwise orientation\n\n        Parameters\n        ----------\n        keep_first\n            By default, the list of vertices is simply flipped. This changes which point is first.\n            If `keep_first` is True, the points are also rolled so the first point is maintained.\n        \"\"\"\n        pts = self._pts[::-1]\n\n        if keep_first:\n            pts = roll(pts, 1, axis=0)\n\n        return self.with_points(pts)\n\n    def scale(self, scale: float) -&gt; Curve:\n        \"\"\"Scale vertex positions by a constant\"\"\"\n        return self.with_points(scale * self._pts)\n\n    def translate(self, offset: ndarray | Literal[\"center\", \"centroid\"]) -&gt; Curve:\n        \"\"\"Translate the curve\n\n        Parameters\n        ----------\n        offset\n            One of\n                - A 2 element vector `(dx, dy)`\n                - A `(n, 2)` array of `(dx, dy)` translations\n                - The string 'center' or `centroid`, in which case the curve is translated so that\n                  point sits on the origin.\n        \"\"\"\n        if isinstance(offset, str):\n            if offset == \"center\":\n                offset = -self.center\n            elif offset == \"centroid\":\n                offset = -self.centroid\n            else:\n                raise ValueError(offset)\n        else:\n            offset = asarray(offset)\n\n        return self.with_points(self._pts + offset.reshape((-1, 2)))\n\n    def roll(self, shift: int) -&gt; Curve:\n        \"\"\"Circular permutation of the vertex order\n\n        To make vertex `i` the first vertex, use `curve.roll(-i)`.\n        \"\"\"\n        return self.with_points(roll(self._pts, shift, axis=0))\n\n    def rotate(self, theta: float) -&gt; Curve:\n        \"\"\"Rotate the curve about the origin\n\n        Parameters\n        ----------\n        theta\n            Angle in radians to rotate the curve. Positive angles are counter-clockwise.\n        \"\"\"\n        return self.transform(rotation_matrix(theta))\n\n    def reflect(self, theta: float | Literal[\"x\", \"X\", \"y\", \"Y\"]) -&gt; Curve:\n        \"\"\"Reflect the curve over a line through the origin\n\n        Parameters\n        ----------\n        theta\n            Angle in radians of the reflection line through the origin.\n            If `theta` is the string 'x' or 'y', reflect over that axis.\n        \"\"\"\n        if isinstance(theta, str):\n            if theta in (\"x\", \"X\"):\n                transform = reflection_matrix(0)\n            elif theta in (\"y\", \"Y\"):\n                transform = reflection_matrix(pi / 2)\n            else:\n                msg = \"Theta can only 'x', 'y', or an angle in radians\"\n                raise ValueError(msg)\n        else:\n            transform = reflection_matrix(theta)\n\n        return self.transform(transform)\n\n    @cached_property\n    def center(self) -&gt; ndarray:\n        \"\"\"The average vertex position\"\"\"\n        return self._pts.mean(axis=0)\n\n    @cached_property\n    def centroid(self) -&gt; ndarray:\n        \"\"\"The center of mass of the uniformly weighted polygon enclosed by the curve\"\"\"\n        # https://en.wikipedia.org/wiki/Centroid#Of_a_polygon\n        pts0, pts1 = self._pts, roll(self._pts, -1, axis=0)\n        # xy = (x0 * y1 - x1 * y0)\n        xy = (pts0 * pts1[:, ::-1] * array([[1, -1]])).sum(axis=1, keepdims=True)\n        return ((pts0 + pts1) * xy).sum(axis=0) / 6 / self.signed_area\n\n    @cached_property\n    def edge(self) -&gt; ndarray:\n        \"\"\"The vectors from vertex `i` to `i+1`\n\n        See also\n        --------\n        [Curve.unit_edge][curvey.curve.Curve.unit_edge]\n            For unit edge vectors.\n        \"\"\"\n        pts0, pts1 = self._pts, roll(self._pts, -1, axis=0)\n        return pts1 - pts0\n\n    def to_edge_midpoints(self) -&gt; Curve:\n        \"\"\"The curve whose vertices are the midpoints of this curve's edges\n\n        Mostly just useful for plotting scalar quantities on edge midpoints.\n        \"\"\"\n        pts = self._pts + self.edge / 2\n        return self.with_points(pts)\n\n    @cached_property\n    def edge_length(self) -&gt; ndarray:\n        \"\"\"Curve edge lengths\n\n        `edge_length[i]` is the length of the edge from vertex `i` to vertex `i+1`.\n\n        See also\n        --------\n        [Curve.cum_edge_length][curvey.curve.Curve.cum_edge_length]\n            Cumulative egde lengths.\n        \"\"\"\n        return norm(self.edge, axis=1)\n\n    @cached_property\n    def length(self) -&gt; float:\n        \"\"\"Total arclength; the sum of edge lengths\"\"\"\n        return self.edge_length.sum()\n\n    @cached_property\n    def unit_edge(self) -&gt; ndarray:\n        \"\"\"The unit edge vectors from vertex `i` to `i+1`\n\n        See also\n        --------\n        [Curve.tangent][curvey.curve.Curve.tangent]\n            For unit tangent vectors calculated from second-order finite differences.\n        \"\"\"\n        return self.edge / self.edge_length[:, newaxis]\n\n    @cached_property\n    def edge_normal(self) -&gt; ndarray:\n        r\"\"\"Unit edge normals\n\n        `edge_normal[i]` is the unit vector normal to the edge from vertex `i` to `i+1`.\n\n        Normals are computed by rotating the unit edge vectors 90 degrees counter-clockwise.\n\n        For a counter-clockwise-oriented curve, this means that normals point inwards.\n\n        See also\n        --------\n        [Curve.normal][curvey.curve.Curve.normal]\n            Vertex normals calculated from 2nd order finite differences.\n        \"\"\"\n        dx, dy = self.unit_edge.T\n        # (x, y) -&gt; (-y, x) for 90 degrees CCW rotation\n        return stack([-dy, dx], axis=1)\n\n    @cached_property\n    def cum_edge_length(self) -&gt; ndarray:\n        \"\"\"Cumulative edge lengths\n\n        Simply equal to `np.cumsum(self.edge_length)`.\n\n        `cum_edge_length` is a length `n` vector, and does not include zero,\n        i.e. `curve.cum_edge_lengths[0]` is the length of the first edge, and\n        `curve.cum_edge_length[-1]` == `curve.length`.\n\n        See also\n        --------\n        [Curve.arclength][curvey.curve.Curve.arclength]\n            Vertex arclength, like `cum_edge_length` but starts at 0.\n        \"\"\"\n        return cumsum(self.edge_length)\n\n    @property\n    def arclength(self) -&gt; ndarray:\n        \"\"\"Vertex arclengths\n\n        `arclength` is a length `n` vector, where `arclength[i]` is the arclength\n        of the `i`th vertex. `arclength[0]` is always zero. `arclength[i]` for `i&gt;0` is equal to\n        `cum_edge_length[i-1].\n\n        See also\n        --------\n        [Curve.closed_arclength][curvey.curve.Curve.closed_arclength]\n            Like `arclength`, but also includes `self.length` as the final element.\n        \"\"\"\n        return append(0, self.cum_edge_length[:-1])\n\n    @property\n    def closed_arclength(self) -&gt; ndarray:\n        \"\"\"Cumulative edge lengths with zero prepended\n\n        `closed_arclength` is a length `n+1` vector, where the first element is `0`, the\n        second element is the length of the first edge, and the last element is the cumulative\n        length of all edges, `curve.length`.\n        \"\"\"\n        return append(0, self.cum_edge_length)\n\n    @cached_property\n    def dual_edge_length(self) -&gt; ndarray:\n        \"\"\"Vertex dual edge lengths\n\n        `curve.dual_edge_length[i]` is the average length of the two edges incident on vertex $i$,\n        i.e. $(L_{i-1, i} + L_{i, i+1})/2$  where $L_{ij}$ is the edge length between vertex\n        $i$ and vertex $j$.\n        \"\"\"\n        l_next = self.edge_length  # from vertex i to i+1\n        l_prev = roll(l_next, 1)  # from i-1 to i\n        return (l_prev + l_next) / 2\n\n    @cached_property\n    def tangent(self) -&gt; ndarray:\n        \"\"\"Unit length tangent vectors\n\n        `tangent[i]` is the curve unit tangent vector at vertex `i`. This is constructed from\n        second order finite differences; use `Curve.unit_edge` for the exact vector from\n        vertex `i` to vertex `i+1`.\n        \"\"\"\n        # return self.edge / self.edge_length[:, newaxis]\n        df_ds = self.deriv()\n        df_ds /= norm(df_ds, axis=1, keepdims=True)\n        return df_ds\n\n    @cached_property\n    def normal(self) -&gt; ndarray:\n        r\"\"\"Vertex unit normal vectors\n\n        Normals are computed by rotating the unit tangents 90 degrees counter-clockwise, so that\n        $\\left[ T_i, N_i, 1 \\right]$ forms a right-handed frame at vertex $i$ with tangent $T_i$ and\n        normal $N_i$.\n\n        For a counter-clockwise-oriented curve, this means that normals point inwards.\n\n        See also\n        --------\n        [Curve.edge_normal][curvey.curve.Curve.edge_normal]\n            The exact unit normals for each edge.\n        \"\"\"\n        dx, dy = self.tangent.T\n        # (x, y) -&gt; (-y, x) for 90 degrees CCW rotation\n        return stack([-dy, dx], axis=1)\n\n    @cached_property\n    def turning_angle(self) -&gt; ndarray:\n        r\"\"\"Turning angle (a.k.a exterior angle), in radians between adjacent edges\n\n        `curve.turning_angle[i]` is the angle between the vectors $T_{i-1, i}$ and $T_{i, i+1}$\n        where $T_{ij}$ is the vector from vertex $i$ to vertex $j$.\n\n        Angles are in the range $\\pm \\pi$.\n        \"\"\"\n        e_next = self.edge  # from vertex i to i+1\n        e_prev = roll(e_next, 1, axis=0)  # from i-1 to i\n        cos_theta = (e_prev * e_next).sum(axis=1)\n        sin_theta = cross(e_prev, e_next)\n        return arctan2(sin_theta, cos_theta)\n\n    @cached_property\n    def curvature(self) -&gt; ndarray:\n        r\"\"\"Length `n` vector of signed vertex curvatures\n\n        Computed as\n        $$\n        \\kappa_i = \\frac {2 \\psi_i}{L_{i-1, i} + L_{i, i+1}}\n        $$\n        Where $\\psi_i$ is the turning angle between the two edges adjacent to vertex $i$,\n        and $L_{ij}$ is the length of the edge between vertex $i$ and $j$.\n\n        Note\n        ----\n        There are multiple ways to reasonably define discrete curvature. (See Table 1 in\n        Vouga 2014 for a summary of their tradeoffs.) One is chosen here for\n        convenience; most of the curvature flows in `curvey.flow` accept a `curvature_fn` to allow\n        this choice to be overridden.\n        \"\"\"\n        # NB self.dual_edge_length already includes the factor 2 term in the equation above\n        return self.turning_angle / self.dual_edge_length\n\n    def deriv(self, f: ndarray | None = None) -&gt; ndarray:\n        \"\"\"Second order finite differences approximations of arclength-parametrized derivatives\n\n        Derivatives are calculated by circularly padding the arclength `s` and function values\n        `f(s)`, passing those to `numpy.gradient` to calculate second order finite differences,\n        and then dropping the padded values.\n\n        `f` is the function values to derivate. By default, this is the curve points, so\n        `curve.deriv()` computes the curve tangent. Repeated application will compute the second\n        derivative, e.g.\n\n        ```python\n        from curvey import Curve\n\n        c = Curve.circle(n=20)\n        df_ds = c.deriv()\n        d2f_ds2 = c.deriv(f=df_ds)\n        ```\n\n        Parameters\n        ----------\n        f\n            The `(n,)` or `(n, ndim)` array of function values. Defaults to `self.points`\n\n        Returns\n        -------\n        deriv :\n            The `(n,)` or `(n, ndim)` array of function derivature values.\n\n        \"\"\"\n        if f is None:\n            f = self._pts\n\n        # Circularly pad arrays so that the derivatives of the first and last actual points are\n        # calculated in the same way as the interior points\n        f_periodic = concatenate([f[[-1]], f, f[[0]]], axis=0)\n        s = self.cum_edge_length\n        s = concatenate([[-self.edge_length[-1], 0], s])\n        df_ds = gradient(f_periodic, s, axis=0)\n        return df_ds[1:-1]  # Drop padded points\n\n    @cached_property\n    def signed_area(self) -&gt; float:\n        \"\"\"Signed area of the polygon enclosed by the curve\n\n        Signed area is positive if the curve is oriented counter-clockwise.\n\n        Calculated by the [shoelace formula](https://en.wikipedia.org/wiki/Shoelace_formula).\n        \"\"\"\n        x0, y0 = self._pts.T\n        x1, y1 = roll(self._pts, -1, axis=0).T\n        return 0.5 * (x0 * y1 - x1 * y0).sum()\n\n    @cached_property\n    def area(self) -&gt; float:\n        \"\"\"Absolute area of the polygon enclosed by the curve\"\"\"\n        return abs(self.signed_area)\n\n    @cached_property\n    def orientation(self) -&gt; int:\n        \"\"\"Orientation of the curve\n\n        Integer-valued; `+1` if curve is oriented counterclockwise, `-1` if clockwise, 0 if zero\n        area\n\n        \"\"\"\n        return int(sign(self.signed_area))\n\n    def to_ccw(self) -&gt; Curve:\n        \"\"\"A counterclockwise-oriented curve\"\"\"\n        return self.reverse() if self.signed_area &lt; 0 else self\n\n    def to_cw(self) -&gt; Curve:\n        \"\"\"A clockwise-oriented curve\"\"\"\n        return self.reverse() if self.signed_area &gt; 0 else self\n\n    def to_orientation(self, orientation: int) -&gt; Curve:\n        \"\"\"A curve with the specified orientation\n\n        Parameters\n        ----------\n        orientation\n            Must be either 1 or -1.\n        \"\"\"\n        if orientation not in (1, -1):\n            msg = f\"orientation must be either 1 or -1, got {orientation}\"\n            raise ValueError(msg)\n\n        return self.reverse() if self.orientation != orientation else self\n\n    def orient_to(self, other: Curve) -&gt; Curve:\n        \"\"\"A curve with the same orientation as `other`\"\"\"\n        return self.to_orientation(other.orientation)\n\n    @cached_property\n    def roundness(self) -&gt; float:\n        r\"\"\"The [roundness](https://en.wikipedia.org/wiki/Roundness) of the curve\n\n        Defined here as $P^2 / 4 \\pi A$ for perimeter $P$ and area $A$.\n\n        Equal to 1.0 for a circle and larger otherwise.\n        \"\"\"\n        return self.length**2 / 4 / pi / self.area\n\n    @classmethod\n    def circle(cls, n: int, r: float = 1.0) -&gt; Self:\n        \"\"\"Construct a regular polygon\n\n        Parameters\n        ----------\n        n\n            Number of vertices.\n\n        r\n            The radius.\n        \"\"\"\n        theta = linspace(0, 2 * pi, n, endpoint=False)\n        return cls(r * angle_to_points(theta))\n\n    @classmethod\n    def ellipse(cls, n: int, ra: float, rb: float) -&gt; Self:\n        \"\"\"Construct an ellipse\n\n        Parameters\n        ----------\n        n\n            Number of vertices.\n\n        ra\n            Major radius.\n\n        rb\n            Minor radius.\n\n        \"\"\"\n        theta = linspace(0, 2 * pi, n, endpoint=False)\n        pts = array([[ra, rb]]) * angle_to_points(theta)\n        return cls(pts)\n\n    @classmethod\n    def star(cls, n: int, r0: float, r1: float) -&gt; Self:\n        \"\"\"Construct a (isotoxal) star polygon with `n` corner vertices\n\n        Parameters\n        ----------\n        n\n            The number of corner vertices. The returned curve has `2n` vertices.\n\n        r0\n            Radius of the even vertices.\n\n        r1\n            Radius of the odd vertices.\n\n        \"\"\"\n        c = Curve.circle(n=2 * n, r=1)\n        r = where(arange(c.n) % 2, r1, r0)\n        return cls(r[:, newaxis] * c._pts)\n\n    @classmethod\n    def dumbbell(cls, n: int, rx: float = 2, ry: float = 2, neck: float = 0.2) -&gt; Self:\n        \"\"\"Construct a dumbbell shape\n\n        Parameters\n        ----------\n        n\n            Number of points\n\n        rx\n            Width parameter\n\n        ry\n            Height parameter\n\n        neck\n            Height of the pinched neck\n        \"\"\"\n        t = np.linspace(0, 1, n, endpoint=False)\n        z = 2 * pi * t\n        x = rx * cos(z)\n        y = ry * sin(z) - (ry - neck) * sin(z) ** 3\n        return cls(np.stack([x, y], axis=1))\n\n    def drop_repeated_points(self) -&gt; Curve:\n        \"\"\"Drop points that are equal to their predecessor(s)\n\n        Repeated points result in edges with zero length and are probably bad. This will also drop\n        the last point if it's equal to the first.\n        \"\"\"\n        # NB closed_points adds the first point to the end,\n        # and `diff` returns a vector one element shorter than its argument, so it all works out\n        distinct = diff(self.closed_points, axis=0).any(axis=1)\n        return self.with_points(self._pts[distinct])\n\n    def interpolator(\n        self,\n        typ: InterpType = \"cubic\",\n        f: ndarray | None = None,\n    ) -&gt; Callable[[ndarray], ndarray]:\n        \"\"\"Construct a function interpolator on curve arclength\n\n        Parameters\n        ----------\n        typ\n            The class of spline to use for interpolation. One of 'linear', 'cubic', or\n            'pchip'.\n\n        f\n            The (n_verts,) or (n_verts, ndim) array of function values to interpolate. By default,\n            this is just the vertex positions.\n\n        Returns\n        -------\n        interpolator :\n            A function g(s) `ndarray -&gt; ndarray` that interpolates values of f at the arclengths s.\n        \"\"\"\n        f = self._pts if f is None else f\n        return periodic_interpolator(self.closed_arclength, f, typ=typ)\n\n    def interpolate(self, s: ndarray, typ: InterpType = \"cubic\") -&gt; Curve:\n        \"\"\"Construct a new curve by interpolating vertex coordinates at the supplied arclengths\n\n        Parameters\n        ----------\n        s\n            Arclength values to interpolate at.\n\n        typ\n            Type of interpolation, one of ('linear', 'cubic', 'pchip').\n        \"\"\"\n        pts = self.interpolator(typ=typ, f=self._pts)(s)\n        return self.with_points(pts)\n\n    def interpolate_n(self, n: int, typ: InterpType = \"cubic\") -&gt; Curve:\n        \"\"\"Interpolate `n` evenly spaced sampled\n\n        Simple convenience wrapper around `Curve.interpolate`.\n\n        Parameters\n        ----------\n        n\n            The number of points in the new curve\n\n        typ\n            Interpolation type.\n        \"\"\"\n        s_new = linspace(0, self.length, n, endpoint=False)\n        return self.interpolate(s=s_new, typ=typ)\n\n    def interpolate_thresh(self, thresh: float, typ: InterpType = \"cubic\") -&gt; Curve:\n        \"\"\"Interpolate with `thresh` spacing between samples.\n\n        Simple convenience wrapper around `Curve.interpolate`.\n\n        Parameters\n        ----------\n        thresh\n            Maximum arclength spacing.\n\n        typ\n            Interpolation type.\n        \"\"\"\n        n = int(ceil(self.length / thresh))\n        n = max(n, 3)\n        return self.interpolate_n(n=n, typ=typ)\n\n    @overload\n    def align_to(self, target: Curve, *, return_transform: Literal[False] = False) -&gt; Curve: ...\n\n    @overload\n    def align_to(self, target: Curve, *, return_transform: Literal[True]) -&gt; ndarray: ...\n\n    def align_to(self, target: Curve, *, return_transform: bool = False) -&gt; Curve | ndarray:\n        \"\"\"Align to another curve by removing mean change in position and edge orientation\n\n        Parameters\n        ----------\n        target\n            The target curve to align to. It must have the same number of vertices as `self`. The\n            edges of the other curve are assumed to be in one-to-one correspondance to the edges in\n            `self`.\n\n        return_transform\n            If true, return the 3x3 transformation matrix. Otherwise, return a `Curve`\n\n        See also\n        --------\n        [Curve.register_to][curvey.curve.Curve.register_to]\n            Iterative closest point registration, which doesn't require corresponding vertices.\n\n        \"\"\"\n        _ = self.check_same_n_vertices(target)\n\n        if return_transform:\n            return align_edges(\n                self._pts, self.edge, target._pts, target.edge, return_transform=True\n            )\n\n        pts = align_edges(self._pts, self.edge, target._pts, target.edge, return_transform=False)\n\n        return self.with_points(pts)\n\n    def plot(self, color=\"black\", ax: Axes | None = None, **kwargs) -&gt; Line2D:\n        \"\"\"Plot the curve as a closed contour\n\n        For more sophisticated plotting see methods `plot_points`, `plot_edges`, and `plot_vectors`.\n\n        Parameters\n        ----------\n        color\n            A matplotlib colorlike.\n\n        ax\n            Defaults to the current axes.\n\n        **kwargs\n            additional kwargs passed to `matplotlib.pyplot.plot`\n\n        \"\"\"\n        ax = _get_ax(ax)\n        (line,) = ax.plot(*self.closed_points.T, color=color, **kwargs)\n        return line\n\n    def plot_edges(\n        self,\n        color: ndarray | None = None,\n        directed: bool = True,\n        width: float | ndarray | None = None,\n        scale_width: tuple[float, float] | None = None,\n        ax: Axes | None = None,\n        **kwargs,\n    ) -&gt; Quiver | LineCollection:\n        \"\"\"Plot a scalar quantity on curve edges\n\n        Parameters\n        ----------\n        color\n            The color to plot each edge. Defaults to curve arc length.\n\n        directed\n            If True, plot edges as arrows between vertices. Otherwise, edges are line segments.\n\n        width\n            The thickness of each edge segment, scalar or edge quantity vector.\n\n        scale_width\n            Min and max widths to scale the edge quantity to.\n\n        ax\n            The matplotlib axes to plot in. Defaults to current axes.\n\n        **kwargs\n            Aadditional kwargs passed to `plt.quiver` or `LineCollection` depending on `directed`.\n\n        Returns\n        -------\n        : matplotlib.quiver.Quiver\n            If `directed` is True.\n\n        : matplotlib.collections.LineCollection\n            If `directed` is False.\n        \"\"\"\n        ax = _get_ax(ax)\n        width = _rescale(width, scale_width)\n        colorspec = _VariableColorSpec.parse(\n            n_data=self.n, supplied=color, default_varied=self.arclength\n        )\n\n        if directed:\n            if isinstance(width, (collections.abc.Sequence, ndarray)):\n                msg = (\n                    \"`width` was supplied as a sequence but \"\n                    \"matplotlib.pyplot.Quiver doesn't support scaling individual arrows. \"\n                    \"Use directed=False to scale edge width.\"\n                )\n                raise ValueError(msg)\n\n            x, y = self._pts.T\n            dx, dy = self.edge.T\n            return ax.quiver(\n                x,\n                y,\n                dx,\n                dy,\n                *colorspec.maybe_varied,\n                color=colorspec.fixed,\n                angles=\"xy\",\n                scale_units=\"xy\",\n                scale=1.0,\n                width=width,\n                **kwargs,\n            )\n\n        # not directed\n        pts = self.closed_points.reshape((-1, 1, 2))\n        segments = concatenate([pts[:-1], pts[1:]], axis=1)\n\n        if colorspec.varied is not None:\n            lc = LineCollection(\n                segments=segments,\n                cmap=\"viridis\",\n                norm=plt.Normalize(),\n                linewidths=width,\n                **kwargs,\n            )\n            lc.set_array(colorspec.varied)\n        else:\n            lc = LineCollection(segments=segments, color=colorspec.fixed, linewidths=width)\n        ax.add_collection(lc)\n\n        # Adding a line collection doesn't update limits so do it here\n        ax.update_datalim(self._pts)\n        ax.autoscale_view()\n        return lc\n\n    def plot_vectors(\n        self,\n        vectors: ndarray | None = None,\n        scale: ndarray | None = None,\n        color=None,\n        scale_length: tuple[float, float] | None = None,\n        ax: Axes | None = None,\n        **kwargs,\n    ) -&gt; Quiver:\n        \"\"\"Plot vector quantities on curve vertices\n\n        To plot vector quantities on edges use `curve.to_edge_midpoints.plot_vectors(...)`.\n\n        Parameters\n        ----------\n        vectors\n            A `(n, 2)` array of vectors. Defaults to curve normals.\n\n        scale\n            A length `n` vector of length scalars to apply to the vectors.\n\n        color\n            Length `n` vector of scalar vertex quantities to color by, or a\n            constant color for all edges.\n\n        scale_length\n            Limits to scale vector length to, after applying `scale`.\n\n        ax\n            The axes to plot in. Defaults to the current axes.\n\n        **kwargs\n            additional kwargs passed to `matplotlib.pyplot.quiver`\n        \"\"\"\n        ax = _get_ax(ax)\n\n        _vectors = self.normal if vectors is None else vectors\n\n        if scale is not None:\n            _vectors = scale.reshape(-1, 1) * _vectors\n\n        if scale_length is not None:\n            length = norm(_vectors, axis=1, keepdims=True)\n            scaled_length = _rescale(length, scale_length)\n            _vectors = _vectors / length * scaled_length\n\n        colorspec = _VariableColorSpec.parse(self.n, color, default_fixed=\"black\")\n\n        # By default quiver doesn't include vector endpoints in x/y lim calculations\n        ax.update_datalim(self._pts + _vectors)\n\n        x, y = self._pts.T\n        dx, dy = _vectors.T\n        return ax.quiver(\n            x,\n            y,\n            dx,\n            dy,\n            *colorspec.maybe_varied,\n            color=colorspec.fixed,\n            angles=\"xy\",\n            scale_units=\"xy\",\n            scale=1.0,\n            **kwargs,\n        )\n\n    def plot_points(\n        self,\n        color: ndarray | Any | None = None,\n        size: ndarray | float | None = None,\n        scale_sz: tuple[float, float] | None = None,\n        ax: Axes | None = None,\n        **kwargs,\n    ) -&gt; PathCollection:\n        \"\"\"Plot a scalar quantity on curve vertices\n\n        Parameters\n        -----------\n        color\n            Either a matplotlib scalar colorlike or length `n` array of scalar vertex\n            quantities. Defaults to `self.dual_edge_length`.\n\n        size\n            Length `n` scalar vertex quantity to size markers by, or a fixed size\n            for all vertices.\n\n        scale_sz\n            Min and max sizes to scale the vertex quantity `size` to.\n\n        ax\n            Matplotlib axes to plot in. Defaults to the current axes.\n\n        **kwargs\n            additional kwargs passed to `matplotlib.pyplot.scatter`\n\n        \"\"\"\n        ax = _get_ax(ax)\n\n        if color is None:\n            color = self.dual_edge_length\n\n        size = _rescale(size, scale_sz)\n\n        return ax.scatter(self.x, self.y, s=size, c=color, **kwargs)\n\n    def triangulate(\n        self,\n        max_tri_area: float | None = None,\n        min_angle: float | None = None,\n        extra_params: str | None = None,\n    ) -&gt; tuple[ndarray, ndarray, ndarray]:\n        \"\"\"Triangulate the polygon enclosed by the curve with Shewchuck's triangulation library\n\n        The python bindings [triangle](https://rufat.be/triangle/index.html) must be importable.\n        They can be installed with `pip install triangle`.\n\n        Parameters\n        ----------\n        max_tri_area: float, optional\n            A global maximum triangle area constraint.\n\n        min_angle: float, optional\n            Minimum angle constraint, in degrees.\n\n        extra_params: str, optional\n            See the [API documentation](https://rufat.be/triangle/API.html).\n            E.g. `extra_params='S10X' specifies a maximum number of 10 Steiner points and suppresses\n            exact arithmetic.\n\n        Returns\n        -------\n        points :\n            The `(n, 2)` vertex coordinates of the triangulation. If `max_tri_area=None`,\n            this is probably equal to `self.points`\n\n        tris :\n            `(n_tris, 3)` array of integer vertex indices.\n\n        is_border :\n            Length `n` vector of booleans, true for vertices on the border of the triangulation.\n\n        \"\"\"\n        try:\n            import triangle\n        except ImportError as e:\n            msg = \"Cannot import `triangle`. Use `pip install triangle` to install.\"\n            raise ValueError(msg) from e\n\n        idx = arange(self.n)\n        segments = stack([idx, roll(idx, -1)], axis=1)\n        params = \"p\"  # Constrained polygon triangulation\n        if max_tri_area is not None:\n            params += f\"a{max_tri_area: f}\"\n        if min_angle is not None:\n            params += f\"q{min_angle: f}\"\n        if extra_params is not None:\n            params += extra_params\n\n        d = triangle.triangulate({\"vertices\": self._pts, \"segments\": segments}, params)\n        verts, tris, is_border = d[\"vertices\"], d[\"triangles\"], d[\"vertex_markers\"]\n        is_border = is_border.astype(bool).squeeze()\n        return verts, tris, is_border\n\n    def transform(self, transform: ndarray) -&gt; Curve:\n        \"\"\"Apply a 2x2 or 3x3 transform matrix to the vertex positions\"\"\"\n        pts = self._pts\n        if transform.shape not in ((2, 2), (3, 3)):\n            msg = f\"Expected transform to have shape (2, 2) or (3, 3), got {transform.shape}\"\n            raise ValueError(msg)\n\n        sz = transform.shape[0]\n        if sz == 3:\n            pts = concatenate([pts, ones((self.n, 1))], axis=1)\n        pts = pts @ transform.T\n        pts = pts[:, :2] if sz == 3 else pts\n        return self.with_points(pts)\n\n    def to_length(self, length: float = 1.0) -&gt; Curve:\n        \"\"\"A new curve scaled to the supplied length\"\"\"\n        return self.scale(length / self.length)\n\n    def to_area(self, area: float = 1.0) -&gt; Curve:\n        \"\"\"A new curve scaled to the supplied area\"\"\"\n        return self.scale(sqrt(area / self.area))\n\n    def subdivide(self, n: int = 1) -&gt; Curve:\n        \"\"\"Create a new curve by evenly subdividing each edge\n\n        Parameters\n        ----------\n        n\n            Number of new points to add to each edge. For `n = 1`, new points are added at the\n            edge midpoint; for `n = 2`, points are added at the one-thirds and two-thirds\n            points, etc. If `n = 0`, an identical curve is returned.\n        \"\"\"\n        if n &lt; 0:\n            msg = \"n must be &gt;= 0\"\n            raise ValueError(msg)\n\n        if n == 0:\n            return self\n\n        return self.split_edges(1 + n * ones(self.n, dtype=\"int\"))\n\n    def split_edges(self, n: ndarray) -&gt; Curve:\n        \"\"\"Sample uniformly within edge segments\n\n        Parameters\n        ----------\n        n\n            A integer-valued vector of length `self.n` indicating the number of points to sample\n            from each edge.\n\n            When `n[i] == 1`, simply sample vertex `i', i.e.\n            `curve.split_edges(ones(curve.n, dtype='int'))` returns an identical curve.\n\n            When `n[i] == 2`, sample at vertex `i` *and* the midpoint between vertex `i` and\n            `i+1`.\n\n            When `n[i] == 3` sample at vertex `i` and the one-third and two-thirds point, and so on.\n\n            When `n[i] == 0`, vertex `i` is dropped from the output.\n\n        Returns\n        -------\n        :\n            A curve with `sum(n)` vertices.\n        \"\"\"\n\n        edge_idx = repeat(arange(self.n), n)\n        edge_frac = concatenate([arange(ni) / ni for ni in n])\n        pts = self._pts[edge_idx] + edge_frac[:, newaxis] * self.edge[edge_idx]\n        return self.with_points(pts)\n\n    def split_long_edges(self, thresh: float) -&gt; Curve:\n        \"\"\"Split edges evenly so all edge lengths are below `thresh`\"\"\"\n        n_split = ceil(self.edge_length / thresh)\n        return self.split_edges(n_split)\n\n    def split_longest_edges(self, n: int) -&gt; Curve:\n        \"\"\"Insert `n` new vertices by uniform edge subdivision\n\n        Edges are split in priority of their length, so very long edges may be split into\n        thirds, fourths, etc. before very short edges are split in half.\n        \"\"\"\n        if n == 0:\n            return self\n\n        if n &lt; 0:\n            msg = \"`n` must be &gt;= 0\"\n            raise ValueError(msg)\n\n        class Edge(NamedTuple):\n            split_length: float\n            n_subdivide: int\n            idx: int\n            orig_length: float\n\n        orig_edges = (\n            Edge(split_length=length, n_subdivide=1, idx=i, orig_length=length)\n            for (i, length) in enumerate(self.edge_length)\n        )\n\n        # Priority queue -- break length ties by the less split edge\n        queue = sortedcontainers.SortedList(orig_edges, key=lambda e: (e.length, -e.n_subdivide))\n\n        for _ in range(n):\n            edge = queue.pop()\n            edge.n_subdivide += 1\n            edge.split_length = edge.orig_length / edge.n_subdivide\n            queue.add(edge)\n\n        edges = sorted(queue, key=lambda e: e.idx)\n        n_subdivide = array([e.n_subdivide for e in edges])\n        return self.split_edges(n_subdivide)\n\n    def collapse_shortest_edges(\n        self,\n        n: int | None = None,\n        min_edge_length: float | None = None,\n    ) -&gt; Curve:\n        \"\"\"Remove vertices belonging to the shortest edges until a stopping criterion is met\n\n        Note\n        ----\n        No attempt is made to prevent self-intersection.\n\n        Parameters\n        ----------\n        n\n            Stop after collapsing this many edges.\n\n        min_edge_length\n            Stop when the shortest edge is longer than this.\n\n        \"\"\"\n        if n is None:\n            n = self.n - 3\n\n        if min_edge_length is None:\n            # noinspection PyArgumentList\n            min_edge_length = self.edge_length.max()\n\n        class Vertex(NamedTuple):\n            idx: int\n            prev: int\n            next: int\n            edge_length: float  # length from vertex i to i+1\n\n        # A doubly-linked list of vertices\n        verts = {\n            i: Vertex(\n                idx=i,\n                prev=(i - 1) % self.n,\n                next=(i + 1) % self.n,\n                edge_length=edge_length,\n            )\n            for i, edge_length in enumerate(self.edge_length)\n        }\n\n        # Priority queue by edge length\n        queue = sortedcontainers.SortedSet(verts.values(), key=lambda v: -v.edge_length)\n\n        for n_removed in itertools.count(1):\n            shortest = queue.pop(-1)\n            del verts[shortest.idx]\n\n            if (n_removed == n) or (queue[-1] &gt;= min_edge_length):\n                break\n\n            # Remove previous and next vertices so we can update them\n            queue.discard(v_prev := verts[shortest.prev])\n            queue.discard(v_next := verts[shortest.next])\n            updated_prev_edge_length = norm(self._pts[v_next.idx] - self._pts[v_prev.idx])\n\n            v_prev = verts[v_prev.idx] = Vertex(\n                idx=v_prev.idx,\n                prev=v_prev.prev,\n                next=v_next.idx,\n                edge_length=cast(float, updated_prev_edge_length),\n            )\n            v_next = verts[v_next.idx] = Vertex(\n                idx=v_next.idx,\n                prev=v_prev.idx,\n                next=v_next.next,\n                edge_length=v_next.edge_length,\n            )\n            queue.add(v_prev)\n            queue.add(v_next)\n\n        # Put the remaining vertices back in order\n        vert_idx = array(sorted(verts.keys()))\n        return self.with_points(self._pts[vert_idx])\n\n    @cached_property\n    def laplacian(self) -&gt; scipy.sparse.dia_matrix:\n        r\"\"\"The discrete Laplacian\n\n        The Laplacian here is the graph Laplacian of a weighted graph with edge weights\n        $1 / d_{i, j}$, where $d_{i, j}$ is the distance (edge length) between adjacent vertices\n        $i$ and $j$.\n\n        Returns a sparse matrix $L$ of size `(n, n)` with diagonal entries\n\n        $$L_{i,i} = 1 / d_{i-1, i} + 1 / d_{i, i+1} $$\n\n        and off-diagonal entries\n\n        $$L_{i,j} = -1 / d_{i, j}$$.\n\n        \"\"\"\n        return Curve._construct_laplacian(self.edge_length)\n\n    @staticmethod\n    def _construct_laplacian(edge_lengths: ndarray) -&gt; scipy.sparse.dia_matrix:\n        n = len(edge_lengths)\n        l_next = 1 / edge_lengths  # l_next[i] is the inverse edge length from vertex i to i+1\n        l_prev = roll(l_next, 1)  # l_prev[i] is the inverse edge length from vertex i-1 to i\n        return scipy.sparse.diags(\n            [\n                -l_next[[-1]],  # lower corner = the single edge length (0, n-1)\n                -l_next[:-1],  # lower diag = edge lengths (1, 0), (2, 1), (3, 2), ...\n                l_prev + l_next,  # diagonal\n                -l_next[:-1],  # upper diag = edge lengths (0, 1), (1, 2), (2, 3), ...\n                -l_next[[-1]],  # upper corner = the single edge length (n-1, 0)\n            ],\n            offsets=(-(n - 1), -1, 0, 1, n - 1),\n        ).tocsc()\n\n    @classmethod\n    def from_curvature(\n        cls,\n        curvature: ndarray,\n        edge_lengths: ndarray,\n        solve_vertices: bool = True,\n        theta0: float | None = None,\n        pt0: ndarray | Sequence[float] | None = None,\n        dual_edge_lengths: ndarray | None = None,\n        laplacian: ndarray | scipy.sparse.base.spmatrix | None = None,\n    ) -&gt; Self:\n        \"\"\"Construct a curve with the supplied new curvatures and edge lengths\n\n        As explained in\n\n        [*Robust Fairing via Conformal Curvature Flow.* Keenan Crane, Ulrich Pinkall, and\n        Peter Schr\u00f6der. 2014](https://www.cs.cmu.edu/~kmcrane/Projects/ConformalWillmoreFlow/paper.pdf)\n\n        The product (curvature * edge_lengths) is integrated to obtain tangent vectors, and then\n        tangent vectors are integrated to obtain vertex positions. This reconstructs the curve\n        up to rotation and translation. Supply `theta0` and `pt0` to fix the orientation of the\n        first edge and the location of the first point.\n\n        This may result in an improperly closed curve. If `solve_vertices` is True, vertex\n        positions are found by a linear projection to the closest closed curve, as described\n        in Crane et al.\n\n        Parameters\n        ----------\n        curvature\n            A length `n` vector of signed vertex curvatures.\n\n        edge_lengths\n            A length `n`  vector of edge lengths. `edge_length[i]` is the distance between\n            vertex `i` and `i+1`.\n\n        theta0\n            The constant of integration defining the angle of the first edge and the x-axis,\n            in radians.\n\n        pt0\n            A 2-element array. The constant of integration defining the absolute position of\n            the first vertex.\n\n        solve_vertices\n            If True, length discretization errors are resolved by solving\n            \u2206f = \u25bd \u00b7 T as the discrete Poisson equation Lf = b for the vertex positions f,\n            as per Crane \u00a75.2. Otherwise, vertex positions are found by simply integrating tangent\n            vectors, which may result in an improperly closed contour.\n\n        laplacian\n            The `(n, n)` Laplacian array. This is constructed automatically if not supplied.\n\n        dual_edge_lengths\n            The length `n` vector of dual edge lengths. This is constructed automatically\n            if not supplied.\n\n        Examples\n        --------\n        Construct a circle from its expected intrinsic parameters.\n\n        ```python\n        import numpy as np\n        from curvey import Curve\n\n        n = 20\n        curvatures = np.ones(n)\n        edge_lengths = 2 * np.pi / n * np.ones(n)\n        c = Curve.from_curvature(curvatures, edge_lengths)\n        _ = c.plot_edges()\n        ```\n\n        Construct a circle from noisy parameters, using `solve_vertices` to ensure the curve\n        is closed.\n\n        ```python\n        curvatures = np.random.normal(1, 0.1, n)\n        edge_lengths = 2 * np.pi / n * np.random.normal(1, 0.1, n)\n        c0 = Curve.from_curvature(curvatures, edge_lengths, solve_vertices=False)\n        c1 = Curve.from_curvature(curvatures, edge_lengths, solve_vertices=True)\n        _ = c0.plot(color='black')\n        _ = c1.plot(color='red')\n        ```\n\n        \"\"\"\n        n = len(curvature)\n        l_next = edge_lengths  # l_next[i] is the edge length from vertex i to i+1\n\n        if dual_edge_lengths is None:\n            l_prev = roll(l_next, 1)  # from i-1 to i\n            # length of the edge dual to vertex i\n            dual_edge_lengths = (l_next + l_prev) / 2\n\n        # Integrate curvatures to get edge angles\n        theta = zeros(n)\n        if theta0 is not None:\n            theta[0] = theta0\n        theta[1:] = theta[0] + cumsum(curvature[1:] * dual_edge_lengths[1:])\n\n        # Unnormalized tangent vectors from vertex i to i+1\n        t_next = l_next.reshape((-1, 1)) * angle_to_points(theta)\n\n        if solve_vertices:\n            l_prev = roll(l_next, 1)  # l_prev[i] is the edge length from vertex i-1 to i\n            t_prev = roll(t_next, 1, axis=0)  # Vector from vertex i-1 to i\n\n            # `b` is the discrete divergence of the new tangent field\n            b = t_prev / l_prev[:, newaxis] - t_next / l_next[:, newaxis]\n            if laplacian is None:\n                laplacian = Curve._construct_laplacian(edge_lengths=l_next)\n\n            with warnings.catch_warnings():\n                warnings.filterwarnings(\"error\", category=scipy.sparse.linalg.MatrixRankWarning)\n\n                try:\n                    if scipy.sparse.issparse(laplacian):\n                        pts = scipy.sparse.linalg.spsolve(laplacian, b)\n                    else:\n                        pts = np.linalg.solve(laplacian, b)\n                # NB scipy.sparse raises numpy linalg errors\n                except (np.linalg.LinAlgError, scipy.sparse.linalg.MatrixRankWarning):\n                    pts = zeros((n, 2))\n                    if pt0 is not None:\n                        pts[0] = pt0\n                    pts[1:] = pts[0] + cumsum(t_next[:-1], axis=0)\n\n            if theta0 is not None:\n                # Rotate to match requested first edge angle\n                dx, dy = pts[1] - pts[0]\n                theta1 = arctan2(dy, dx)\n                pts @= rotation_matrix(theta1 - theta0)\n\n            if pt0 is not None:\n                pts -= pts[0] - pt0\n\n        else:\n            # Just integrate the tangent vectors\n            pts = zeros((n, 2))\n            if pt0 is not None:\n                pts[0] = pt0\n            pts[1:] = pts[0] + cumsum(t_next[:-1], axis=0)\n\n        return cls(pts)\n\n    def with_curvature(\n        self,\n        curvature: ndarray,\n        solve_vertices=True,\n        realign=False,\n    ) -&gt; Curve:\n        \"\"\"Construct a curve with the (approx.) same edge lengths and the supplied new curvatures.\n\n        See method `Curve.from_curvature` for more details.\n\n        Parameters\n        ----------\n        curvature\n            A length `n` vector of signed curvatures.\n\n        solve_vertices\n            See `Curve.from_curvature`\n\n        realign\n            If True, the mean change in edge angle and vertex position is removed.\n        \"\"\"\n        if realign:\n            # Going to rotate the curve anyway, initial edge angle irrelevant\n            theta0 = None\n        else:\n            dx, dy = self._pts[1] - self._pts[0]\n            theta0 = arctan2(dy, dx)\n\n        out = self.__class__.from_curvature(\n            curvature=curvature,\n            edge_lengths=self.edge_length,\n            solve_vertices=solve_vertices,\n            theta0=theta0,\n            pt0=self._pts[0],\n            dual_edge_lengths=self.dual_edge_length,\n            laplacian=self.laplacian,\n        )\n\n        if realign:\n            out = out.align_to(self)\n\n        return out\n\n    @overload\n    def to_shapely(self, mode: Literal[\"ring\"]) -&gt; shapely.LinearRing: ...\n\n    @overload\n    def to_shapely(self, mode: Literal[\"edges\"]) -&gt; shapely.MultiLineString: ...\n\n    @overload\n    def to_shapely(self, mode: Literal[\"polygon\"]) -&gt; shapely.Polygon: ...\n\n    @overload\n    def to_shapely(self, mode: Literal[\"points\"]) -&gt; shapely.MultiPoint: ...\n\n    def to_shapely(\n        self,\n        mode: Literal[\"ring\", \"edges\", \"polygon\", \"points\"] = \"ring\",\n    ):\n        \"\"\"Convenience converter to `shapely` object\n\n        Parameters\n        ----------\n        mode\n            Which type of `shapely` geometry to return.\n\n              - 'ring': a `LinearRing` corresponding to the closed curve.\n              - 'edges': a `MultiLineString` containing `n_edges` 2-point line segments.\n              - 'polygon': a `Polygon` enclosed by the curve.\n              - 'points': a `MultiPoint` containing the vertices.\n        \"\"\"\n        if mode == \"ring\":\n            return shapely.LinearRing(self._pts)\n\n        if mode == \"edges\":\n            pts0 = self._pts\n            pts1 = roll(pts0, 1, axis=0)\n            return shapely.MultiLineString(list(zip(pts0, pts1)))\n\n        if mode == \"polygon\":\n            return shapely.Polygon(self._pts)\n\n        if mode == \"points\":\n            return shapely.MultiPoint(self._pts)\n\n        modes = \", \".join((\"ring\", \"edges\", \"polygon\", \"points\"))  # type: ignore [unreachable]\n        msg = f\"mode must be one of ({modes}), got {mode}\"\n        raise ValueError(msg)\n\n    @cached_property\n    def is_simple(self) -&gt; bool:\n        \"\"\"False if the curve intersects or touches itself, including having repeated points\n\n        Uses `shapely.LinearRing.is_simple`\n        \"\"\"\n        return self.to_shapely(\"ring\").is_simple\n\n    def edge_intersections(self) -&gt; ndarray:\n        \"\"\"An `(n_intersect, 2)` array of points where two edges cross\n\n        This does not include two co-incident vertices or an edge coincident on\n        a non-adjacent vertex.\n        \"\"\"\n        # Use unary union to resolve all self-intersections\n        mls: shapely.MultiLineString = shapely.unary_union(self.to_shapely(\"ring\"))\n        all_pts = shapely.extract_unique_points(mls)\n        intersections = all_pts - self.to_shapely(\"points\")  # Set difference\n\n        if intersections.is_empty:\n            return zeros((0, 2))\n\n        if isinstance(intersections, shapely.Point):\n            return array(intersections.coords)  # (1, 2)\n\n        return concatenate([pt.coords for pt in intersections.geoms])\n\n    @overload\n    def register_to(\n        self, target: Curve, allow_scale: bool, return_transform: Literal[False]\n    ) -&gt; Curve: ...\n\n    @overload\n    def register_to(\n        self, target: Curve, allow_scale: bool, return_transform: Literal[True]\n    ) -&gt; ndarray: ...\n\n    @overload\n    def register_to(\n        self, target: Curve, allow_scale: bool, return_transform: bool\n    ) -&gt; Curve | ndarray: ...\n\n    def register_to(\n        self,\n        target: Curve,\n        allow_scale: bool = False,\n        return_transform=False,\n    ) -&gt; Curve | ndarray:\n        r\"\"\"Iterative closest point registration\n\n        Minimizes\n\n        $$\n        \\sum_i \\min_j d(v_i, e_j)^2\n        $$\n\n        where $d(v_i, e_j)$ is the euclidean distance btween vertices $v_i$ in `self`\n        and edges $e_j$ in `target`.\n\n        Parameters\n        ----------\n        target\n            The `Curve` to register to/\n\n        allow_scale\n            If True, allow uniform scaling.\n\n        return_transform\n            If True, return a 3x3 transform matrix. Otherwise, return the transformed `Curve`.\n\n        See also\n        --------\n        [Curve.align_to][curvey.curve.Curve.align_to]\n            When `source` and `target` have the same number of vertices in 1-to-1 correspondance.\n        \"\"\"\n        tree = shapely.STRtree(target.to_shapely(\"edges\").geoms)\n\n        def get_transform(params: ndarray) -&gt; ndarray:\n            \"\"\"3x3 transform matrix\"\"\"\n            if len(params) == 4:\n                theta, dx, dy, scale_factor = params\n            else:\n                theta, dx, dy = params\n                scale_factor = 1\n\n            cos_theta, sin_theta = scale_factor * cos(theta), scale_factor * sin(theta)\n            return array(\n                [\n                    [cos_theta, -sin_theta, dx],\n                    [sin_theta, cos_theta, dy],\n                    [0, 0, 1],\n                ]\n            )\n\n        def sum_sq_dist_closest_pt(params: ndarray) -&gt; float:\n            transformed = self.transform(get_transform(params))\n            (_self_idx, _other_idx), dists = tree.query_nearest(\n                geometry=transformed.to_shapely(\"points\").geoms,\n                return_distance=True,\n                all_matches=False,\n            )\n            return (dists**2).sum()\n\n        opt = scipy.optimize.minimize(\n            fun=sum_sq_dist_closest_pt,\n            x0=array([0, 0, 0, 1] if allow_scale else [0, 0, 0]),\n        )\n        if not opt.success:\n            msg = f\"Optimization failed: {opt.message}\"\n            warnings.warn(msg, category=OptimizationFailed, stacklevel=2)\n\n        transform = get_transform(opt.x)\n        return transform if return_transform else self.transform(transform)\n\n    def check_same_n_vertices(self, other: Curve) -&gt; int:\n        \"\"\"Raises a `ValueError` if vertex counts don't match\n\n        Otherwise, returns the common vertex count.\n        \"\"\"\n        if self.n != other.n:\n            msg = (\n                \"Curve pair must have the same number of vertices. \"\n                f\"Got self.n = {self.n} and other.n = {other.n}\"\n            )\n            raise MismatchedVertexCounts(msg)\n        return self.n\n\n    def roll_to(self, other: Curve) -&gt; Curve:\n        \"\"\"Cyclicly permute points to minimize the distance between corresponding points\n\n        `other` must have the same number of vertices as `self`\n        \"\"\"\n        n = self.check_same_n_vertices(other)\n\n        # (n, n) array of pairwise square distances\n        dist = scipy.spatial.distance.cdist(other._pts, self._pts, \"sqeuclidean\")\n        i0 = arange(n)\n\n        # (n, n) cyclic permutation matrix\n        #   [[0, 1, 2, 3, ..., n-1]\n        #    [1, 2, 3, ..., n-1, 0]\n        #    [2, 3, ..., n-1, 0, 1] ... ]\n        i1 = (i0[:, newaxis] + i0[newaxis, :]) % n\n\n        # The permutation index that minimizes sum of sq. dists\n        i_min = cast(int, argmin(dist[i0, i1].sum(axis=1)))\n        return self.roll(-i_min)\n\n    def optimize_edge_lengths_to(\n        self,\n        other: Curve,\n        interp_typ: InterpType = \"cubic\",\n    ) -&gt; Curve:\n        \"\"\"Optimize partitioning of vertex arclength positions to match edge_lengths in other\n\n        `self` and `other` must have the same number of vertices.\n\n        This assumes `self` and `other` have already been processed to have the same length!\n\n        Parameters\n        ----------\n        other\n            The curve to optimize against\n\n        interp_typ\n            Passed to `Curve.interpolator`\n        \"\"\"\n        n = self.check_same_n_vertices(other)\n\n        # So we don't need to refit each iteration\n        interpolator = self.interpolator(typ=interp_typ)\n\n        def _resample(ds: ndarray) -&gt; Curve:\n            arclength = append(0, cumsum(ds[:-1]))\n            return self.with_points(interpolator(arclength))\n\n        def _objective(ds: ndarray) -&gt; float:\n            resampled = _resample(ds)\n            return ((other.closed_arclength - resampled.closed_arclength) ** 2).sum()\n\n        # noinspection PyTypeChecker\n        opt = scipy.optimize.minimize(\n            fun=_objective,\n            x0=other.edge_length,\n            # Edge lengths must sum to total length\n            constraints=scipy.optimize.LinearConstraint(ones(n), lb=other.length, ub=other.length),\n            # Edge lengths must be positive\n            bounds=scipy.optimize.Bounds(lb=0),\n        )\n        if not opt.success:\n            msg = \"Optimization failed: \" + opt.message\n            warnings.warn(msg, OptimizationFailed, stacklevel=2)\n\n        return self.with_points(_resample(opt.x)._pts)\n</code></pre>"},{"location":"api/curve/#constructors","title":"Constructors","text":""},{"location":"api/curve/#curvey.curve.Curve.circle","title":"<code>circle(n: int, r: float = 1.0) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Construct a regular polygon</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of vertices.</p> required <code>r</code> <code>float</code> <p>The radius.</p> <code>1.0</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>@classmethod\ndef circle(cls, n: int, r: float = 1.0) -&gt; Self:\n    \"\"\"Construct a regular polygon\n\n    Parameters\n    ----------\n    n\n        Number of vertices.\n\n    r\n        The radius.\n    \"\"\"\n    theta = linspace(0, 2 * pi, n, endpoint=False)\n    return cls(r * angle_to_points(theta))\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.dumbbell","title":"<code>dumbbell(n: int, rx: float = 2, ry: float = 2, neck: float = 0.2) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Construct a dumbbell shape</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of points</p> required <code>rx</code> <code>float</code> <p>Width parameter</p> <code>2</code> <code>ry</code> <code>float</code> <p>Height parameter</p> <code>2</code> <code>neck</code> <code>float</code> <p>Height of the pinched neck</p> <code>0.2</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>@classmethod\ndef dumbbell(cls, n: int, rx: float = 2, ry: float = 2, neck: float = 0.2) -&gt; Self:\n    \"\"\"Construct a dumbbell shape\n\n    Parameters\n    ----------\n    n\n        Number of points\n\n    rx\n        Width parameter\n\n    ry\n        Height parameter\n\n    neck\n        Height of the pinched neck\n    \"\"\"\n    t = np.linspace(0, 1, n, endpoint=False)\n    z = 2 * pi * t\n    x = rx * cos(z)\n    y = ry * sin(z) - (ry - neck) * sin(z) ** 3\n    return cls(np.stack([x, y], axis=1))\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.ellipse","title":"<code>ellipse(n: int, ra: float, rb: float) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Construct an ellipse</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of vertices.</p> required <code>ra</code> <code>float</code> <p>Major radius.</p> required <code>rb</code> <code>float</code> <p>Minor radius.</p> required Source code in <code>src\\curvey\\curve.py</code> <pre><code>@classmethod\ndef ellipse(cls, n: int, ra: float, rb: float) -&gt; Self:\n    \"\"\"Construct an ellipse\n\n    Parameters\n    ----------\n    n\n        Number of vertices.\n\n    ra\n        Major radius.\n\n    rb\n        Minor radius.\n\n    \"\"\"\n    theta = linspace(0, 2 * pi, n, endpoint=False)\n    pts = array([[ra, rb]]) * angle_to_points(theta)\n    return cls(pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.from_curvature","title":"<code>from_curvature(curvature: ndarray, edge_lengths: ndarray, solve_vertices: bool = True, theta0: float | None = None, pt0: ndarray | Sequence[float] | None = None, dual_edge_lengths: ndarray | None = None, laplacian: ndarray | scipy.sparse.base.spmatrix | None = None) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Construct a curve with the supplied new curvatures and edge lengths</p> <p>As explained in</p> <p>Robust Fairing via Conformal Curvature Flow. Keenan Crane, Ulrich Pinkall, and Peter Schr\u00f6der. 2014</p> <p>The product (curvature * edge_lengths) is integrated to obtain tangent vectors, and then tangent vectors are integrated to obtain vertex positions. This reconstructs the curve up to rotation and translation. Supply <code>theta0</code> and <code>pt0</code> to fix the orientation of the first edge and the location of the first point.</p> <p>This may result in an improperly closed curve. If <code>solve_vertices</code> is True, vertex positions are found by a linear projection to the closest closed curve, as described in Crane et al.</p> <p>Parameters:</p> Name Type Description Default <code>curvature</code> <code>ndarray</code> <p>A length <code>n</code> vector of signed vertex curvatures.</p> required <code>edge_lengths</code> <code>ndarray</code> <p>A length <code>n</code>  vector of edge lengths. <code>edge_length[i]</code> is the distance between vertex <code>i</code> and <code>i+1</code>.</p> required <code>theta0</code> <code>float | None</code> <p>The constant of integration defining the angle of the first edge and the x-axis, in radians.</p> <code>None</code> <code>pt0</code> <code>ndarray | Sequence[float] | None</code> <p>A 2-element array. The constant of integration defining the absolute position of the first vertex.</p> <code>None</code> <code>solve_vertices</code> <code>bool</code> <p>If True, length discretization errors are resolved by solving \u2206f = \u25bd \u00b7 T as the discrete Poisson equation Lf = b for the vertex positions f, as per Crane \u00a75.2. Otherwise, vertex positions are found by simply integrating tangent vectors, which may result in an improperly closed contour.</p> <code>True</code> <code>laplacian</code> <code>ndarray | spmatrix | None</code> <p>The <code>(n, n)</code> Laplacian array. This is constructed automatically if not supplied.</p> <code>None</code> <code>dual_edge_lengths</code> <code>ndarray | None</code> <p>The length <code>n</code> vector of dual edge lengths. This is constructed automatically if not supplied.</p> <code>None</code> <p>Examples:</p> <p>Construct a circle from its expected intrinsic parameters.</p> <pre><code>import numpy as np\nfrom curvey import Curve\n\nn = 20\ncurvatures = np.ones(n)\nedge_lengths = 2 * np.pi / n * np.ones(n)\nc = Curve.from_curvature(curvatures, edge_lengths)\n_ = c.plot_edges()\n</code></pre> <p>Construct a circle from noisy parameters, using <code>solve_vertices</code> to ensure the curve is closed.</p> <pre><code>curvatures = np.random.normal(1, 0.1, n)\nedge_lengths = 2 * np.pi / n * np.random.normal(1, 0.1, n)\nc0 = Curve.from_curvature(curvatures, edge_lengths, solve_vertices=False)\nc1 = Curve.from_curvature(curvatures, edge_lengths, solve_vertices=True)\n_ = c0.plot(color='black')\n_ = c1.plot(color='red')\n</code></pre> Source code in <code>src\\curvey\\curve.py</code> <pre><code>@classmethod\ndef from_curvature(\n    cls,\n    curvature: ndarray,\n    edge_lengths: ndarray,\n    solve_vertices: bool = True,\n    theta0: float | None = None,\n    pt0: ndarray | Sequence[float] | None = None,\n    dual_edge_lengths: ndarray | None = None,\n    laplacian: ndarray | scipy.sparse.base.spmatrix | None = None,\n) -&gt; Self:\n    \"\"\"Construct a curve with the supplied new curvatures and edge lengths\n\n    As explained in\n\n    [*Robust Fairing via Conformal Curvature Flow.* Keenan Crane, Ulrich Pinkall, and\n    Peter Schr\u00f6der. 2014](https://www.cs.cmu.edu/~kmcrane/Projects/ConformalWillmoreFlow/paper.pdf)\n\n    The product (curvature * edge_lengths) is integrated to obtain tangent vectors, and then\n    tangent vectors are integrated to obtain vertex positions. This reconstructs the curve\n    up to rotation and translation. Supply `theta0` and `pt0` to fix the orientation of the\n    first edge and the location of the first point.\n\n    This may result in an improperly closed curve. If `solve_vertices` is True, vertex\n    positions are found by a linear projection to the closest closed curve, as described\n    in Crane et al.\n\n    Parameters\n    ----------\n    curvature\n        A length `n` vector of signed vertex curvatures.\n\n    edge_lengths\n        A length `n`  vector of edge lengths. `edge_length[i]` is the distance between\n        vertex `i` and `i+1`.\n\n    theta0\n        The constant of integration defining the angle of the first edge and the x-axis,\n        in radians.\n\n    pt0\n        A 2-element array. The constant of integration defining the absolute position of\n        the first vertex.\n\n    solve_vertices\n        If True, length discretization errors are resolved by solving\n        \u2206f = \u25bd \u00b7 T as the discrete Poisson equation Lf = b for the vertex positions f,\n        as per Crane \u00a75.2. Otherwise, vertex positions are found by simply integrating tangent\n        vectors, which may result in an improperly closed contour.\n\n    laplacian\n        The `(n, n)` Laplacian array. This is constructed automatically if not supplied.\n\n    dual_edge_lengths\n        The length `n` vector of dual edge lengths. This is constructed automatically\n        if not supplied.\n\n    Examples\n    --------\n    Construct a circle from its expected intrinsic parameters.\n\n    ```python\n    import numpy as np\n    from curvey import Curve\n\n    n = 20\n    curvatures = np.ones(n)\n    edge_lengths = 2 * np.pi / n * np.ones(n)\n    c = Curve.from_curvature(curvatures, edge_lengths)\n    _ = c.plot_edges()\n    ```\n\n    Construct a circle from noisy parameters, using `solve_vertices` to ensure the curve\n    is closed.\n\n    ```python\n    curvatures = np.random.normal(1, 0.1, n)\n    edge_lengths = 2 * np.pi / n * np.random.normal(1, 0.1, n)\n    c0 = Curve.from_curvature(curvatures, edge_lengths, solve_vertices=False)\n    c1 = Curve.from_curvature(curvatures, edge_lengths, solve_vertices=True)\n    _ = c0.plot(color='black')\n    _ = c1.plot(color='red')\n    ```\n\n    \"\"\"\n    n = len(curvature)\n    l_next = edge_lengths  # l_next[i] is the edge length from vertex i to i+1\n\n    if dual_edge_lengths is None:\n        l_prev = roll(l_next, 1)  # from i-1 to i\n        # length of the edge dual to vertex i\n        dual_edge_lengths = (l_next + l_prev) / 2\n\n    # Integrate curvatures to get edge angles\n    theta = zeros(n)\n    if theta0 is not None:\n        theta[0] = theta0\n    theta[1:] = theta[0] + cumsum(curvature[1:] * dual_edge_lengths[1:])\n\n    # Unnormalized tangent vectors from vertex i to i+1\n    t_next = l_next.reshape((-1, 1)) * angle_to_points(theta)\n\n    if solve_vertices:\n        l_prev = roll(l_next, 1)  # l_prev[i] is the edge length from vertex i-1 to i\n        t_prev = roll(t_next, 1, axis=0)  # Vector from vertex i-1 to i\n\n        # `b` is the discrete divergence of the new tangent field\n        b = t_prev / l_prev[:, newaxis] - t_next / l_next[:, newaxis]\n        if laplacian is None:\n            laplacian = Curve._construct_laplacian(edge_lengths=l_next)\n\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\"error\", category=scipy.sparse.linalg.MatrixRankWarning)\n\n            try:\n                if scipy.sparse.issparse(laplacian):\n                    pts = scipy.sparse.linalg.spsolve(laplacian, b)\n                else:\n                    pts = np.linalg.solve(laplacian, b)\n            # NB scipy.sparse raises numpy linalg errors\n            except (np.linalg.LinAlgError, scipy.sparse.linalg.MatrixRankWarning):\n                pts = zeros((n, 2))\n                if pt0 is not None:\n                    pts[0] = pt0\n                pts[1:] = pts[0] + cumsum(t_next[:-1], axis=0)\n\n        if theta0 is not None:\n            # Rotate to match requested first edge angle\n            dx, dy = pts[1] - pts[0]\n            theta1 = arctan2(dy, dx)\n            pts @= rotation_matrix(theta1 - theta0)\n\n        if pt0 is not None:\n            pts -= pts[0] - pt0\n\n    else:\n        # Just integrate the tangent vectors\n        pts = zeros((n, 2))\n        if pt0 is not None:\n            pts[0] = pt0\n        pts[1:] = pts[0] + cumsum(t_next[:-1], axis=0)\n\n    return cls(pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.star","title":"<code>star(n: int, r0: float, r1: float) -&gt; Self</code>  <code>classmethod</code>","text":"<p>Construct a (isotoxal) star polygon with <code>n</code> corner vertices</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>The number of corner vertices. The returned curve has <code>2n</code> vertices.</p> required <code>r0</code> <code>float</code> <p>Radius of the even vertices.</p> required <code>r1</code> <code>float</code> <p>Radius of the odd vertices.</p> required Source code in <code>src\\curvey\\curve.py</code> <pre><code>@classmethod\ndef star(cls, n: int, r0: float, r1: float) -&gt; Self:\n    \"\"\"Construct a (isotoxal) star polygon with `n` corner vertices\n\n    Parameters\n    ----------\n    n\n        The number of corner vertices. The returned curve has `2n` vertices.\n\n    r0\n        Radius of the even vertices.\n\n    r1\n        Radius of the odd vertices.\n\n    \"\"\"\n    c = Curve.circle(n=2 * n, r=1)\n    r = where(arange(c.n) % 2, r1, r0)\n    return cls(r[:, newaxis] * c._pts)\n</code></pre>"},{"location":"api/curve/#curve-valued-properties","title":"Curve-valued properties","text":""},{"location":"api/curve/#curvey.curve.Curve.area","title":"<code>area: float</code>  <code>cached</code> <code>property</code>","text":"<p>Absolute area of the polygon enclosed by the curve</p>"},{"location":"api/curve/#curvey.curve.Curve.center","title":"<code>center: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>The average vertex position</p>"},{"location":"api/curve/#curvey.curve.Curve.centroid","title":"<code>centroid: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>The center of mass of the uniformly weighted polygon enclosed by the curve</p>"},{"location":"api/curve/#curvey.curve.Curve.data","title":"<code>data: MappingProxyType[str, Any]</code>  <code>property</code>","text":"<p>A read-only view of the curve's metadata</p>"},{"location":"api/curve/#curvey.curve.Curve.is_simple","title":"<code>is_simple: bool</code>  <code>cached</code> <code>property</code>","text":"<p>False if the curve intersects or touches itself, including having repeated points</p> <p>Uses <code>shapely.LinearRing.is_simple</code></p>"},{"location":"api/curve/#curvey.curve.Curve.laplacian","title":"<code>laplacian: scipy.sparse.dia_matrix</code>  <code>cached</code> <code>property</code>","text":"<p>The discrete Laplacian</p> <p>The Laplacian here is the graph Laplacian of a weighted graph with edge weights \\(1 / d_{i, j}\\), where \\(d_{i, j}\\) is the distance (edge length) between adjacent vertices \\(i\\) and \\(j\\).</p> <p>Returns a sparse matrix \\(L\\) of size <code>(n, n)</code> with diagonal entries</p> \\[L_{i,i} = 1 / d_{i-1, i} + 1 / d_{i, i+1} \\] <p>and off-diagonal entries</p> <p>\\(\\(L_{i,j} = -1 / d_{i, j}\\)\\).</p>"},{"location":"api/curve/#curvey.curve.Curve.length","title":"<code>length: float</code>  <code>cached</code> <code>property</code>","text":"<p>Total arclength; the sum of edge lengths</p>"},{"location":"api/curve/#curvey.curve.Curve.n","title":"<code>n: int</code>  <code>property</code>","text":"<p>The number of vertices</p> <p>(or the number of edges, since this is a closed curve)</p>"},{"location":"api/curve/#curvey.curve.Curve.orientation","title":"<code>orientation: int</code>  <code>cached</code> <code>property</code>","text":"<p>Orientation of the curve</p> <p>Integer-valued; <code>+1</code> if curve is oriented counterclockwise, <code>-1</code> if clockwise, 0 if zero area</p>"},{"location":"api/curve/#curvey.curve.Curve.signed_area","title":"<code>signed_area: float</code>  <code>cached</code> <code>property</code>","text":"<p>Signed area of the polygon enclosed by the curve</p> <p>Signed area is positive if the curve is oriented counter-clockwise.</p> <p>Calculated by the shoelace formula.</p>"},{"location":"api/curve/#vertex-valued-properties","title":"Vertex-valued properties","text":"<p>The following properties have length <code>n</code>:</p>"},{"location":"api/curve/#curvey.curve.Curve.arclength","title":"<code>arclength: ndarray</code>  <code>property</code>","text":"<p>Vertex arclengths</p> <p><code>arclength</code> is a length <code>n</code> vector, where <code>arclength[i]</code> is the arclength of the <code>i</code>th vertex. <code>arclength[0]</code> is always zero. <code>arclength[i]</code> for <code>i&gt;0</code> is equal to `cum_edge_length[i-1].</p> See also <p>Curve.closed_arclength     Like <code>arclength</code>, but also includes <code>self.length</code> as the final element.</p>"},{"location":"api/curve/#curvey.curve.Curve.curvature","title":"<code>curvature: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>Length <code>n</code> vector of signed vertex curvatures</p> <p>Computed as $$ \\kappa_i = \\frac {2 \\psi_i}{L_{i-1, i} + L_{i, i+1}} $$ Where \\(\\psi_i\\) is the turning angle between the two edges adjacent to vertex \\(i\\), and \\(L_{ij}\\) is the length of the edge between vertex \\(i\\) and \\(j\\).</p> Note <p>There are multiple ways to reasonably define discrete curvature. (See Table 1 in Vouga 2014 for a summary of their tradeoffs.) One is chosen here for convenience; most of the curvature flows in <code>curvey.flow</code> accept a <code>curvature_fn</code> to allow this choice to be overridden.</p>"},{"location":"api/curve/#curvey.curve.Curve.dual_edge_length","title":"<code>dual_edge_length: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>Vertex dual edge lengths</p> <p><code>curve.dual_edge_length[i]</code> is the average length of the two edges incident on vertex \\(i\\), i.e. \\((L_{i-1, i} + L_{i, i+1})/2\\)  where \\(L_{ij}\\) is the edge length between vertex \\(i\\) and vertex \\(j\\).</p>"},{"location":"api/curve/#curvey.curve.Curve.normal","title":"<code>normal: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>Vertex unit normal vectors</p> <p>Normals are computed by rotating the unit tangents 90 degrees counter-clockwise, so that \\(\\left[ T_i, N_i, 1 \\right]\\) forms a right-handed frame at vertex \\(i\\) with tangent \\(T_i\\) and normal \\(N_i\\).</p> <p>For a counter-clockwise-oriented curve, this means that normals point inwards.</p> See also <p>Curve.edge_normal     The exact unit normals for each edge.</p>"},{"location":"api/curve/#curvey.curve.Curve.points","title":"<code>points: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>A <code>(n, 2)</code> array of curve vertex coordinates</p>"},{"location":"api/curve/#curvey.curve.Curve.tangent","title":"<code>tangent: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>Unit length tangent vectors</p> <p><code>tangent[i]</code> is the curve unit tangent vector at vertex <code>i</code>. This is constructed from second order finite differences; use <code>Curve.unit_edge</code> for the exact vector from vertex <code>i</code> to vertex <code>i+1</code>.</p>"},{"location":"api/curve/#curvey.curve.Curve.turning_angle","title":"<code>turning_angle: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>Turning angle (a.k.a exterior angle), in radians between adjacent edges</p> <p><code>curve.turning_angle[i]</code> is the angle between the vectors \\(T_{i-1, i}\\) and \\(T_{i, i+1}\\) where \\(T_{ij}\\) is the vector from vertex \\(i\\) to vertex \\(j\\).</p> <p>Angles are in the range \\(\\pm \\pi\\).</p>"},{"location":"api/curve/#curvey.curve.Curve.x","title":"<code>x: ndarray</code>  <code>property</code>","text":"<p>The x-component of the curve vertices</p>"},{"location":"api/curve/#curvey.curve.Curve.y","title":"<code>y: ndarray</code>  <code>property</code>","text":"<p>The y-component of the curve vertices</p>"},{"location":"api/curve/#vertex-1-valued-properties","title":"Vertex + 1 -valued properties","text":"<p>These are special cases and have length <code>n + 1</code> </p>"},{"location":"api/curve/#curvey.curve.Curve.closed_arclength","title":"<code>closed_arclength: ndarray</code>  <code>property</code>","text":"<p>Cumulative edge lengths with zero prepended</p> <p><code>closed_arclength</code> is a length <code>n+1</code> vector, where the first element is <code>0</code>, the second element is the length of the first edge, and the last element is the cumulative length of all edges, <code>curve.length</code>.</p>"},{"location":"api/curve/#curvey.curve.Curve.closed_points","title":"<code>closed_points: ndarray</code>  <code>property</code>","text":"<p>A <code>(n+1, 2)</code> array of the vertex coordinates where the last row is equal to the first</p> <p>Curvey uses an implicitly closed representation, assuming an edge exists between the last and first point, i.e. in general <code>curve.points[0] != curve.points[-1]</code>. Sometimes it's useful to have an explicit representation.</p>"},{"location":"api/curve/#edge-valued-properties","title":"Edge-valued properties","text":"<p>The following properties have length <code>n</code>: </p>"},{"location":"api/curve/#curvey.curve.Curve.edge","title":"<code>edge: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>The vectors from vertex <code>i</code> to <code>i+1</code></p> See also <p>Curve.unit_edge     For unit edge vectors.</p>"},{"location":"api/curve/#curvey.curve.Curve.edge_length","title":"<code>edge_length: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>Curve edge lengths</p> <p><code>edge_length[i]</code> is the length of the edge from vertex <code>i</code> to vertex <code>i+1</code>.</p> See also <p>Curve.cum_edge_length     Cumulative egde lengths.</p>"},{"location":"api/curve/#curvey.curve.Curve.unit_edge","title":"<code>unit_edge: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>The unit edge vectors from vertex <code>i</code> to <code>i+1</code></p> See also <p>Curve.tangent     For unit tangent vectors calculated from second-order finite differences.</p>"},{"location":"api/curve/#curvey.curve.Curve.edge_normal","title":"<code>edge_normal: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>Unit edge normals</p> <p><code>edge_normal[i]</code> is the unit vector normal to the edge from vertex <code>i</code> to <code>i+1</code>.</p> <p>Normals are computed by rotating the unit edge vectors 90 degrees counter-clockwise.</p> <p>For a counter-clockwise-oriented curve, this means that normals point inwards.</p> See also <p>Curve.normal     Vertex normals calculated from 2nd order finite differences.</p>"},{"location":"api/curve/#curvey.curve.Curve.cum_edge_length","title":"<code>cum_edge_length: ndarray</code>  <code>cached</code> <code>property</code>","text":"<p>Cumulative edge lengths</p> <p>Simply equal to <code>np.cumsum(self.edge_length)</code>.</p> <p><code>cum_edge_length</code> is a length <code>n</code> vector, and does not include zero, i.e. <code>curve.cum_edge_lengths[0]</code> is the length of the first edge, and <code>curve.cum_edge_length[-1]</code> == <code>curve.length</code>.</p> See also <p>Curve.arclength     Vertex arclength, like <code>cum_edge_length</code> but starts at 0.</p>"},{"location":"api/curve/#transformations","title":"Transformations","text":"<p>All transformations return a new <code>Curve</code>; nothing modifies a <code>Curve</code> inplace.</p>"},{"location":"api/curve/#basic-transformations","title":"Basic transformations","text":""},{"location":"api/curve/#curvey.curve.Curve.with_points","title":"<code>with_points(pts: ndarray) -&gt; Curve</code>","text":"<p>A curve with the newly supplied points array, but same metadata values</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def with_points(self, pts: ndarray) -&gt; Curve:\n    \"\"\"A curve with the newly supplied points array, but same metadata values\"\"\"\n    # We can share the data dict here without a copy because it's publicly read-only\n    return self.__class__(pts=pts, _data=self._data)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.with_data","title":"<code>with_data(**kwargs) -&gt; Curve</code>","text":"<p>A new curve with the same points and metadata appended with the supplied metadata</p> <p>E.g. <code>curve.with_data(foo=1, bar=2).with_data(baz=3)</code> has metadata parameters 'foo', 'bar', and 'baz'.</p> <p>This allows without complaint overwriting previous metadata.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>New metadata in key=value format</p> <code>{}</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def with_data(self, **kwargs) -&gt; Curve:\n    \"\"\"A new curve with the same points and metadata appended with the supplied metadata\n\n    E.g. `curve.with_data(foo=1, bar=2).with_data(baz=3)` has metadata parameters\n    'foo', 'bar', and 'baz'.\n\n    This allows without complaint overwriting previous metadata.\n\n    Parameters\n    ----------\n    **kwargs\n        New metadata in key=value format\n\n    \"\"\"\n    return self.__class__(self._pts, _data={**self._data, **kwargs})\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.drop_data","title":"<code>drop_data(*args: str) -&gt; Curve</code>","text":"<p>Copy of the curve without the listed metadata parameters</p> <p>Use <code>curve.drop_data(*curve.data.keys())</code> to drop all data.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def drop_data(self, *args: str) -&gt; Curve:\n    \"\"\"Copy of the curve without the listed metadata parameters\n\n    Use `curve.drop_data(*curve.data.keys())` to drop all data.\n    \"\"\"\n    to_drop = set(args)\n    data = {k: v for k, v in self._data.items() if k not in to_drop}\n    return self.__class__(self._pts, _data=data)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.reverse","title":"<code>reverse(keep_first=False) -&gt; Curve</code>","text":"<p>Reverse the curve orientation</p> <p>Flips between clockwise and counter-clockwise orientation</p> <p>Parameters:</p> Name Type Description Default <code>keep_first</code> <p>By default, the list of vertices is simply flipped. This changes which point is first. If <code>keep_first</code> is True, the points are also rolled so the first point is maintained.</p> <code>False</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def reverse(self, keep_first=False) -&gt; Curve:\n    \"\"\"Reverse the curve orientation\n\n    Flips between clockwise and counter-clockwise orientation\n\n    Parameters\n    ----------\n    keep_first\n        By default, the list of vertices is simply flipped. This changes which point is first.\n        If `keep_first` is True, the points are also rolled so the first point is maintained.\n    \"\"\"\n    pts = self._pts[::-1]\n\n    if keep_first:\n        pts = roll(pts, 1, axis=0)\n\n    return self.with_points(pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.scale","title":"<code>scale(scale: float) -&gt; Curve</code>","text":"<p>Scale vertex positions by a constant</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def scale(self, scale: float) -&gt; Curve:\n    \"\"\"Scale vertex positions by a constant\"\"\"\n    return self.with_points(scale * self._pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.translate","title":"<code>translate(offset: ndarray | Literal['center', 'centroid']) -&gt; Curve</code>","text":"<p>Translate the curve</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>ndarray | Literal['center', 'centroid']</code> <p>One of     - A 2 element vector <code>(dx, dy)</code>     - A <code>(n, 2)</code> array of <code>(dx, dy)</code> translations     - The string 'center' or <code>centroid</code>, in which case the curve is translated so that       point sits on the origin.</p> required Source code in <code>src\\curvey\\curve.py</code> <pre><code>def translate(self, offset: ndarray | Literal[\"center\", \"centroid\"]) -&gt; Curve:\n    \"\"\"Translate the curve\n\n    Parameters\n    ----------\n    offset\n        One of\n            - A 2 element vector `(dx, dy)`\n            - A `(n, 2)` array of `(dx, dy)` translations\n            - The string 'center' or `centroid`, in which case the curve is translated so that\n              point sits on the origin.\n    \"\"\"\n    if isinstance(offset, str):\n        if offset == \"center\":\n            offset = -self.center\n        elif offset == \"centroid\":\n            offset = -self.centroid\n        else:\n            raise ValueError(offset)\n    else:\n        offset = asarray(offset)\n\n    return self.with_points(self._pts + offset.reshape((-1, 2)))\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.roll","title":"<code>roll(shift: int) -&gt; Curve</code>","text":"<p>Circular permutation of the vertex order</p> <p>To make vertex <code>i</code> the first vertex, use <code>curve.roll(-i)</code>.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def roll(self, shift: int) -&gt; Curve:\n    \"\"\"Circular permutation of the vertex order\n\n    To make vertex `i` the first vertex, use `curve.roll(-i)`.\n    \"\"\"\n    return self.with_points(roll(self._pts, shift, axis=0))\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.rotate","title":"<code>rotate(theta: float) -&gt; Curve</code>","text":"<p>Rotate the curve about the origin</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Angle in radians to rotate the curve. Positive angles are counter-clockwise.</p> required Source code in <code>src\\curvey\\curve.py</code> <pre><code>def rotate(self, theta: float) -&gt; Curve:\n    \"\"\"Rotate the curve about the origin\n\n    Parameters\n    ----------\n    theta\n        Angle in radians to rotate the curve. Positive angles are counter-clockwise.\n    \"\"\"\n    return self.transform(rotation_matrix(theta))\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.reflect","title":"<code>reflect(theta: float | Literal['x', 'X', 'y', 'Y']) -&gt; Curve</code>","text":"<p>Reflect the curve over a line through the origin</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float | Literal['x', 'X', 'y', 'Y']</code> <p>Angle in radians of the reflection line through the origin. If <code>theta</code> is the string 'x' or 'y', reflect over that axis.</p> required Source code in <code>src\\curvey\\curve.py</code> <pre><code>def reflect(self, theta: float | Literal[\"x\", \"X\", \"y\", \"Y\"]) -&gt; Curve:\n    \"\"\"Reflect the curve over a line through the origin\n\n    Parameters\n    ----------\n    theta\n        Angle in radians of the reflection line through the origin.\n        If `theta` is the string 'x' or 'y', reflect over that axis.\n    \"\"\"\n    if isinstance(theta, str):\n        if theta in (\"x\", \"X\"):\n            transform = reflection_matrix(0)\n        elif theta in (\"y\", \"Y\"):\n            transform = reflection_matrix(pi / 2)\n        else:\n            msg = \"Theta can only 'x', 'y', or an angle in radians\"\n            raise ValueError(msg)\n    else:\n        transform = reflection_matrix(theta)\n\n    return self.transform(transform)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.to_cw","title":"<code>to_cw() -&gt; Curve</code>","text":"<p>A clockwise-oriented curve</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def to_cw(self) -&gt; Curve:\n    \"\"\"A clockwise-oriented curve\"\"\"\n    return self.reverse() if self.signed_area &gt; 0 else self\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.to_ccw","title":"<code>to_ccw() -&gt; Curve</code>","text":"<p>A counterclockwise-oriented curve</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def to_ccw(self) -&gt; Curve:\n    \"\"\"A counterclockwise-oriented curve\"\"\"\n    return self.reverse() if self.signed_area &lt; 0 else self\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.transform","title":"<code>transform(transform: ndarray) -&gt; Curve</code>","text":"<p>Apply a 2x2 or 3x3 transform matrix to the vertex positions</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def transform(self, transform: ndarray) -&gt; Curve:\n    \"\"\"Apply a 2x2 or 3x3 transform matrix to the vertex positions\"\"\"\n    pts = self._pts\n    if transform.shape not in ((2, 2), (3, 3)):\n        msg = f\"Expected transform to have shape (2, 2) or (3, 3), got {transform.shape}\"\n        raise ValueError(msg)\n\n    sz = transform.shape[0]\n    if sz == 3:\n        pts = concatenate([pts, ones((self.n, 1))], axis=1)\n    pts = pts @ transform.T\n    pts = pts[:, :2] if sz == 3 else pts\n    return self.with_points(pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.to_area","title":"<code>to_area(area: float = 1.0) -&gt; Curve</code>","text":"<p>A new curve scaled to the supplied area</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def to_area(self, area: float = 1.0) -&gt; Curve:\n    \"\"\"A new curve scaled to the supplied area\"\"\"\n    return self.scale(sqrt(area / self.area))\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.to_edge_midpoints","title":"<code>to_edge_midpoints() -&gt; Curve</code>","text":"<p>The curve whose vertices are the midpoints of this curve's edges</p> <p>Mostly just useful for plotting scalar quantities on edge midpoints.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def to_edge_midpoints(self) -&gt; Curve:\n    \"\"\"The curve whose vertices are the midpoints of this curve's edges\n\n    Mostly just useful for plotting scalar quantities on edge midpoints.\n    \"\"\"\n    pts = self._pts + self.edge / 2\n    return self.with_points(pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.to_length","title":"<code>to_length(length: float = 1.0) -&gt; Curve</code>","text":"<p>A new curve scaled to the supplied length</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def to_length(self, length: float = 1.0) -&gt; Curve:\n    \"\"\"A new curve scaled to the supplied length\"\"\"\n    return self.scale(length / self.length)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.to_orientation","title":"<code>to_orientation(orientation: int) -&gt; Curve</code>","text":"<p>A curve with the specified orientation</p> <p>Parameters:</p> Name Type Description Default <code>orientation</code> <code>int</code> <p>Must be either 1 or -1.</p> required Source code in <code>src\\curvey\\curve.py</code> <pre><code>def to_orientation(self, orientation: int) -&gt; Curve:\n    \"\"\"A curve with the specified orientation\n\n    Parameters\n    ----------\n    orientation\n        Must be either 1 or -1.\n    \"\"\"\n    if orientation not in (1, -1):\n        msg = f\"orientation must be either 1 or -1, got {orientation}\"\n        raise ValueError(msg)\n\n    return self.reverse() if self.orientation != orientation else self\n</code></pre>"},{"location":"api/curve/#sampling-transformations","title":"Sampling transformations","text":""},{"location":"api/curve/#curvey.curve.Curve.collapse_shortest_edges","title":"<code>collapse_shortest_edges(n: int | None = None, min_edge_length: float | None = None) -&gt; Curve</code>","text":"<p>Remove vertices belonging to the shortest edges until a stopping criterion is met</p> Note <p>No attempt is made to prevent self-intersection.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Stop after collapsing this many edges.</p> <code>None</code> <code>min_edge_length</code> <code>float | None</code> <p>Stop when the shortest edge is longer than this.</p> <code>None</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def collapse_shortest_edges(\n    self,\n    n: int | None = None,\n    min_edge_length: float | None = None,\n) -&gt; Curve:\n    \"\"\"Remove vertices belonging to the shortest edges until a stopping criterion is met\n\n    Note\n    ----\n    No attempt is made to prevent self-intersection.\n\n    Parameters\n    ----------\n    n\n        Stop after collapsing this many edges.\n\n    min_edge_length\n        Stop when the shortest edge is longer than this.\n\n    \"\"\"\n    if n is None:\n        n = self.n - 3\n\n    if min_edge_length is None:\n        # noinspection PyArgumentList\n        min_edge_length = self.edge_length.max()\n\n    class Vertex(NamedTuple):\n        idx: int\n        prev: int\n        next: int\n        edge_length: float  # length from vertex i to i+1\n\n    # A doubly-linked list of vertices\n    verts = {\n        i: Vertex(\n            idx=i,\n            prev=(i - 1) % self.n,\n            next=(i + 1) % self.n,\n            edge_length=edge_length,\n        )\n        for i, edge_length in enumerate(self.edge_length)\n    }\n\n    # Priority queue by edge length\n    queue = sortedcontainers.SortedSet(verts.values(), key=lambda v: -v.edge_length)\n\n    for n_removed in itertools.count(1):\n        shortest = queue.pop(-1)\n        del verts[shortest.idx]\n\n        if (n_removed == n) or (queue[-1] &gt;= min_edge_length):\n            break\n\n        # Remove previous and next vertices so we can update them\n        queue.discard(v_prev := verts[shortest.prev])\n        queue.discard(v_next := verts[shortest.next])\n        updated_prev_edge_length = norm(self._pts[v_next.idx] - self._pts[v_prev.idx])\n\n        v_prev = verts[v_prev.idx] = Vertex(\n            idx=v_prev.idx,\n            prev=v_prev.prev,\n            next=v_next.idx,\n            edge_length=cast(float, updated_prev_edge_length),\n        )\n        v_next = verts[v_next.idx] = Vertex(\n            idx=v_next.idx,\n            prev=v_prev.idx,\n            next=v_next.next,\n            edge_length=v_next.edge_length,\n        )\n        queue.add(v_prev)\n        queue.add(v_next)\n\n    # Put the remaining vertices back in order\n    vert_idx = array(sorted(verts.keys()))\n    return self.with_points(self._pts[vert_idx])\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.interpolate","title":"<code>interpolate(s: ndarray, typ: InterpType = 'cubic') -&gt; Curve</code>","text":"<p>Construct a new curve by interpolating vertex coordinates at the supplied arclengths</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>ndarray</code> <p>Arclength values to interpolate at.</p> required <code>typ</code> <code>InterpType</code> <p>Type of interpolation, one of ('linear', 'cubic', 'pchip').</p> <code>'cubic'</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def interpolate(self, s: ndarray, typ: InterpType = \"cubic\") -&gt; Curve:\n    \"\"\"Construct a new curve by interpolating vertex coordinates at the supplied arclengths\n\n    Parameters\n    ----------\n    s\n        Arclength values to interpolate at.\n\n    typ\n        Type of interpolation, one of ('linear', 'cubic', 'pchip').\n    \"\"\"\n    pts = self.interpolator(typ=typ, f=self._pts)(s)\n    return self.with_points(pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.split_edges","title":"<code>split_edges(n: ndarray) -&gt; Curve</code>","text":"<p>Sample uniformly within edge segments</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>ndarray</code> <p>A integer-valued vector of length <code>self.n</code> indicating the number of points to sample from each edge.</p> <p>When <code>n[i] == 1</code>, simply sample vertex <code>i', i.e.</code>curve.split_edges(ones(curve.n, dtype='int'))` returns an identical curve.</p> <p>When <code>n[i] == 2</code>, sample at vertex <code>i</code> and the midpoint between vertex <code>i</code> and <code>i+1</code>.</p> <p>When <code>n[i] == 3</code> sample at vertex <code>i</code> and the one-third and two-thirds point, and so on.</p> <p>When <code>n[i] == 0</code>, vertex <code>i</code> is dropped from the output.</p> required <p>Returns:</p> Type Description <code>Curve</code> <p>A curve with <code>sum(n)</code> vertices.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def split_edges(self, n: ndarray) -&gt; Curve:\n    \"\"\"Sample uniformly within edge segments\n\n    Parameters\n    ----------\n    n\n        A integer-valued vector of length `self.n` indicating the number of points to sample\n        from each edge.\n\n        When `n[i] == 1`, simply sample vertex `i', i.e.\n        `curve.split_edges(ones(curve.n, dtype='int'))` returns an identical curve.\n\n        When `n[i] == 2`, sample at vertex `i` *and* the midpoint between vertex `i` and\n        `i+1`.\n\n        When `n[i] == 3` sample at vertex `i` and the one-third and two-thirds point, and so on.\n\n        When `n[i] == 0`, vertex `i` is dropped from the output.\n\n    Returns\n    -------\n    :\n        A curve with `sum(n)` vertices.\n    \"\"\"\n\n    edge_idx = repeat(arange(self.n), n)\n    edge_frac = concatenate([arange(ni) / ni for ni in n])\n    pts = self._pts[edge_idx] + edge_frac[:, newaxis] * self.edge[edge_idx]\n    return self.with_points(pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.split_longest_edges","title":"<code>split_longest_edges(n: int) -&gt; Curve</code>","text":"<p>Insert <code>n</code> new vertices by uniform edge subdivision</p> <p>Edges are split in priority of their length, so very long edges may be split into thirds, fourths, etc. before very short edges are split in half.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def split_longest_edges(self, n: int) -&gt; Curve:\n    \"\"\"Insert `n` new vertices by uniform edge subdivision\n\n    Edges are split in priority of their length, so very long edges may be split into\n    thirds, fourths, etc. before very short edges are split in half.\n    \"\"\"\n    if n == 0:\n        return self\n\n    if n &lt; 0:\n        msg = \"`n` must be &gt;= 0\"\n        raise ValueError(msg)\n\n    class Edge(NamedTuple):\n        split_length: float\n        n_subdivide: int\n        idx: int\n        orig_length: float\n\n    orig_edges = (\n        Edge(split_length=length, n_subdivide=1, idx=i, orig_length=length)\n        for (i, length) in enumerate(self.edge_length)\n    )\n\n    # Priority queue -- break length ties by the less split edge\n    queue = sortedcontainers.SortedList(orig_edges, key=lambda e: (e.length, -e.n_subdivide))\n\n    for _ in range(n):\n        edge = queue.pop()\n        edge.n_subdivide += 1\n        edge.split_length = edge.orig_length / edge.n_subdivide\n        queue.add(edge)\n\n    edges = sorted(queue, key=lambda e: e.idx)\n    n_subdivide = array([e.n_subdivide for e in edges])\n    return self.split_edges(n_subdivide)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.subdivide","title":"<code>subdivide(n: int = 1) -&gt; Curve</code>","text":"<p>Create a new curve by evenly subdividing each edge</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of new points to add to each edge. For <code>n = 1</code>, new points are added at the edge midpoint; for <code>n = 2</code>, points are added at the one-thirds and two-thirds points, etc. If <code>n = 0</code>, an identical curve is returned.</p> <code>1</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def subdivide(self, n: int = 1) -&gt; Curve:\n    \"\"\"Create a new curve by evenly subdividing each edge\n\n    Parameters\n    ----------\n    n\n        Number of new points to add to each edge. For `n = 1`, new points are added at the\n        edge midpoint; for `n = 2`, points are added at the one-thirds and two-thirds\n        points, etc. If `n = 0`, an identical curve is returned.\n    \"\"\"\n    if n &lt; 0:\n        msg = \"n must be &gt;= 0\"\n        raise ValueError(msg)\n\n    if n == 0:\n        return self\n\n    return self.split_edges(1 + n * ones(self.n, dtype=\"int\"))\n</code></pre>"},{"location":"api/curve/#target-transformations","title":"Target transformations","text":"<p>These transformations accept an additional target curve. </p>"},{"location":"api/curve/#curvey.curve.Curve.align_to","title":"<code>align_to(target: Curve, *, return_transform: bool = False) -&gt; Curve | ndarray</code>","text":"<p>Align to another curve by removing mean change in position and edge orientation</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Curve</code> <p>The target curve to align to. It must have the same number of vertices as <code>self</code>. The edges of the other curve are assumed to be in one-to-one correspondance to the edges in <code>self</code>.</p> required <code>return_transform</code> <code>bool</code> <p>If true, return the 3x3 transformation matrix. Otherwise, return a <code>Curve</code></p> <code>False</code> See also <p>Curve.register_to     Iterative closest point registration, which doesn't require corresponding vertices.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def align_to(self, target: Curve, *, return_transform: bool = False) -&gt; Curve | ndarray:\n    \"\"\"Align to another curve by removing mean change in position and edge orientation\n\n    Parameters\n    ----------\n    target\n        The target curve to align to. It must have the same number of vertices as `self`. The\n        edges of the other curve are assumed to be in one-to-one correspondance to the edges in\n        `self`.\n\n    return_transform\n        If true, return the 3x3 transformation matrix. Otherwise, return a `Curve`\n\n    See also\n    --------\n    [Curve.register_to][curvey.curve.Curve.register_to]\n        Iterative closest point registration, which doesn't require corresponding vertices.\n\n    \"\"\"\n    _ = self.check_same_n_vertices(target)\n\n    if return_transform:\n        return align_edges(\n            self._pts, self.edge, target._pts, target.edge, return_transform=True\n        )\n\n    pts = align_edges(self._pts, self.edge, target._pts, target.edge, return_transform=False)\n\n    return self.with_points(pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.optimize_edge_lengths_to","title":"<code>optimize_edge_lengths_to(other: Curve, interp_typ: InterpType = 'cubic') -&gt; Curve</code>","text":"<p>Optimize partitioning of vertex arclength positions to match edge_lengths in other</p> <p><code>self</code> and <code>other</code> must have the same number of vertices.</p> <p>This assumes <code>self</code> and <code>other</code> have already been processed to have the same length!</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Curve</code> <p>The curve to optimize against</p> required <code>interp_typ</code> <code>InterpType</code> <p>Passed to <code>Curve.interpolator</code></p> <code>'cubic'</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def optimize_edge_lengths_to(\n    self,\n    other: Curve,\n    interp_typ: InterpType = \"cubic\",\n) -&gt; Curve:\n    \"\"\"Optimize partitioning of vertex arclength positions to match edge_lengths in other\n\n    `self` and `other` must have the same number of vertices.\n\n    This assumes `self` and `other` have already been processed to have the same length!\n\n    Parameters\n    ----------\n    other\n        The curve to optimize against\n\n    interp_typ\n        Passed to `Curve.interpolator`\n    \"\"\"\n    n = self.check_same_n_vertices(other)\n\n    # So we don't need to refit each iteration\n    interpolator = self.interpolator(typ=interp_typ)\n\n    def _resample(ds: ndarray) -&gt; Curve:\n        arclength = append(0, cumsum(ds[:-1]))\n        return self.with_points(interpolator(arclength))\n\n    def _objective(ds: ndarray) -&gt; float:\n        resampled = _resample(ds)\n        return ((other.closed_arclength - resampled.closed_arclength) ** 2).sum()\n\n    # noinspection PyTypeChecker\n    opt = scipy.optimize.minimize(\n        fun=_objective,\n        x0=other.edge_length,\n        # Edge lengths must sum to total length\n        constraints=scipy.optimize.LinearConstraint(ones(n), lb=other.length, ub=other.length),\n        # Edge lengths must be positive\n        bounds=scipy.optimize.Bounds(lb=0),\n    )\n    if not opt.success:\n        msg = \"Optimization failed: \" + opt.message\n        warnings.warn(msg, OptimizationFailed, stacklevel=2)\n\n    return self.with_points(_resample(opt.x)._pts)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.orient_to","title":"<code>orient_to(other: Curve) -&gt; Curve</code>","text":"<p>A curve with the same orientation as <code>other</code></p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def orient_to(self, other: Curve) -&gt; Curve:\n    \"\"\"A curve with the same orientation as `other`\"\"\"\n    return self.to_orientation(other.orientation)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.register_to","title":"<code>register_to(target: Curve, allow_scale: bool = False, return_transform=False) -&gt; Curve | ndarray</code>","text":"<p>Iterative closest point registration</p> <p>Minimizes</p> \\[ \\sum_i \\min_j d(v_i, e_j)^2 \\] <p>where \\(d(v_i, e_j)\\) is the euclidean distance btween vertices \\(v_i\\) in <code>self</code> and edges \\(e_j\\) in <code>target</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>Curve</code> <p>The <code>Curve</code> to register to/</p> required <code>allow_scale</code> <code>bool</code> <p>If True, allow uniform scaling.</p> <code>False</code> <code>return_transform</code> <p>If True, return a 3x3 transform matrix. Otherwise, return the transformed <code>Curve</code>.</p> <code>False</code> See also <p>Curve.align_to     When <code>source</code> and <code>target</code> have the same number of vertices in 1-to-1 correspondance.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def register_to(\n    self,\n    target: Curve,\n    allow_scale: bool = False,\n    return_transform=False,\n) -&gt; Curve | ndarray:\n    r\"\"\"Iterative closest point registration\n\n    Minimizes\n\n    $$\n    \\sum_i \\min_j d(v_i, e_j)^2\n    $$\n\n    where $d(v_i, e_j)$ is the euclidean distance btween vertices $v_i$ in `self`\n    and edges $e_j$ in `target`.\n\n    Parameters\n    ----------\n    target\n        The `Curve` to register to/\n\n    allow_scale\n        If True, allow uniform scaling.\n\n    return_transform\n        If True, return a 3x3 transform matrix. Otherwise, return the transformed `Curve`.\n\n    See also\n    --------\n    [Curve.align_to][curvey.curve.Curve.align_to]\n        When `source` and `target` have the same number of vertices in 1-to-1 correspondance.\n    \"\"\"\n    tree = shapely.STRtree(target.to_shapely(\"edges\").geoms)\n\n    def get_transform(params: ndarray) -&gt; ndarray:\n        \"\"\"3x3 transform matrix\"\"\"\n        if len(params) == 4:\n            theta, dx, dy, scale_factor = params\n        else:\n            theta, dx, dy = params\n            scale_factor = 1\n\n        cos_theta, sin_theta = scale_factor * cos(theta), scale_factor * sin(theta)\n        return array(\n            [\n                [cos_theta, -sin_theta, dx],\n                [sin_theta, cos_theta, dy],\n                [0, 0, 1],\n            ]\n        )\n\n    def sum_sq_dist_closest_pt(params: ndarray) -&gt; float:\n        transformed = self.transform(get_transform(params))\n        (_self_idx, _other_idx), dists = tree.query_nearest(\n            geometry=transformed.to_shapely(\"points\").geoms,\n            return_distance=True,\n            all_matches=False,\n        )\n        return (dists**2).sum()\n\n    opt = scipy.optimize.minimize(\n        fun=sum_sq_dist_closest_pt,\n        x0=array([0, 0, 0, 1] if allow_scale else [0, 0, 0]),\n    )\n    if not opt.success:\n        msg = f\"Optimization failed: {opt.message}\"\n        warnings.warn(msg, category=OptimizationFailed, stacklevel=2)\n\n    transform = get_transform(opt.x)\n    return transform if return_transform else self.transform(transform)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.roll_to","title":"<code>roll_to(other: Curve) -&gt; Curve</code>","text":"<p>Cyclicly permute points to minimize the distance between corresponding points</p> <p><code>other</code> must have the same number of vertices as <code>self</code></p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def roll_to(self, other: Curve) -&gt; Curve:\n    \"\"\"Cyclicly permute points to minimize the distance between corresponding points\n\n    `other` must have the same number of vertices as `self`\n    \"\"\"\n    n = self.check_same_n_vertices(other)\n\n    # (n, n) array of pairwise square distances\n    dist = scipy.spatial.distance.cdist(other._pts, self._pts, \"sqeuclidean\")\n    i0 = arange(n)\n\n    # (n, n) cyclic permutation matrix\n    #   [[0, 1, 2, 3, ..., n-1]\n    #    [1, 2, 3, ..., n-1, 0]\n    #    [2, 3, ..., n-1, 0, 1] ... ]\n    i1 = (i0[:, newaxis] + i0[newaxis, :]) % n\n\n    # The permutation index that minimizes sum of sq. dists\n    i_min = cast(int, argmin(dist[i0, i1].sum(axis=1)))\n    return self.roll(-i_min)\n</code></pre>"},{"location":"api/curve/#plotting","title":"Plotting","text":""},{"location":"api/curve/#curvey.curve.Curve.plot","title":"<code>plot(color='black', ax: Axes | None = None, **kwargs) -&gt; Line2D</code>","text":"<p>Plot the curve as a closed contour</p> <p>For more sophisticated plotting see methods <code>plot_points</code>, <code>plot_edges</code>, and <code>plot_vectors</code>.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <p>A matplotlib colorlike.</p> <code>'black'</code> <code>ax</code> <code>Axes | None</code> <p>Defaults to the current axes.</p> <code>None</code> <code>**kwargs</code> <p>additional kwargs passed to <code>matplotlib.pyplot.plot</code></p> <code>{}</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def plot(self, color=\"black\", ax: Axes | None = None, **kwargs) -&gt; Line2D:\n    \"\"\"Plot the curve as a closed contour\n\n    For more sophisticated plotting see methods `plot_points`, `plot_edges`, and `plot_vectors`.\n\n    Parameters\n    ----------\n    color\n        A matplotlib colorlike.\n\n    ax\n        Defaults to the current axes.\n\n    **kwargs\n        additional kwargs passed to `matplotlib.pyplot.plot`\n\n    \"\"\"\n    ax = _get_ax(ax)\n    (line,) = ax.plot(*self.closed_points.T, color=color, **kwargs)\n    return line\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.plot_edges","title":"<code>plot_edges(color: ndarray | None = None, directed: bool = True, width: float | ndarray | None = None, scale_width: tuple[float, float] | None = None, ax: Axes | None = None, **kwargs) -&gt; Quiver | LineCollection</code>","text":"<p>Plot a scalar quantity on curve edges</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>ndarray | None</code> <p>The color to plot each edge. Defaults to curve arc length.</p> <code>None</code> <code>directed</code> <code>bool</code> <p>If True, plot edges as arrows between vertices. Otherwise, edges are line segments.</p> <code>True</code> <code>width</code> <code>float | ndarray | None</code> <p>The thickness of each edge segment, scalar or edge quantity vector.</p> <code>None</code> <code>scale_width</code> <code>tuple[float, float] | None</code> <p>Min and max widths to scale the edge quantity to.</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>The matplotlib axes to plot in. Defaults to current axes.</p> <code>None</code> <code>**kwargs</code> <p>Aadditional kwargs passed to <code>plt.quiver</code> or <code>LineCollection</code> depending on <code>directed</code>.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Quiver</code> <p>If <code>directed</code> is True.</p> <code>LineCollection</code> <p>If <code>directed</code> is False.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def plot_edges(\n    self,\n    color: ndarray | None = None,\n    directed: bool = True,\n    width: float | ndarray | None = None,\n    scale_width: tuple[float, float] | None = None,\n    ax: Axes | None = None,\n    **kwargs,\n) -&gt; Quiver | LineCollection:\n    \"\"\"Plot a scalar quantity on curve edges\n\n    Parameters\n    ----------\n    color\n        The color to plot each edge. Defaults to curve arc length.\n\n    directed\n        If True, plot edges as arrows between vertices. Otherwise, edges are line segments.\n\n    width\n        The thickness of each edge segment, scalar or edge quantity vector.\n\n    scale_width\n        Min and max widths to scale the edge quantity to.\n\n    ax\n        The matplotlib axes to plot in. Defaults to current axes.\n\n    **kwargs\n        Aadditional kwargs passed to `plt.quiver` or `LineCollection` depending on `directed`.\n\n    Returns\n    -------\n    : matplotlib.quiver.Quiver\n        If `directed` is True.\n\n    : matplotlib.collections.LineCollection\n        If `directed` is False.\n    \"\"\"\n    ax = _get_ax(ax)\n    width = _rescale(width, scale_width)\n    colorspec = _VariableColorSpec.parse(\n        n_data=self.n, supplied=color, default_varied=self.arclength\n    )\n\n    if directed:\n        if isinstance(width, (collections.abc.Sequence, ndarray)):\n            msg = (\n                \"`width` was supplied as a sequence but \"\n                \"matplotlib.pyplot.Quiver doesn't support scaling individual arrows. \"\n                \"Use directed=False to scale edge width.\"\n            )\n            raise ValueError(msg)\n\n        x, y = self._pts.T\n        dx, dy = self.edge.T\n        return ax.quiver(\n            x,\n            y,\n            dx,\n            dy,\n            *colorspec.maybe_varied,\n            color=colorspec.fixed,\n            angles=\"xy\",\n            scale_units=\"xy\",\n            scale=1.0,\n            width=width,\n            **kwargs,\n        )\n\n    # not directed\n    pts = self.closed_points.reshape((-1, 1, 2))\n    segments = concatenate([pts[:-1], pts[1:]], axis=1)\n\n    if colorspec.varied is not None:\n        lc = LineCollection(\n            segments=segments,\n            cmap=\"viridis\",\n            norm=plt.Normalize(),\n            linewidths=width,\n            **kwargs,\n        )\n        lc.set_array(colorspec.varied)\n    else:\n        lc = LineCollection(segments=segments, color=colorspec.fixed, linewidths=width)\n    ax.add_collection(lc)\n\n    # Adding a line collection doesn't update limits so do it here\n    ax.update_datalim(self._pts)\n    ax.autoscale_view()\n    return lc\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.plot_points","title":"<code>plot_points(color: ndarray | Any | None = None, size: ndarray | float | None = None, scale_sz: tuple[float, float] | None = None, ax: Axes | None = None, **kwargs) -&gt; PathCollection</code>","text":"<p>Plot a scalar quantity on curve vertices</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>ndarray | Any | None</code> <p>Either a matplotlib scalar colorlike or length <code>n</code> array of scalar vertex quantities. Defaults to <code>self.dual_edge_length</code>.</p> <code>None</code> <code>size</code> <code>ndarray | float | None</code> <p>Length <code>n</code> scalar vertex quantity to size markers by, or a fixed size for all vertices.</p> <code>None</code> <code>scale_sz</code> <code>tuple[float, float] | None</code> <p>Min and max sizes to scale the vertex quantity <code>size</code> to.</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>Matplotlib axes to plot in. Defaults to the current axes.</p> <code>None</code> <code>**kwargs</code> <p>additional kwargs passed to <code>matplotlib.pyplot.scatter</code></p> <code>{}</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def plot_points(\n    self,\n    color: ndarray | Any | None = None,\n    size: ndarray | float | None = None,\n    scale_sz: tuple[float, float] | None = None,\n    ax: Axes | None = None,\n    **kwargs,\n) -&gt; PathCollection:\n    \"\"\"Plot a scalar quantity on curve vertices\n\n    Parameters\n    -----------\n    color\n        Either a matplotlib scalar colorlike or length `n` array of scalar vertex\n        quantities. Defaults to `self.dual_edge_length`.\n\n    size\n        Length `n` scalar vertex quantity to size markers by, or a fixed size\n        for all vertices.\n\n    scale_sz\n        Min and max sizes to scale the vertex quantity `size` to.\n\n    ax\n        Matplotlib axes to plot in. Defaults to the current axes.\n\n    **kwargs\n        additional kwargs passed to `matplotlib.pyplot.scatter`\n\n    \"\"\"\n    ax = _get_ax(ax)\n\n    if color is None:\n        color = self.dual_edge_length\n\n    size = _rescale(size, scale_sz)\n\n    return ax.scatter(self.x, self.y, s=size, c=color, **kwargs)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.plot_vectors","title":"<code>plot_vectors(vectors: ndarray | None = None, scale: ndarray | None = None, color=None, scale_length: tuple[float, float] | None = None, ax: Axes | None = None, **kwargs) -&gt; Quiver</code>","text":"<p>Plot vector quantities on curve vertices</p> <p>To plot vector quantities on edges use <code>curve.to_edge_midpoints.plot_vectors(...)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>vectors</code> <code>ndarray | None</code> <p>A <code>(n, 2)</code> array of vectors. Defaults to curve normals.</p> <code>None</code> <code>scale</code> <code>ndarray | None</code> <p>A length <code>n</code> vector of length scalars to apply to the vectors.</p> <code>None</code> <code>color</code> <p>Length <code>n</code> vector of scalar vertex quantities to color by, or a constant color for all edges.</p> <code>None</code> <code>scale_length</code> <code>tuple[float, float] | None</code> <p>Limits to scale vector length to, after applying <code>scale</code>.</p> <code>None</code> <code>ax</code> <code>Axes | None</code> <p>The axes to plot in. Defaults to the current axes.</p> <code>None</code> <code>**kwargs</code> <p>additional kwargs passed to <code>matplotlib.pyplot.quiver</code></p> <code>{}</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def plot_vectors(\n    self,\n    vectors: ndarray | None = None,\n    scale: ndarray | None = None,\n    color=None,\n    scale_length: tuple[float, float] | None = None,\n    ax: Axes | None = None,\n    **kwargs,\n) -&gt; Quiver:\n    \"\"\"Plot vector quantities on curve vertices\n\n    To plot vector quantities on edges use `curve.to_edge_midpoints.plot_vectors(...)`.\n\n    Parameters\n    ----------\n    vectors\n        A `(n, 2)` array of vectors. Defaults to curve normals.\n\n    scale\n        A length `n` vector of length scalars to apply to the vectors.\n\n    color\n        Length `n` vector of scalar vertex quantities to color by, or a\n        constant color for all edges.\n\n    scale_length\n        Limits to scale vector length to, after applying `scale`.\n\n    ax\n        The axes to plot in. Defaults to the current axes.\n\n    **kwargs\n        additional kwargs passed to `matplotlib.pyplot.quiver`\n    \"\"\"\n    ax = _get_ax(ax)\n\n    _vectors = self.normal if vectors is None else vectors\n\n    if scale is not None:\n        _vectors = scale.reshape(-1, 1) * _vectors\n\n    if scale_length is not None:\n        length = norm(_vectors, axis=1, keepdims=True)\n        scaled_length = _rescale(length, scale_length)\n        _vectors = _vectors / length * scaled_length\n\n    colorspec = _VariableColorSpec.parse(self.n, color, default_fixed=\"black\")\n\n    # By default quiver doesn't include vector endpoints in x/y lim calculations\n    ax.update_datalim(self._pts + _vectors)\n\n    x, y = self._pts.T\n    dx, dy = _vectors.T\n    return ax.quiver(\n        x,\n        y,\n        dx,\n        dy,\n        *colorspec.maybe_varied,\n        color=colorspec.fixed,\n        angles=\"xy\",\n        scale_units=\"xy\",\n        scale=1.0,\n        **kwargs,\n    )\n</code></pre>"},{"location":"api/curve/#special","title":"Special","text":""},{"location":"api/curve/#curvey.curve.Curve.check_same_n_vertices","title":"<code>check_same_n_vertices(other: Curve) -&gt; int</code>","text":"<p>Raises a <code>ValueError</code> if vertex counts don't match</p> <p>Otherwise, returns the common vertex count.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def check_same_n_vertices(self, other: Curve) -&gt; int:\n    \"\"\"Raises a `ValueError` if vertex counts don't match\n\n    Otherwise, returns the common vertex count.\n    \"\"\"\n    if self.n != other.n:\n        msg = (\n            \"Curve pair must have the same number of vertices. \"\n            f\"Got self.n = {self.n} and other.n = {other.n}\"\n        )\n        raise MismatchedVertexCounts(msg)\n    return self.n\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.deriv","title":"<code>deriv(f: ndarray | None = None) -&gt; ndarray</code>","text":"<p>Second order finite differences approximations of arclength-parametrized derivatives</p> <p>Derivatives are calculated by circularly padding the arclength <code>s</code> and function values <code>f(s)</code>, passing those to <code>numpy.gradient</code> to calculate second order finite differences, and then dropping the padded values.</p> <p><code>f</code> is the function values to derivate. By default, this is the curve points, so <code>curve.deriv()</code> computes the curve tangent. Repeated application will compute the second derivative, e.g.</p> <pre><code>from curvey import Curve\n\nc = Curve.circle(n=20)\ndf_ds = c.deriv()\nd2f_ds2 = c.deriv(f=df_ds)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>f</code> <code>ndarray | None</code> <p>The <code>(n,)</code> or <code>(n, ndim)</code> array of function values. Defaults to <code>self.points</code></p> <code>None</code> <p>Returns:</p> Name Type Description <code>deriv</code> <code>ndarray</code> <p>The <code>(n,)</code> or <code>(n, ndim)</code> array of function derivature values.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def deriv(self, f: ndarray | None = None) -&gt; ndarray:\n    \"\"\"Second order finite differences approximations of arclength-parametrized derivatives\n\n    Derivatives are calculated by circularly padding the arclength `s` and function values\n    `f(s)`, passing those to `numpy.gradient` to calculate second order finite differences,\n    and then dropping the padded values.\n\n    `f` is the function values to derivate. By default, this is the curve points, so\n    `curve.deriv()` computes the curve tangent. Repeated application will compute the second\n    derivative, e.g.\n\n    ```python\n    from curvey import Curve\n\n    c = Curve.circle(n=20)\n    df_ds = c.deriv()\n    d2f_ds2 = c.deriv(f=df_ds)\n    ```\n\n    Parameters\n    ----------\n    f\n        The `(n,)` or `(n, ndim)` array of function values. Defaults to `self.points`\n\n    Returns\n    -------\n    deriv :\n        The `(n,)` or `(n, ndim)` array of function derivature values.\n\n    \"\"\"\n    if f is None:\n        f = self._pts\n\n    # Circularly pad arrays so that the derivatives of the first and last actual points are\n    # calculated in the same way as the interior points\n    f_periodic = concatenate([f[[-1]], f, f[[0]]], axis=0)\n    s = self.cum_edge_length\n    s = concatenate([[-self.edge_length[-1], 0], s])\n    df_ds = gradient(f_periodic, s, axis=0)\n    return df_ds[1:-1]  # Drop padded points\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.edge_intersections","title":"<code>edge_intersections() -&gt; ndarray</code>","text":"<p>An <code>(n_intersect, 2)</code> array of points where two edges cross</p> <p>This does not include two co-incident vertices or an edge coincident on a non-adjacent vertex.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def edge_intersections(self) -&gt; ndarray:\n    \"\"\"An `(n_intersect, 2)` array of points where two edges cross\n\n    This does not include two co-incident vertices or an edge coincident on\n    a non-adjacent vertex.\n    \"\"\"\n    # Use unary union to resolve all self-intersections\n    mls: shapely.MultiLineString = shapely.unary_union(self.to_shapely(\"ring\"))\n    all_pts = shapely.extract_unique_points(mls)\n    intersections = all_pts - self.to_shapely(\"points\")  # Set difference\n\n    if intersections.is_empty:\n        return zeros((0, 2))\n\n    if isinstance(intersections, shapely.Point):\n        return array(intersections.coords)  # (1, 2)\n\n    return concatenate([pt.coords for pt in intersections.geoms])\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.interpolator","title":"<code>interpolator(typ: InterpType = 'cubic', f: ndarray | None = None) -&gt; Callable[[ndarray], ndarray]</code>","text":"<p>Construct a function interpolator on curve arclength</p> <p>Parameters:</p> Name Type Description Default <code>typ</code> <code>InterpType</code> <p>The class of spline to use for interpolation. One of 'linear', 'cubic', or 'pchip'.</p> <code>'cubic'</code> <code>f</code> <code>ndarray | None</code> <p>The (n_verts,) or (n_verts, ndim) array of function values to interpolate. By default, this is just the vertex positions.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>interpolator</code> <code>Callable[[ndarray], ndarray]</code> <p>A function g(s) <code>ndarray -&gt; ndarray</code> that interpolates values of f at the arclengths s.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def interpolator(\n    self,\n    typ: InterpType = \"cubic\",\n    f: ndarray | None = None,\n) -&gt; Callable[[ndarray], ndarray]:\n    \"\"\"Construct a function interpolator on curve arclength\n\n    Parameters\n    ----------\n    typ\n        The class of spline to use for interpolation. One of 'linear', 'cubic', or\n        'pchip'.\n\n    f\n        The (n_verts,) or (n_verts, ndim) array of function values to interpolate. By default,\n        this is just the vertex positions.\n\n    Returns\n    -------\n    interpolator :\n        A function g(s) `ndarray -&gt; ndarray` that interpolates values of f at the arclengths s.\n    \"\"\"\n    f = self._pts if f is None else f\n    return periodic_interpolator(self.closed_arclength, f, typ=typ)\n</code></pre>"},{"location":"api/curve/#library-interface","title":"Library interface","text":""},{"location":"api/curve/#curvey.curve.Curve.to_shapely","title":"<code>to_shapely(mode: Literal['ring', 'edges', 'polygon', 'points'] = 'ring')</code>","text":"<p>Convenience converter to <code>shapely</code> object</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal['ring', 'edges', 'polygon', 'points']</code> <p>Which type of <code>shapely</code> geometry to return.</p> <ul> <li>'ring': a <code>LinearRing</code> corresponding to the closed curve.</li> <li>'edges': a <code>MultiLineString</code> containing <code>n_edges</code> 2-point line segments.</li> <li>'polygon': a <code>Polygon</code> enclosed by the curve.</li> <li>'points': a <code>MultiPoint</code> containing the vertices.</li> </ul> <code>'ring'</code> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def to_shapely(\n    self,\n    mode: Literal[\"ring\", \"edges\", \"polygon\", \"points\"] = \"ring\",\n):\n    \"\"\"Convenience converter to `shapely` object\n\n    Parameters\n    ----------\n    mode\n        Which type of `shapely` geometry to return.\n\n          - 'ring': a `LinearRing` corresponding to the closed curve.\n          - 'edges': a `MultiLineString` containing `n_edges` 2-point line segments.\n          - 'polygon': a `Polygon` enclosed by the curve.\n          - 'points': a `MultiPoint` containing the vertices.\n    \"\"\"\n    if mode == \"ring\":\n        return shapely.LinearRing(self._pts)\n\n    if mode == \"edges\":\n        pts0 = self._pts\n        pts1 = roll(pts0, 1, axis=0)\n        return shapely.MultiLineString(list(zip(pts0, pts1)))\n\n    if mode == \"polygon\":\n        return shapely.Polygon(self._pts)\n\n    if mode == \"points\":\n        return shapely.MultiPoint(self._pts)\n\n    modes = \", \".join((\"ring\", \"edges\", \"polygon\", \"points\"))  # type: ignore [unreachable]\n    msg = f\"mode must be one of ({modes}), got {mode}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"api/curve/#curvey.curve.Curve.triangulate","title":"<code>triangulate(max_tri_area: float | None = None, min_angle: float | None = None, extra_params: str | None = None) -&gt; tuple[ndarray, ndarray, ndarray]</code>","text":"<p>Triangulate the polygon enclosed by the curve with Shewchuck's triangulation library</p> <p>The python bindings triangle must be importable. They can be installed with <code>pip install triangle</code>.</p> <p>Parameters:</p> Name Type Description Default <code>max_tri_area</code> <code>float | None</code> <p>A global maximum triangle area constraint.</p> <code>None</code> <code>min_angle</code> <code>float | None</code> <p>Minimum angle constraint, in degrees.</p> <code>None</code> <code>extra_params</code> <code>str | None</code> <p>See the API documentation. E.g. `extra_params='S10X' specifies a maximum number of 10 Steiner points and suppresses exact arithmetic.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>points</code> <code>ndarray</code> <p>The <code>(n, 2)</code> vertex coordinates of the triangulation. If <code>max_tri_area=None</code>, this is probably equal to <code>self.points</code></p> <code>tris</code> <code>ndarray</code> <p><code>(n_tris, 3)</code> array of integer vertex indices.</p> <code>is_border</code> <code>ndarray</code> <p>Length <code>n</code> vector of booleans, true for vertices on the border of the triangulation.</p> Source code in <code>src\\curvey\\curve.py</code> <pre><code>def triangulate(\n    self,\n    max_tri_area: float | None = None,\n    min_angle: float | None = None,\n    extra_params: str | None = None,\n) -&gt; tuple[ndarray, ndarray, ndarray]:\n    \"\"\"Triangulate the polygon enclosed by the curve with Shewchuck's triangulation library\n\n    The python bindings [triangle](https://rufat.be/triangle/index.html) must be importable.\n    They can be installed with `pip install triangle`.\n\n    Parameters\n    ----------\n    max_tri_area: float, optional\n        A global maximum triangle area constraint.\n\n    min_angle: float, optional\n        Minimum angle constraint, in degrees.\n\n    extra_params: str, optional\n        See the [API documentation](https://rufat.be/triangle/API.html).\n        E.g. `extra_params='S10X' specifies a maximum number of 10 Steiner points and suppresses\n        exact arithmetic.\n\n    Returns\n    -------\n    points :\n        The `(n, 2)` vertex coordinates of the triangulation. If `max_tri_area=None`,\n        this is probably equal to `self.points`\n\n    tris :\n        `(n_tris, 3)` array of integer vertex indices.\n\n    is_border :\n        Length `n` vector of booleans, true for vertices on the border of the triangulation.\n\n    \"\"\"\n    try:\n        import triangle\n    except ImportError as e:\n        msg = \"Cannot import `triangle`. Use `pip install triangle` to install.\"\n        raise ValueError(msg) from e\n\n    idx = arange(self.n)\n    segments = stack([idx, roll(idx, -1)], axis=1)\n    params = \"p\"  # Constrained polygon triangulation\n    if max_tri_area is not None:\n        params += f\"a{max_tri_area: f}\"\n    if min_angle is not None:\n        params += f\"q{min_angle: f}\"\n    if extra_params is not None:\n        params += extra_params\n\n    d = triangle.triangulate({\"vertices\": self._pts, \"segments\": segments}, params)\n    verts, tris, is_border = d[\"vertices\"], d[\"triangles\"], d[\"vertex_markers\"]\n    is_border = is_border.astype(bool).squeeze()\n    return verts, tris, is_border\n</code></pre>"},{"location":"api/curves/","title":"curvey.curves","text":""},{"location":"api/curves/#curvey.curves","title":"<code>curves</code>","text":"<p>Sequences of curves</p>"},{"location":"api/curves/#curvey.curves.Curves","title":"<code>Curves</code>","text":"<p>A container of <code>Curve</code>s</p> <p>The constructor accepts an iterator of <code>Curve</code>s: <pre><code>from curvey import Curve, Curves\n\ncurves = Curves(Curve.circle(n=20, r=r) for r in (1, 2, 3))\n</code></pre></p> <p><code>Curves</code> can be iterated over: <pre><code>for c in curves:\n    ...\n</code></pre></p> <p><code>Curves</code> can be indexed with:</p> <ul> <li> <p>an int: <code>curves[i]</code> returns the <code>Curve</code> at the <code>i</code>ith position</p> </li> <li> <p>a slice or numpy index-like array: <code>curves[::2]</code> returns a new <code>Curves</code> containing every     second curve</p> </li> <li> <p>a string: <code>curves['param']</code> returns an array of the curve metadata or <code>Curve</code> attribute     associated with each <code>Curve</code> in the <code>Curves</code></p> </li> <li> <p>a function: <code>curves[fn]</code> is equivalent to <code>array([fn(c) for c in curves])</code></p> </li> </ul> <p>Use <code>Curves.subplots</code> or <code>Curves.superimposed</code> to plot every curve in the <code>Curves</code> at once.</p> <p>Use <code>Curves.plot</code> to plot <code>Curve</code> metadata values against eachother.</p> <p>Parameters:</p> Name Type Description Default <code>curves</code> <code>Iterable[Curve] | None</code> <p>A iterable of <code>Curves</code>. Defaults to an empty sequence if not supplied.</p> <code>None</code> Source code in <code>src\\curvey\\curves.py</code> <pre><code>class Curves:\n    \"\"\"A container of `Curve`s\n\n    The constructor accepts an iterator of `Curve`s:\n    ```python\n    from curvey import Curve, Curves\n\n    curves = Curves(Curve.circle(n=20, r=r) for r in (1, 2, 3))\n    ```\n\n    `Curves` can be iterated over:\n    ```python\n    for c in curves:\n        ...\n    ```\n\n    `Curves` can be indexed with:\n\n    - an int: `curves[i]` returns the `Curve` at the `i`ith position\n\n    - a slice or numpy index-like array: `curves[::2]` returns a new `Curves` containing every\n        second curve\n\n    - a string: `curves['param']` returns an array of the curve metadata or `Curve` attribute\n        associated with each `Curve` in the `Curves`\n\n    - a function: `curves[fn]` is equivalent to `array([fn(c) for c in curves])`\n\n    Use `Curves.subplots` or `Curves.superimposed` to plot every curve in the `Curves` at once.\n\n    Use `Curves.plot` to plot `Curve` metadata values against eachother.\n\n    Parameters\n    ----------\n    curves\n        A iterable of `Curves`. Defaults to an empty sequence if not supplied.\n    \"\"\"\n\n    def __init__(self, curves: Iterable[Curve] | None = None):\n        self.curves: list[Curve] = []\n        \"\"\"The `Curve`s contained in this `Curves`\"\"\"\n\n        if curves is not None:\n            self.curves.extend(curves)\n\n    @property\n    def n(self) -&gt; int:\n        \"\"\"Number of curves in the sequence\"\"\"\n        return len(self.curves)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Number of curves in the sequence\"\"\"\n        return len(self.curves)\n\n    def __add__(self, other: Curves | list[Curve]) -&gt; Curves:\n        \"\"\"Concatenate two `Curves` to form a new sequence\"\"\"\n        if isinstance(other, Curves):\n            return Curves(self.curves + other.curves)\n\n        # Just hope this raises a reasonable error if it fails\n        return Curves(self.curves + other)\n\n    def append(self, curve: Curve):\n        \"\"\"Add a curve to the end of the sequence\"\"\"\n        self.curves.append(curve)\n\n    def keys(self, mode: Literal[\"intersection\", \"union\"] = \"union\") -&gt; set[str]:\n        \"\"\"Unique curve metadata parameter names\n\n        Parameters\n        ----------\n        mode\n            If 'union', return keys that are present on any `Curve` in the `Curves`.\n            If 'intersection', return only keys that are present on all `Curve`s in the `Curves`.\n        \"\"\"\n        if self.n == 0:\n            return set()\n\n        keys = (set(c.data.keys()) for c in self)\n        if mode == \"intersection\":\n            return set.intersection(*keys)\n\n        if mode == \"union\":\n            return set.union(*keys)\n\n        raise ValueError(mode)\n\n    def __repr__(self) -&gt; str:\n        if keys := self.keys():\n            data = \", \".join(k for k in sorted(keys))\n            # Gross triple nested curlies here, so it formats like `Curves(n=3, data={foo, bar})`\n            return f\"Curves(n={self.n}, data={{{data}}})\"\n\n        return f\"Curves(n={self.n})\"\n\n    def __iter__(self) -&gt; Iterator[Curve]:\n        \"\"\"Iterate over curves in the sequence\n\n        The index of the curve is stored in the 'idx' metadata parameter.\n        Use `Curves.iter_curves` to supply a custom name for index, if necessary.\n        \"\"\"\n        return self.iter_curves()\n\n    def iter_curves(self, idx: str = \"idx\") -&gt; Iterator[Curve]:\n        \"\"\"Iterate over curves in the sequence\n\n        The index of the curve is stored in the `idx` metadata parameter. This might be useful for\n        tracking the original index in a subset.\n\n        ```python\n        from curvey import Curves\n\n        orig = Curves(Curve.circle(3) for _ in range(6))\n        every_other = Curves(orig.iter_curves('orig_idx'))[::2]\n        every_other['orig_idx']\n        ```\n        \"\"\"\n        for i, c in enumerate(self.curves):\n            yield c.with_data(**{idx: i})\n\n    def get_named_data(self, data: BareMetadata | NamedMetadata, **kwargs) -&gt; tuple[str, ndarray]:\n        \"\"\"Get curve metadata (name, values) pairs\n\n        If `data` is just a name, return (name, values).\n        If `data` is something that can reasonably interpreted as `values`,\n        try to figure out a reasonable name for them.\n        \"\"\"\n        if isinstance(data, str):\n            return data, self.get_data(data, **kwargs)\n\n        if isinstance(data, tuple) and len(data) == 2:\n            name = data[0]\n            if not isinstance(name, str):\n                msg = f\"Expected metadata name to be str, got {name}\"\n                raise TypeError(msg)\n            return name, self.get_data(data[1], **kwargs)\n\n        if callable(data):\n            name = data.__name__ if hasattr(data, \"__name__\") else str(data)\n            return name, self.get_data(data, **kwargs)\n\n        name = type(data).__name__\n        return name, self.get_data(data, **kwargs)\n\n    def get_data(\n        self,\n        data: BareMetadata,\n        default: Any = nan,\n        allow_default: bool = True,\n        allow_property: bool = True,\n    ) -&gt; ndarray:\n        \"\"\"Concatenate curve metadata into an array of length `n`\n\n        Parameters\n        ----------\n        data\n            One of:\n\n            - Name of the property stored in curve metadata\n            - Name of a `Curve` attribute, if `allow_property` is true\n            - A function `Curve -&gt; value`\n            - An length `n` array or list of values\n\n        allow_property\n            If true, `data` may be the name of a Curve attribute, such as 'area' or 'length'\n\n        allow_default\n            If true, and the requested data is only available on a subset of curves, return\n            `default` for those curves.\n\n        default\n            The default value if named parameter `data` is not present in a curve's metadata.\n            If not supplied, all curves in the collection must have that metadata parameter,\n            otherwise a `KeyError` is raised.\n\n        \"\"\"\n        if isinstance(data, str):\n            if data in self.keys(\"union\"):\n                if allow_default:\n                    return array([c.data.get(data, default) for c in self])\n\n                if data in self.keys(\"intersection\"):\n                    msg = f\"Metadata '{data}' is only present on some curves\"\n                    raise KeyError(msg)\n\n                return array([c[data] for c in self])\n\n            if hasattr(Curve, data):\n                if allow_property:\n                    return array([getattr(c, data) for c in self])\n\n                msg = (\n                    f\"Metadata '{data}' not found. \"\n                    \"it's a Curve property but `allow_property` is False\"\n                )\n                raise KeyError(msg)\n\n            msg = f\"Metadata '{data}' not found\"\n            raise KeyError(msg)\n\n        if callable(data):\n            return array([data(c) for c in self])\n\n        if isinstance(data, Sequence):\n            if (n := len(data)) != self.n:\n                msg = f\"Expected a sequence of length self.n = {self.n}, got {n}\"\n                raise ValueError(msg)\n            return asarray(data)\n\n        msg = f\"Unrecognized data type {type(data)}\"  # type: ignore [unreachable]\n        raise TypeError(msg)\n\n    @overload\n    def __getitem__(self, idx: int) -&gt; Curve: ...\n\n    @overload\n    def __getitem__(self, idx: slice) -&gt; Curves: ...\n\n    @overload\n    def __getitem__(self, idx: str | collections.abc.Callable) -&gt; ndarray: ...\n\n    def __getitem__(\n        self,\n        idx: str | int | slice | ArrayLike | collections.abc.Callable,\n    ) -&gt; Curve | Curves | ndarray:\n        \"\"\"Convenience method to index the sequence\n\n        `Curves[int]` returns the curve stored at that index.\n        `Curves[str]` returns a `ndarray` of `n` metadata values.\n        `Curves[fn]` for `fn: Callable[[Curve], Any]` returns a `ndarray` of the values\n        of that function called on the `n` curves in the sequence.\n\n        Otherwise, `Curves[idx]` returns a new `Curves` for that index,\n        obeying list slicing and numpy smart indexing behavior. E.g. `sequence[::3]` returns\n        a new curve sequence for every third curve in the original sequence.\n\n        \"\"\"\n        if isinstance(idx, str):\n            return self.get_data(idx)\n\n        if callable(idx):\n            return self.get_data(idx)\n\n        if isinstance(idx, (int, np.integer)):\n            # Recast to int here so indexing with np.int works as expected\n            return self.curves[int(idx)]\n\n        # noinspection PyUnresolvedReferences\n        idx = arange(self.n)[idx]  # type: ignore [index]\n        all_curves = self.curves\n        curves = [all_curves[int(i)] for i in idx]\n        return Curves(curves=curves)\n\n    def plot(\n        self,\n        y: Metadata,\n        x: Metadata | None = None,\n        ax: Axes | None = None,\n        label_axes: bool | None = None,\n        label: str | bool | None = True,\n        **kwargs,\n    ):\n        \"\"\"Plot metadata values against each other.\n\n        By default, the independent variable `y` is 'time', if it's present.\n\n        Parameters\n        ----------\n        y\n            The name of the parameter to plot on the y-axis.\n            Can also be a function `Curve` -&gt; float, or a `tuple(name, function)`,\n            Or a `tuple(name, array)`\n\n        x\n            The name of the parameter to plot on the x-axis, or alternative type as described for\n            `y`. If not supplied, defaults to `time` if it's present in the curve metadata,\n            or index otherwise.\n\n        label_axes\n            If true, set x and y labels. Defaults to true if a new axes is created.\n\n        label\n            Name to label the plot with, for use in matplotlib legend. Defaults to the name\n            of the `y` parameter.\n\n        ax\n            The matplotlib axes to plot in. Defaults to the current axes.\n\n        **kwargs\n            Remaining kwargs are passed to `matplotlib.pyplot.plot`\n\n        \"\"\"\n        if ax is None:\n            ax = plt.gca()\n            if label_axes is None:\n                label_axes = True\n\n        yname, ydata = self.get_named_data(y)\n\n        if x is None:\n            keys = self.keys(mode=\"union\")\n            if \"time\" in keys:\n                x = \"time\"\n            elif \"idx\" in keys:\n                x = \"idx\"\n            else:\n                x = (\"idx\", arange(self.n))\n\n        xname, xdata = self.get_named_data(x)\n\n        if label_axes:\n            ax.set_xlabel(xname)\n            ax.set_ylabel(yname)\n\n        if label and isinstance(label, bool):\n            label = yname\n\n        ax.plot(xdata, ydata, label=label, **kwargs)\n\n    def _subplots_builder(\n        self,\n        n_rows: int | None = 1,\n        n_cols: int | None = None,\n        share_xy=True,\n        figsize: tuple[float, float] = (15, 5),\n        idx: str = \"idx\",\n        axs: Sequence[Axes] | None = None,\n    ) -&gt; _SubplotsBuilder:\n        curves = Curves(list(self.iter_curves(idx=idx)))\n        if axs is None:\n            return _SubplotsBuilder.from_dims(\n                curves=curves,\n                nr=n_rows,\n                nc=n_cols,\n                sharex=share_xy,\n                sharey=share_xy,\n                figsize=figsize,\n            )\n\n        return _SubplotsBuilder.from_axs(curves=curves, axs=axs)\n\n    def subplots(\n        self,\n        n_rows: int | None = 1,\n        n_cols: int | None = None,\n        axis: str | None = \"scaled\",\n        show_axes=False,\n        plot_fn: Callable[[Curve], None] | None = None,\n        subtitle: str | Callable[[Curve], str] | None = None,\n        share_xy=True,\n        figsize: tuple[float, float] = (15, 5),\n        idx: str = \"idx\",\n        axs: Sequence[Axes] | None = None,\n        hide_unused: bool = True,\n    ):\n        \"\"\"Plot each curve in the sequence in a different subplot\n\n        Parameters\n        ----------\n        figsize\n            The size of the overall superfigure.\n\n        n_rows\n            Number of rows.\n\n        n_cols\n            Number of columns. By default, `n_cols` = ceil(self.n / n_rows)`. If `n_cols` is specified, and\n            `n_rows` * `n_cols` &lt; `self.n`, the curve sequence is automatically subsampled.\n\n        axis\n            Argument to `plt.axis`. By default this is 'equal' (i.e., make circles circular).\n\n        show_axes\n            Whether to show each subplot axes, i.e. border and x/y ticks, etc.\n\n        plot_fn\n            By default this just dispatches to `Curve.plot_edges(directed=False)`.\n\n        subtitle\n            A convenience argument to put a title over each subplot. If `subtitle` is a string,\n            a title is constructed from the corresponding curve metadata. Otherwise, `subtitle`\n            should be a function that accepts a curve and returns a string.\n\n        share_xy\n            Whether each subplot should share x/y limits.\n\n        idx\n            The index of the curve in this collection is stored in the curve metadata property\n            with this name.\n\n        axs\n            Array of matplotlib axes to use for subplots. If supplied, `n_rows` and `n_cols`\n            are ignored and determined by the shape of this array.\n\n        hide_unused\n            If n_axs &gt; n_plots, hide the unused axes.\n\n        Returns\n        -------\n        axes :\n            `(n_rows, n_cols)` array of `matplotlib.axes.Axes` objects\n\n        \"\"\"\n        if not plot_fn:\n\n            def plot_fn(c: Curve):\n                c.plot_edges(directed=False)\n\n        if isinstance(subtitle, str):\n            _key = subtitle\n\n            def subtitle(c: Curve) -&gt; str:\n                return f\"{_key} = {c[_key]}\"\n\n        b = self._subplots_builder(\n            n_rows=n_rows,\n            n_cols=n_cols,\n            share_xy=share_xy,\n            figsize=figsize,\n            idx=idx,\n            axs=axs,\n        )\n        if hide_unused and b.n_axs &gt; b.n_plots:\n            # Hide unused axes if there's e.g. 3x3 axes but only 8 curves to plot\n            for i in range(b.n_plots, b.n_axs):\n                b.get_ax(i).axis(\"off\")\n\n        for i in range(b.n_plots):\n            b.axis_subplot(i=i, plot_fn=plot_fn, subtitle=subtitle, axis=axis, show_axes=show_axes)\n\n        if b.fig is not None:  # If we created the figure\n            b.fig.tight_layout()\n\n        return b.axs\n\n    def superimposed(\n        self,\n        ax: Axes | None = None,\n        plot_fn: Callable[[Curve], Any] | None = None,\n        color: Metadata | None = None,\n        clim: tuple[float, float] | None = None,\n        idx: str = \"idx\",\n    ) -&gt; list[Any]:\n        \"\"\"Plot every curve in the same axes\n\n        Parameters\n        ----------\n        ax\n            Matlplotlib axes to plot in. Default current axes.\n\n        plot_fn\n            Function `Curve -&gt; matplotlib_object` to plot the curve.\n            By default, this dispatches to `curve.plot`\n\n        color\n            The name of a curve metadata parameter to color by. If `plot_fn` is supplied,\n            this is ignored.\n\n        clim\n            Range to scale color data to.\n\n        idx\n            The index of the curve in this collection is stored in this curve's metadata.\n\n        Returns\n        -------\n        :\n            List of objects returned by `plot_fn`.\n        \"\"\"\n\n        ax = _get_ax(ax)\n\n        if not plot_fn:\n            if color is not None:\n                cmap = plt.get_cmap(\"viridis\")\n                _cname, cdata = self.get_named_data(color)\n                cnorm = plt.Normalize(*clim) if clim else plt.Normalize()\n                cdata = cnorm(cdata)\n\n                def plot_fn(c: Curve) -&gt; Line2D:\n                    return c.plot(color=cmap(cdata[c[idx]]), ax=ax)\n            else:\n\n                def plot_fn(c: Curve) -&gt; Line2D:\n                    return c.plot(ax=ax)\n\n        out = []\n\n        for curve in self.iter_curves(idx=idx):\n            out.append(plot_fn(curve))\n\n        return out\n\n    def _animation_frames(self) -&gt; Iterator[int]:\n        i, step, n = 0, 1, self.n\n        while True:\n            yield i\n            if (i, step) == (n - 1, 1):\n                i, step = n - 2, -1\n            elif (i, step) == (0, -1):\n                i, step = 1, 1\n            else:\n                i += step\n\n    def _animate(\n        self,\n        frames: Iterable[int] | Callable[[], int] | None = None,\n        **kwargs,\n    ):\n        from matplotlib import animation\n\n        kwargs.setdefault(\"save_count\", 2 * self.n + 1)\n        frames = frames or self._animation_frames()\n\n        fig, ax = plt.subplots()\n        line = self[0].plot(ax=ax)\n\n        for c in self:\n            ax.dataLim.update_from_data_xy(c.points)\n\n        ax.axis(\"equal\")\n        ax.autoscale_view()\n\n        def update(frame):\n            curve = self[frame]\n            x, y = curve.closed_points.T\n            line.set_xdata(x)\n            line.set_ydata(y)\n            return line\n\n        # noinspection PyTypeChecker\n        return animation.FuncAnimation(\n            fig=fig,\n            func=update,\n            frames=frames,  # type: ignore [arg-type]\n            interval=30,\n            **kwargs,\n        )\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.curves","title":"<code>curves: list[Curve] = []</code>  <code>instance-attribute</code>","text":"<p>The <code>Curve</code>s contained in this <code>Curves</code></p>"},{"location":"api/curves/#curvey.curves.Curves.n","title":"<code>n: int</code>  <code>property</code>","text":"<p>Number of curves in the sequence</p>"},{"location":"api/curves/#curvey.curves.Curves.__add__","title":"<code>__add__(other: Curves | list[Curve]) -&gt; Curves</code>","text":"<p>Concatenate two <code>Curves</code> to form a new sequence</p> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def __add__(self, other: Curves | list[Curve]) -&gt; Curves:\n    \"\"\"Concatenate two `Curves` to form a new sequence\"\"\"\n    if isinstance(other, Curves):\n        return Curves(self.curves + other.curves)\n\n    # Just hope this raises a reasonable error if it fails\n    return Curves(self.curves + other)\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.__getitem__","title":"<code>__getitem__(idx: str | int | slice | ArrayLike | collections.abc.Callable) -&gt; Curve | Curves | ndarray</code>","text":"<p>Convenience method to index the sequence</p> <p><code>Curves[int]</code> returns the curve stored at that index. <code>Curves[str]</code> returns a <code>ndarray</code> of <code>n</code> metadata values. <code>Curves[fn]</code> for <code>fn: Callable[[Curve], Any]</code> returns a <code>ndarray</code> of the values of that function called on the <code>n</code> curves in the sequence.</p> <p>Otherwise, <code>Curves[idx]</code> returns a new <code>Curves</code> for that index, obeying list slicing and numpy smart indexing behavior. E.g. <code>sequence[::3]</code> returns a new curve sequence for every third curve in the original sequence.</p> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def __getitem__(\n    self,\n    idx: str | int | slice | ArrayLike | collections.abc.Callable,\n) -&gt; Curve | Curves | ndarray:\n    \"\"\"Convenience method to index the sequence\n\n    `Curves[int]` returns the curve stored at that index.\n    `Curves[str]` returns a `ndarray` of `n` metadata values.\n    `Curves[fn]` for `fn: Callable[[Curve], Any]` returns a `ndarray` of the values\n    of that function called on the `n` curves in the sequence.\n\n    Otherwise, `Curves[idx]` returns a new `Curves` for that index,\n    obeying list slicing and numpy smart indexing behavior. E.g. `sequence[::3]` returns\n    a new curve sequence for every third curve in the original sequence.\n\n    \"\"\"\n    if isinstance(idx, str):\n        return self.get_data(idx)\n\n    if callable(idx):\n        return self.get_data(idx)\n\n    if isinstance(idx, (int, np.integer)):\n        # Recast to int here so indexing with np.int works as expected\n        return self.curves[int(idx)]\n\n    # noinspection PyUnresolvedReferences\n    idx = arange(self.n)[idx]  # type: ignore [index]\n    all_curves = self.curves\n    curves = [all_curves[int(i)] for i in idx]\n    return Curves(curves=curves)\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.__iter__","title":"<code>__iter__() -&gt; Iterator[Curve]</code>","text":"<p>Iterate over curves in the sequence</p> <p>The index of the curve is stored in the 'idx' metadata parameter. Use <code>Curves.iter_curves</code> to supply a custom name for index, if necessary.</p> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Curve]:\n    \"\"\"Iterate over curves in the sequence\n\n    The index of the curve is stored in the 'idx' metadata parameter.\n    Use `Curves.iter_curves` to supply a custom name for index, if necessary.\n    \"\"\"\n    return self.iter_curves()\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Number of curves in the sequence</p> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Number of curves in the sequence\"\"\"\n    return len(self.curves)\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.append","title":"<code>append(curve: Curve)</code>","text":"<p>Add a curve to the end of the sequence</p> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def append(self, curve: Curve):\n    \"\"\"Add a curve to the end of the sequence\"\"\"\n    self.curves.append(curve)\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.get_data","title":"<code>get_data(data: BareMetadata, default: Any = nan, allow_default: bool = True, allow_property: bool = True) -&gt; ndarray</code>","text":"<p>Concatenate curve metadata into an array of length <code>n</code></p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>BareMetadata</code> <p>One of:</p> <ul> <li>Name of the property stored in curve metadata</li> <li>Name of a <code>Curve</code> attribute, if <code>allow_property</code> is true</li> <li>A function <code>Curve -&gt; value</code></li> <li>An length <code>n</code> array or list of values</li> </ul> required <code>allow_property</code> <code>bool</code> <p>If true, <code>data</code> may be the name of a Curve attribute, such as 'area' or 'length'</p> <code>True</code> <code>allow_default</code> <code>bool</code> <p>If true, and the requested data is only available on a subset of curves, return <code>default</code> for those curves.</p> <code>True</code> <code>default</code> <code>Any</code> <p>The default value if named parameter <code>data</code> is not present in a curve's metadata. If not supplied, all curves in the collection must have that metadata parameter, otherwise a <code>KeyError</code> is raised.</p> <code>nan</code> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def get_data(\n    self,\n    data: BareMetadata,\n    default: Any = nan,\n    allow_default: bool = True,\n    allow_property: bool = True,\n) -&gt; ndarray:\n    \"\"\"Concatenate curve metadata into an array of length `n`\n\n    Parameters\n    ----------\n    data\n        One of:\n\n        - Name of the property stored in curve metadata\n        - Name of a `Curve` attribute, if `allow_property` is true\n        - A function `Curve -&gt; value`\n        - An length `n` array or list of values\n\n    allow_property\n        If true, `data` may be the name of a Curve attribute, such as 'area' or 'length'\n\n    allow_default\n        If true, and the requested data is only available on a subset of curves, return\n        `default` for those curves.\n\n    default\n        The default value if named parameter `data` is not present in a curve's metadata.\n        If not supplied, all curves in the collection must have that metadata parameter,\n        otherwise a `KeyError` is raised.\n\n    \"\"\"\n    if isinstance(data, str):\n        if data in self.keys(\"union\"):\n            if allow_default:\n                return array([c.data.get(data, default) for c in self])\n\n            if data in self.keys(\"intersection\"):\n                msg = f\"Metadata '{data}' is only present on some curves\"\n                raise KeyError(msg)\n\n            return array([c[data] for c in self])\n\n        if hasattr(Curve, data):\n            if allow_property:\n                return array([getattr(c, data) for c in self])\n\n            msg = (\n                f\"Metadata '{data}' not found. \"\n                \"it's a Curve property but `allow_property` is False\"\n            )\n            raise KeyError(msg)\n\n        msg = f\"Metadata '{data}' not found\"\n        raise KeyError(msg)\n\n    if callable(data):\n        return array([data(c) for c in self])\n\n    if isinstance(data, Sequence):\n        if (n := len(data)) != self.n:\n            msg = f\"Expected a sequence of length self.n = {self.n}, got {n}\"\n            raise ValueError(msg)\n        return asarray(data)\n\n    msg = f\"Unrecognized data type {type(data)}\"  # type: ignore [unreachable]\n    raise TypeError(msg)\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.get_named_data","title":"<code>get_named_data(data: BareMetadata | NamedMetadata, **kwargs) -&gt; tuple[str, ndarray]</code>","text":"<p>Get curve metadata (name, values) pairs</p> <p>If <code>data</code> is just a name, return (name, values). If <code>data</code> is something that can reasonably interpreted as <code>values</code>, try to figure out a reasonable name for them.</p> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def get_named_data(self, data: BareMetadata | NamedMetadata, **kwargs) -&gt; tuple[str, ndarray]:\n    \"\"\"Get curve metadata (name, values) pairs\n\n    If `data` is just a name, return (name, values).\n    If `data` is something that can reasonably interpreted as `values`,\n    try to figure out a reasonable name for them.\n    \"\"\"\n    if isinstance(data, str):\n        return data, self.get_data(data, **kwargs)\n\n    if isinstance(data, tuple) and len(data) == 2:\n        name = data[0]\n        if not isinstance(name, str):\n            msg = f\"Expected metadata name to be str, got {name}\"\n            raise TypeError(msg)\n        return name, self.get_data(data[1], **kwargs)\n\n    if callable(data):\n        name = data.__name__ if hasattr(data, \"__name__\") else str(data)\n        return name, self.get_data(data, **kwargs)\n\n    name = type(data).__name__\n    return name, self.get_data(data, **kwargs)\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.iter_curves","title":"<code>iter_curves(idx: str = 'idx') -&gt; Iterator[Curve]</code>","text":"<p>Iterate over curves in the sequence</p> <p>The index of the curve is stored in the <code>idx</code> metadata parameter. This might be useful for tracking the original index in a subset.</p> <pre><code>from curvey import Curves\n\norig = Curves(Curve.circle(3) for _ in range(6))\nevery_other = Curves(orig.iter_curves('orig_idx'))[::2]\nevery_other['orig_idx']\n</code></pre> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def iter_curves(self, idx: str = \"idx\") -&gt; Iterator[Curve]:\n    \"\"\"Iterate over curves in the sequence\n\n    The index of the curve is stored in the `idx` metadata parameter. This might be useful for\n    tracking the original index in a subset.\n\n    ```python\n    from curvey import Curves\n\n    orig = Curves(Curve.circle(3) for _ in range(6))\n    every_other = Curves(orig.iter_curves('orig_idx'))[::2]\n    every_other['orig_idx']\n    ```\n    \"\"\"\n    for i, c in enumerate(self.curves):\n        yield c.with_data(**{idx: i})\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.keys","title":"<code>keys(mode: Literal['intersection', 'union'] = 'union') -&gt; set[str]</code>","text":"<p>Unique curve metadata parameter names</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>Literal['intersection', 'union']</code> <p>If 'union', return keys that are present on any <code>Curve</code> in the <code>Curves</code>. If 'intersection', return only keys that are present on all <code>Curve</code>s in the <code>Curves</code>.</p> <code>'union'</code> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def keys(self, mode: Literal[\"intersection\", \"union\"] = \"union\") -&gt; set[str]:\n    \"\"\"Unique curve metadata parameter names\n\n    Parameters\n    ----------\n    mode\n        If 'union', return keys that are present on any `Curve` in the `Curves`.\n        If 'intersection', return only keys that are present on all `Curve`s in the `Curves`.\n    \"\"\"\n    if self.n == 0:\n        return set()\n\n    keys = (set(c.data.keys()) for c in self)\n    if mode == \"intersection\":\n        return set.intersection(*keys)\n\n    if mode == \"union\":\n        return set.union(*keys)\n\n    raise ValueError(mode)\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.plot","title":"<code>plot(y: Metadata, x: Metadata | None = None, ax: Axes | None = None, label_axes: bool | None = None, label: str | bool | None = True, **kwargs)</code>","text":"<p>Plot metadata values against each other.</p> <p>By default, the independent variable <code>y</code> is 'time', if it's present.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>Metadata</code> <p>The name of the parameter to plot on the y-axis. Can also be a function <code>Curve</code> -&gt; float, or a <code>tuple(name, function)</code>, Or a <code>tuple(name, array)</code></p> required <code>x</code> <code>Metadata | None</code> <p>The name of the parameter to plot on the x-axis, or alternative type as described for <code>y</code>. If not supplied, defaults to <code>time</code> if it's present in the curve metadata, or index otherwise.</p> <code>None</code> <code>label_axes</code> <code>bool | None</code> <p>If true, set x and y labels. Defaults to true if a new axes is created.</p> <code>None</code> <code>label</code> <code>str | bool | None</code> <p>Name to label the plot with, for use in matplotlib legend. Defaults to the name of the <code>y</code> parameter.</p> <code>True</code> <code>ax</code> <code>Axes | None</code> <p>The matplotlib axes to plot in. Defaults to the current axes.</p> <code>None</code> <code>**kwargs</code> <p>Remaining kwargs are passed to <code>matplotlib.pyplot.plot</code></p> <code>{}</code> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def plot(\n    self,\n    y: Metadata,\n    x: Metadata | None = None,\n    ax: Axes | None = None,\n    label_axes: bool | None = None,\n    label: str | bool | None = True,\n    **kwargs,\n):\n    \"\"\"Plot metadata values against each other.\n\n    By default, the independent variable `y` is 'time', if it's present.\n\n    Parameters\n    ----------\n    y\n        The name of the parameter to plot on the y-axis.\n        Can also be a function `Curve` -&gt; float, or a `tuple(name, function)`,\n        Or a `tuple(name, array)`\n\n    x\n        The name of the parameter to plot on the x-axis, or alternative type as described for\n        `y`. If not supplied, defaults to `time` if it's present in the curve metadata,\n        or index otherwise.\n\n    label_axes\n        If true, set x and y labels. Defaults to true if a new axes is created.\n\n    label\n        Name to label the plot with, for use in matplotlib legend. Defaults to the name\n        of the `y` parameter.\n\n    ax\n        The matplotlib axes to plot in. Defaults to the current axes.\n\n    **kwargs\n        Remaining kwargs are passed to `matplotlib.pyplot.plot`\n\n    \"\"\"\n    if ax is None:\n        ax = plt.gca()\n        if label_axes is None:\n            label_axes = True\n\n    yname, ydata = self.get_named_data(y)\n\n    if x is None:\n        keys = self.keys(mode=\"union\")\n        if \"time\" in keys:\n            x = \"time\"\n        elif \"idx\" in keys:\n            x = \"idx\"\n        else:\n            x = (\"idx\", arange(self.n))\n\n    xname, xdata = self.get_named_data(x)\n\n    if label_axes:\n        ax.set_xlabel(xname)\n        ax.set_ylabel(yname)\n\n    if label and isinstance(label, bool):\n        label = yname\n\n    ax.plot(xdata, ydata, label=label, **kwargs)\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.subplots","title":"<code>subplots(n_rows: int | None = 1, n_cols: int | None = None, axis: str | None = 'scaled', show_axes=False, plot_fn: Callable[[Curve], None] | None = None, subtitle: str | Callable[[Curve], str] | None = None, share_xy=True, figsize: tuple[float, float] = (15, 5), idx: str = 'idx', axs: Sequence[Axes] | None = None, hide_unused: bool = True)</code>","text":"<p>Plot each curve in the sequence in a different subplot</p> <p>Parameters:</p> Name Type Description Default <code>figsize</code> <code>tuple[float, float]</code> <p>The size of the overall superfigure.</p> <code>(15, 5)</code> <code>n_rows</code> <code>int | None</code> <p>Number of rows.</p> <code>1</code> <code>n_cols</code> <code>int | None</code> <p>Number of columns. By default, <code>n_cols</code> = ceil(self.n / n_rows)<code>. If</code>n_cols<code>is specified, and</code>n_rows<code>*</code>n_cols<code>&lt;</code>self.n`, the curve sequence is automatically subsampled.</p> <code>None</code> <code>axis</code> <code>str | None</code> <p>Argument to <code>plt.axis</code>. By default this is 'equal' (i.e., make circles circular).</p> <code>'scaled'</code> <code>show_axes</code> <p>Whether to show each subplot axes, i.e. border and x/y ticks, etc.</p> <code>False</code> <code>plot_fn</code> <code>Callable[[Curve], None] | None</code> <p>By default this just dispatches to <code>Curve.plot_edges(directed=False)</code>.</p> <code>None</code> <code>subtitle</code> <code>str | Callable[[Curve], str] | None</code> <p>A convenience argument to put a title over each subplot. If <code>subtitle</code> is a string, a title is constructed from the corresponding curve metadata. Otherwise, <code>subtitle</code> should be a function that accepts a curve and returns a string.</p> <code>None</code> <code>share_xy</code> <p>Whether each subplot should share x/y limits.</p> <code>True</code> <code>idx</code> <code>str</code> <p>The index of the curve in this collection is stored in the curve metadata property with this name.</p> <code>'idx'</code> <code>axs</code> <code>Sequence[Axes] | None</code> <p>Array of matplotlib axes to use for subplots. If supplied, <code>n_rows</code> and <code>n_cols</code> are ignored and determined by the shape of this array.</p> <code>None</code> <code>hide_unused</code> <code>bool</code> <p>If n_axs &gt; n_plots, hide the unused axes.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>axes</code> <p><code>(n_rows, n_cols)</code> array of <code>matplotlib.axes.Axes</code> objects</p> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def subplots(\n    self,\n    n_rows: int | None = 1,\n    n_cols: int | None = None,\n    axis: str | None = \"scaled\",\n    show_axes=False,\n    plot_fn: Callable[[Curve], None] | None = None,\n    subtitle: str | Callable[[Curve], str] | None = None,\n    share_xy=True,\n    figsize: tuple[float, float] = (15, 5),\n    idx: str = \"idx\",\n    axs: Sequence[Axes] | None = None,\n    hide_unused: bool = True,\n):\n    \"\"\"Plot each curve in the sequence in a different subplot\n\n    Parameters\n    ----------\n    figsize\n        The size of the overall superfigure.\n\n    n_rows\n        Number of rows.\n\n    n_cols\n        Number of columns. By default, `n_cols` = ceil(self.n / n_rows)`. If `n_cols` is specified, and\n        `n_rows` * `n_cols` &lt; `self.n`, the curve sequence is automatically subsampled.\n\n    axis\n        Argument to `plt.axis`. By default this is 'equal' (i.e., make circles circular).\n\n    show_axes\n        Whether to show each subplot axes, i.e. border and x/y ticks, etc.\n\n    plot_fn\n        By default this just dispatches to `Curve.plot_edges(directed=False)`.\n\n    subtitle\n        A convenience argument to put a title over each subplot. If `subtitle` is a string,\n        a title is constructed from the corresponding curve metadata. Otherwise, `subtitle`\n        should be a function that accepts a curve and returns a string.\n\n    share_xy\n        Whether each subplot should share x/y limits.\n\n    idx\n        The index of the curve in this collection is stored in the curve metadata property\n        with this name.\n\n    axs\n        Array of matplotlib axes to use for subplots. If supplied, `n_rows` and `n_cols`\n        are ignored and determined by the shape of this array.\n\n    hide_unused\n        If n_axs &gt; n_plots, hide the unused axes.\n\n    Returns\n    -------\n    axes :\n        `(n_rows, n_cols)` array of `matplotlib.axes.Axes` objects\n\n    \"\"\"\n    if not plot_fn:\n\n        def plot_fn(c: Curve):\n            c.plot_edges(directed=False)\n\n    if isinstance(subtitle, str):\n        _key = subtitle\n\n        def subtitle(c: Curve) -&gt; str:\n            return f\"{_key} = {c[_key]}\"\n\n    b = self._subplots_builder(\n        n_rows=n_rows,\n        n_cols=n_cols,\n        share_xy=share_xy,\n        figsize=figsize,\n        idx=idx,\n        axs=axs,\n    )\n    if hide_unused and b.n_axs &gt; b.n_plots:\n        # Hide unused axes if there's e.g. 3x3 axes but only 8 curves to plot\n        for i in range(b.n_plots, b.n_axs):\n            b.get_ax(i).axis(\"off\")\n\n    for i in range(b.n_plots):\n        b.axis_subplot(i=i, plot_fn=plot_fn, subtitle=subtitle, axis=axis, show_axes=show_axes)\n\n    if b.fig is not None:  # If we created the figure\n        b.fig.tight_layout()\n\n    return b.axs\n</code></pre>"},{"location":"api/curves/#curvey.curves.Curves.superimposed","title":"<code>superimposed(ax: Axes | None = None, plot_fn: Callable[[Curve], Any] | None = None, color: Metadata | None = None, clim: tuple[float, float] | None = None, idx: str = 'idx') -&gt; list[Any]</code>","text":"<p>Plot every curve in the same axes</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>Axes | None</code> <p>Matlplotlib axes to plot in. Default current axes.</p> <code>None</code> <code>plot_fn</code> <code>Callable[[Curve], Any] | None</code> <p>Function <code>Curve -&gt; matplotlib_object</code> to plot the curve. By default, this dispatches to <code>curve.plot</code></p> <code>None</code> <code>color</code> <code>Metadata | None</code> <p>The name of a curve metadata parameter to color by. If <code>plot_fn</code> is supplied, this is ignored.</p> <code>None</code> <code>clim</code> <code>tuple[float, float] | None</code> <p>Range to scale color data to.</p> <code>None</code> <code>idx</code> <code>str</code> <p>The index of the curve in this collection is stored in this curve's metadata.</p> <code>'idx'</code> <p>Returns:</p> Type Description <code>list[Any]</code> <p>List of objects returned by <code>plot_fn</code>.</p> Source code in <code>src\\curvey\\curves.py</code> <pre><code>def superimposed(\n    self,\n    ax: Axes | None = None,\n    plot_fn: Callable[[Curve], Any] | None = None,\n    color: Metadata | None = None,\n    clim: tuple[float, float] | None = None,\n    idx: str = \"idx\",\n) -&gt; list[Any]:\n    \"\"\"Plot every curve in the same axes\n\n    Parameters\n    ----------\n    ax\n        Matlplotlib axes to plot in. Default current axes.\n\n    plot_fn\n        Function `Curve -&gt; matplotlib_object` to plot the curve.\n        By default, this dispatches to `curve.plot`\n\n    color\n        The name of a curve metadata parameter to color by. If `plot_fn` is supplied,\n        this is ignored.\n\n    clim\n        Range to scale color data to.\n\n    idx\n        The index of the curve in this collection is stored in this curve's metadata.\n\n    Returns\n    -------\n    :\n        List of objects returned by `plot_fn`.\n    \"\"\"\n\n    ax = _get_ax(ax)\n\n    if not plot_fn:\n        if color is not None:\n            cmap = plt.get_cmap(\"viridis\")\n            _cname, cdata = self.get_named_data(color)\n            cnorm = plt.Normalize(*clim) if clim else plt.Normalize()\n            cdata = cnorm(cdata)\n\n            def plot_fn(c: Curve) -&gt; Line2D:\n                return c.plot(color=cmap(cdata[c[idx]]), ax=ax)\n        else:\n\n            def plot_fn(c: Curve) -&gt; Line2D:\n                return c.plot(ax=ax)\n\n    out = []\n\n    for curve in self.iter_curves(idx=idx):\n        out.append(plot_fn(curve))\n\n    return out\n</code></pre>"},{"location":"api/flow/","title":"curvey.flow","text":""},{"location":"api/flow/#curvey.flow","title":"<code>flow</code>","text":"<p>Definitions of flow infrastructure and implementations of some common flows</p>"},{"location":"api/flow/#curvey.flow.AbstractCurvatureFlow","title":"<code>AbstractCurvatureFlow</code>","text":"<p>             Bases: <code>AbstractFlow[TData]</code>, <code>Generic[TData]</code></p> <p>Abstract superclass for curvature flows</p> <p>Parameters:</p> Name Type Description Default <code>curvature_fn</code> <code>Callable[[Curve], ndarray] | None</code> <p>A function <code>Curve -&gt; ndarray</code> that returns the signed curvature values at each vertex.</p> <code>None</code> <code>rescale</code> <code>Literal['length', 'area'] | None</code> <p>If this is 'length' or 'area', the recurve length/area is rescaled to the original's length or area, preventing the usual curvature flow shrinkage.</p> <code>None</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>class AbstractCurvatureFlow(AbstractFlow[TData], Generic[TData]):\n    \"\"\"Abstract superclass for curvature flows\n\n    Parameters\n    ----------\n    curvature_fn\n        A function `Curve -&gt; ndarray` that returns the signed curvature values at each vertex.\n\n    rescale\n        If this is 'length' or 'area', the recurve length/area is rescaled to the original's\n        length or area, preventing the usual curvature flow shrinkage.\n    \"\"\"\n\n    def __init__(\n        self,\n        curvature_fn: Callable[[Curve], ndarray] | None = None,\n        rescale: Literal[\"length\", \"area\"] | None = None,\n    ):\n        super().__init__()\n        self.curvature_fn = curvature_fn or self.default_curvature_fn\n        self.rescale = rescale\n\n    @abstractmethod\n    def step(self, curve: Curve, timestep: float, solver: Solver[TData]) -&gt; Curve: ...\n\n    @abstractmethod\n    def solver(self, initial: Curve, **kwargs) -&gt; Solver[TData]: ...\n\n    def _postprocess(self, curve: Curve, solver: Solver[TData]) -&gt; Curve:\n        if self.rescale == \"area\":\n            curve = curve.scale(sqrt(solver.initial.area / curve.area))\n        elif self.rescale == \"length\":\n            curve = curve.scale(solver.initial.length / curve.length)\n\n        return curve\n\n    @staticmethod\n    def default_curvature_fn(curve: Curve) -&gt; ndarray:\n        \"\"\"Simply return the value of the `Curve.curvature` property\"\"\"\n        return curve.curvature\n</code></pre>"},{"location":"api/flow/#curvey.flow.AbstractCurvatureFlow.default_curvature_fn","title":"<code>default_curvature_fn(curve: Curve) -&gt; ndarray</code>  <code>staticmethod</code>","text":"<p>Simply return the value of the <code>Curve.curvature</code> property</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@staticmethod\ndef default_curvature_fn(curve: Curve) -&gt; ndarray:\n    \"\"\"Simply return the value of the `Curve.curvature` property\"\"\"\n    return curve.curvature\n</code></pre>"},{"location":"api/flow/#curvey.flow.AbstractCurvatureFlow.poststep","title":"<code>poststep(curve: Curve, solver: Solver[TData]) -&gt; Curve</code>","text":"<p>Called after stepping the curve, but before logging it</p> <p>This is called after attaching additional curve metadata requested by curve loggers.</p> <p>Subclasses can raise <code>RetryStep</code> or <code>StopEarly</code> here if necessary, or further process the curve.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def poststep(self, curve: Curve, solver: Solver[TData]) -&gt; Curve:  # noqa: ARG002\n    \"\"\"Called after stepping the curve, but before logging it\n\n    This is called after attaching additional curve metadata requested by curve loggers.\n\n    Subclasses can raise `RetryStep` or `StopEarly` here if necessary, or further process the\n    curve.\n    \"\"\"\n    return curve\n</code></pre>"},{"location":"api/flow/#curvey.flow.AbstractFlow","title":"<code>AbstractFlow</code>","text":"<p>             Bases: <code>Generic[TData]</code></p> <p>Abstract superclass for curve flow</p> <p>The basic contract is that <code>Flow</code> objects don't maintain any state specific to the solution of a flow. All state is stored in the curve metadata or in the <code>Solver.data</code> class, which is generic over the <code>TData</code> type.</p> <p>Two methods for subclasses to implement: <code>step</code>, which steps the curve by the supplied timestep, and <code>solver</code>, which constructs the auxillary <code>Solver</code> object with flow-specific <code>data: TData</code>.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>class AbstractFlow(Generic[TData]):\n    \"\"\"Abstract superclass for curve flow\n\n    The basic contract is that `Flow` objects don't maintain any state specific\n    to the solution of a flow. All state is stored in the curve metadata\n    or in the `Solver.data` class, which is generic over the `TData` type.\n\n    Two methods for subclasses to implement: `step`, which steps the curve by the\n    supplied timestep, and `solver`, which constructs the auxillary `Solver` object with\n    flow-specific `data: TData`.\n\n    \"\"\"\n\n    @abstractmethod\n    def solver(self, initial: Curve, **kwargs) -&gt; Solver[TData]:\n        \"\"\"Construct a `Solver` to solve curve flow over time\n\n        **kwargs are all passed to the `Solver` constructor.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def step(self, curve: Curve, timestep: float, solver: Solver[TData]) -&gt; Curve:\n        \"\"\"Step the curve by `timestep`\"\"\"\n        ...\n\n    def poststep(self, curve: Curve, solver: Solver[TData]) -&gt; Curve:  # noqa: ARG002\n        \"\"\"Called after stepping the curve, but before logging it\n\n        This is called after attaching additional curve metadata requested by curve loggers.\n\n        Subclasses can raise `RetryStep` or `StopEarly` here if necessary, or further process the\n        curve.\n        \"\"\"\n        return curve\n</code></pre>"},{"location":"api/flow/#curvey.flow.AbstractFlow.poststep","title":"<code>poststep(curve: Curve, solver: Solver[TData]) -&gt; Curve</code>","text":"<p>Called after stepping the curve, but before logging it</p> <p>This is called after attaching additional curve metadata requested by curve loggers.</p> <p>Subclasses can raise <code>RetryStep</code> or <code>StopEarly</code> here if necessary, or further process the curve.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def poststep(self, curve: Curve, solver: Solver[TData]) -&gt; Curve:  # noqa: ARG002\n    \"\"\"Called after stepping the curve, but before logging it\n\n    This is called after attaching additional curve metadata requested by curve loggers.\n\n    Subclasses can raise `RetryStep` or `StopEarly` here if necessary, or further process the\n    curve.\n    \"\"\"\n    return curve\n</code></pre>"},{"location":"api/flow/#curvey.flow.AbstractFlow.solver","title":"<code>solver(initial: Curve, **kwargs) -&gt; Solver[TData]</code>  <code>abstractmethod</code>","text":"<p>Construct a <code>Solver</code> to solve curve flow over time</p> <p>**kwargs are all passed to the <code>Solver</code> constructor.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@abstractmethod\ndef solver(self, initial: Curve, **kwargs) -&gt; Solver[TData]:\n    \"\"\"Construct a `Solver` to solve curve flow over time\n\n    **kwargs are all passed to the `Solver` constructor.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"api/flow/#curvey.flow.AbstractFlow.step","title":"<code>step(curve: Curve, timestep: float, solver: Solver[TData]) -&gt; Curve</code>  <code>abstractmethod</code>","text":"<p>Step the curve by <code>timestep</code></p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@abstractmethod\ndef step(self, curve: Curve, timestep: float, solver: Solver[TData]) -&gt; Curve:\n    \"\"\"Step the curve by `timestep`\"\"\"\n    ...\n</code></pre>"},{"location":"api/flow/#curvey.flow.CurveShorteningFlow","title":"<code>CurveShorteningFlow</code>","text":"<p>             Bases: <code>AbstractCurvatureFlow[_CsfData]</code></p> <p>Basic curve shortening flow</p> <p>At each iteration, vertices coordinates are moved by \\(\\Delta t \\kappa_i N_i\\), for timestep \\(\\Delta t\\) and vertex curvatures \\(\\kappa_i\\) and normal \\(N_i\\).</p> <p>Parameters:</p> Name Type Description Default <code>resample_mode</code> <code>InterpType | None</code> <p>Type of interpolation to use when resampling, one of ('linear', 'cubic', 'pchip').</p> <code>'cubic'</code> <code>**kwargs</code> <p>Remaining kwargs are passed to the <code>AbstractCurvatureFlow</code> constructor.</p> <code>{}</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>class CurveShorteningFlow(AbstractCurvatureFlow[_CsfData]):\n    r\"\"\"Basic curve shortening flow\n\n    At each iteration, vertices coordinates are moved by $\\Delta t \\kappa_i N_i$, for\n    timestep $\\Delta t$ and vertex curvatures $\\kappa_i$ and normal $N_i$.\n\n    Parameters\n    ----------\n    resample_mode\n        Type of interpolation to use when resampling, one of ('linear', 'cubic', 'pchip').\n\n    **kwargs\n        Remaining kwargs are passed to the `AbstractCurvatureFlow` constructor.\n    \"\"\"\n\n    def __init__(\n        self,\n        resample_mode: InterpType | None = \"cubic\",\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.resample_mode = resample_mode\n\n    def solver(self, initial: Curve, **kwargs) -&gt; Solver[_CsfData]:\n        \"\"\"Construct a `CurveShorteningFlow` `Solver`\n\n        **kwargs are all passed to the `Solver` constructor.\n        \"\"\"\n        data = _CsfData(orig_thresh=initial.edge_length.mean())\n        return Solver(flow=self, initial=initial, data=data, **kwargs)\n\n    def step(self, curve: Curve, timestep: float, solver: Solver[_CsfData]) -&gt; Curve:\n        curve = curve.translate(timestep * self.curvature_fn(curve)[:, newaxis] * curve.normal)\n        curve = super()._postprocess(curve=curve, solver=solver)\n\n        if self.resample_mode:\n            curve = curve.interpolate_thresh(\n                thresh=solver.data[\"orig_thresh\"],\n                typ=self.resample_mode,\n            )\n\n        return curve\n</code></pre>"},{"location":"api/flow/#curvey.flow.CurveShorteningFlow.default_curvature_fn","title":"<code>default_curvature_fn(curve: Curve) -&gt; ndarray</code>  <code>staticmethod</code>","text":"<p>Simply return the value of the <code>Curve.curvature</code> property</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@staticmethod\ndef default_curvature_fn(curve: Curve) -&gt; ndarray:\n    \"\"\"Simply return the value of the `Curve.curvature` property\"\"\"\n    return curve.curvature\n</code></pre>"},{"location":"api/flow/#curvey.flow.CurveShorteningFlow.poststep","title":"<code>poststep(curve: Curve, solver: Solver[TData]) -&gt; Curve</code>","text":"<p>Called after stepping the curve, but before logging it</p> <p>This is called after attaching additional curve metadata requested by curve loggers.</p> <p>Subclasses can raise <code>RetryStep</code> or <code>StopEarly</code> here if necessary, or further process the curve.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def poststep(self, curve: Curve, solver: Solver[TData]) -&gt; Curve:  # noqa: ARG002\n    \"\"\"Called after stepping the curve, but before logging it\n\n    This is called after attaching additional curve metadata requested by curve loggers.\n\n    Subclasses can raise `RetryStep` or `StopEarly` here if necessary, or further process the\n    curve.\n    \"\"\"\n    return curve\n</code></pre>"},{"location":"api/flow/#curvey.flow.CurveShorteningFlow.solver","title":"<code>solver(initial: Curve, **kwargs) -&gt; Solver[_CsfData]</code>","text":"<p>Construct a <code>CurveShorteningFlow</code> <code>Solver</code></p> <p>**kwargs are all passed to the <code>Solver</code> constructor.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def solver(self, initial: Curve, **kwargs) -&gt; Solver[_CsfData]:\n    \"\"\"Construct a `CurveShorteningFlow` `Solver`\n\n    **kwargs are all passed to the `Solver` constructor.\n    \"\"\"\n    data = _CsfData(orig_thresh=initial.edge_length.mean())\n    return Solver(flow=self, initial=initial, data=data, **kwargs)\n</code></pre>"},{"location":"api/flow/#curvey.flow.RetryStep","title":"<code>RetryStep</code>","text":"<p>             Bases: <code>Exception</code></p> <p>This can be raised in a custom <code>Solver.step_fn</code> to retry the current step</p> <p>Usually after adjusting the timestep or some other state.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>class RetryStep(Exception):\n    \"\"\"This can be raised in a custom `Solver.step_fn` to retry the current step\n\n    Usually after adjusting the timestep or some other state.\n    \"\"\"\n</code></pre>"},{"location":"api/flow/#curvey.flow.SingularityFreeMeanCurvatureFlow","title":"<code>SingularityFreeMeanCurvatureFlow</code>","text":"<p>             Bases: <code>AbstractCurvatureFlow</code></p> <p>Singularity free mean curvature flow</p> <p>As defined in</p> <p>Can Mean-Curvature Flow Be Made Non-Singular? Michael Kazhdan, Jake Solomon, and Mirela Ben-Chen. 2012.</p> <p>That paper suggests this shouldn't really be necessary in the planar curve case, as curves in the continuous case can't form singularities anyway, but it does seem to be much more numerically stable than the traditional approach, and doesn't require resampling the curve.</p> <p>See also the explanation in</p> <p>Mean Curvature Flow and Applications. Maria Eduarda Duarte and Leonardo Sacht. 2017.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>All kwargs passed to <code>AbstractCurvatureFlow</code> constructor.</p> <code>{}</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>class SingularityFreeMeanCurvatureFlow(AbstractCurvatureFlow):\n    \"\"\"Singularity free mean curvature flow\n\n    As defined in\n\n    [*Can Mean-Curvature Flow Be Made Non-Singular?* Michael Kazhdan, Jake Solomon, and Mirela Ben-Chen.\n    2012.](https://arxiv.org/abs/1203.6819)\n\n    That paper suggests this shouldn't really be necessary in the planar curve case, as curves in\n    the continuous case can't form singularities anyway, but it does seem to be much more\n    numerically stable than the traditional approach, and doesn't require resampling the curve.\n\n    See also the explanation in\n\n    [*Mean Curvature Flow and Applications*. Maria Eduarda Duarte and Leonardo Sacht. 2017.](\n    https://sibgrapi.sid.inpe.br/col/sid.inpe.br/sibgrapi/2017/09.04.18.39/doc/Mean%20Curvature%20Flow%20and%20Applications.pdf)\n\n    Parameters\n    ----------\n    **kwargs\n        All kwargs passed to `AbstractCurvatureFlow` constructor.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n\n    def solver(self, initial: Curve, **kwargs) -&gt; Solver[_SfmcfData]:\n        \"\"\"Construct a solver for this flow\n\n        All **kwargs are passed to the `Solver` constructor.\n        \"\"\"\n        stiffness = scipy.sparse.diags(-1 / initial.dual_edge_length) @ initial.laplacian\n        data = _SfmcfData(stiffness=stiffness)\n        return Solver(flow=self, initial=initial, data=data, **kwargs)\n\n    def step(self, curve: Curve, timestep: float, solver: Solver[_SfmcfData]) -&gt; Curve:\n        inv_mass = scipy.sparse.diags(1 / curve.dual_edge_length)  # The $D_t^-1$ matrix\n        stiffness = solver.data[\"stiffness\"]  # The stiffness $L_0$\n        # noinspection PyTypeChecker\n        pts = scipy.sparse.linalg.spsolve(inv_mass - timestep * stiffness, inv_mass @ curve.points)\n        curve = solver.initial.with_points(pts)\n        return super()._postprocess(curve=curve, solver=solver)\n</code></pre>"},{"location":"api/flow/#curvey.flow.SingularityFreeMeanCurvatureFlow.default_curvature_fn","title":"<code>default_curvature_fn(curve: Curve) -&gt; ndarray</code>  <code>staticmethod</code>","text":"<p>Simply return the value of the <code>Curve.curvature</code> property</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@staticmethod\ndef default_curvature_fn(curve: Curve) -&gt; ndarray:\n    \"\"\"Simply return the value of the `Curve.curvature` property\"\"\"\n    return curve.curvature\n</code></pre>"},{"location":"api/flow/#curvey.flow.SingularityFreeMeanCurvatureFlow.poststep","title":"<code>poststep(curve: Curve, solver: Solver[TData]) -&gt; Curve</code>","text":"<p>Called after stepping the curve, but before logging it</p> <p>This is called after attaching additional curve metadata requested by curve loggers.</p> <p>Subclasses can raise <code>RetryStep</code> or <code>StopEarly</code> here if necessary, or further process the curve.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def poststep(self, curve: Curve, solver: Solver[TData]) -&gt; Curve:  # noqa: ARG002\n    \"\"\"Called after stepping the curve, but before logging it\n\n    This is called after attaching additional curve metadata requested by curve loggers.\n\n    Subclasses can raise `RetryStep` or `StopEarly` here if necessary, or further process the\n    curve.\n    \"\"\"\n    return curve\n</code></pre>"},{"location":"api/flow/#curvey.flow.SingularityFreeMeanCurvatureFlow.solver","title":"<code>solver(initial: Curve, **kwargs) -&gt; Solver[_SfmcfData]</code>","text":"<p>Construct a solver for this flow</p> <p>All **kwargs are passed to the <code>Solver</code> constructor.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def solver(self, initial: Curve, **kwargs) -&gt; Solver[_SfmcfData]:\n    \"\"\"Construct a solver for this flow\n\n    All **kwargs are passed to the `Solver` constructor.\n    \"\"\"\n    stiffness = scipy.sparse.diags(-1 / initial.dual_edge_length) @ initial.laplacian\n    data = _SfmcfData(stiffness=stiffness)\n    return Solver(flow=self, initial=initial, data=data, **kwargs)\n</code></pre>"},{"location":"api/flow/#curvey.flow.Solver","title":"<code>Solver</code>","text":"<p>             Bases: <code>Generic[TData]</code></p> <p>Auxillary class for solving curve <code>Flow</code>s</p> <p>Parameters:</p> Name Type Description Default <code>flow</code> <code>AbstractFlow</code> <p>The <code>Flow</code> object we're solving</p> required <code>initial</code> <code>Curve</code> <p>The initial <code>Curve</code> to start solving from</p> required <code>timestep</code> <code>float | None</code> <p>For fixed timesteps</p> <code>None</code> <code>timestep_fn</code> <code>Callable[[Solver], float] | None</code> <p>A function <code>Solver -&gt; float</code> that can adaptively decide a timestep on each iteration.</p> <code>None</code> <code>history</code> <code>bool</code> <p>If true, the <code>Curve</code> after each iteration is stored in <code>Solver.history</code>, a <code>Curves</code> object.</p> <code>True</code> <code>max_step</code> <code>int | None</code> <p>Maximum number of iterations to run.</p> <code>None</code> <code>stop_on_non_simple</code> <code>bool</code> <p>A step whose <code>Curve.is_simple == False</code> stops the run, discarding the non-simple curve.</p> <code>False</code> <code>verbose</code> <code>bool</code> <p>If true, curve state information and stopping messages are printed to stdout on each iteration.</p> <code>False</code> <code>log</code> <code>bool</code> <p>If true, the printed log messages as in <code>verbose</code> are saved as a list of <code>str</code>s in <code>Solver.log</code></p> <code>False</code> <code>data</code> <code>TData</code> <p>Flow specific data.</p> required <code>step_fn</code> <code>Callable[[Solver], Curve] | None</code> <p>A function <code>Solver -&gt; Curve</code> that steps the curve forward at each iteration. This just defaults to <code>Solver.step</code>.</p> <code>None</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>class Solver(Generic[TData]):\n    \"\"\"Auxillary class for solving curve `Flow`s\n\n    Parameters\n    ----------\n    flow\n        The `Flow` object we're solving\n\n    initial\n        The initial `Curve` to start solving from\n\n    timestep\n        For fixed timesteps\n\n    timestep_fn\n        A function `Solver -&gt; float` that can adaptively decide a timestep on each iteration.\n\n    history\n        If true, the `Curve` after each iteration is stored in `Solver.history`, a `Curves` object.\n\n    max_step\n        Maximum number of iterations to run.\n\n    stop_on_non_simple\n        A step whose `Curve.is_simple == False` stops the run, discarding the non-simple\n        curve.\n\n    verbose\n        If true, curve state information and stopping messages are printed to stdout on each\n        iteration.\n\n    log\n        If true, the printed log messages as in `verbose` are saved as a list of `str`s in\n        `Solver.log`\n\n    data\n        Flow specific data.\n\n    step_fn\n        A function `Solver -&gt; Curve` that steps the curve forward at each iteration. This just\n        defaults to `Solver.step`.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        flow: AbstractFlow,\n        initial: Curve,\n        data: TData,\n        timestep: float | None = None,\n        timestep_fn: Callable[[Solver], float] | None = None,\n        history: bool = True,\n        max_step: int | None = None,\n        stop_on_non_simple: bool = False,\n        verbose: bool = False,\n        log: bool = False,\n        step_fn: Callable[[Solver], Curve] | None = None,\n    ):\n        self.flow = flow\n        self.initial = initial\n        self.current = initial.with_data(time=0, step=0)\n        self.previous: Curve | None = None\n        self.timestep = timestep\n        self.timestep_fn = timestep_fn\n        self.history: Curves | None = None\n        if history:\n            # Note that we don't log the first curve until\n            # self.run() in case some extra initialization needs to happen somewhere\n            self.history = Curves([])\n        self.log_history: list[str] | None = [] if log else None\n        self.max_step = max_step\n        self.stop_on_non_simple = stop_on_non_simple\n        self.verbose = verbose\n\n        self._stop_fns: list[Callable[[Solver], bool]] = []\n        self._curve_loggers: dict[str, Callable[[Curve], Any]] = {}\n        self.data = data\n        self.step_fn = step_fn\n\n    def __repr__(self) -&gt; str:\n        solver_name = self.__class__.__name__\n        flow_name = self.flow.__class__.__name__\n        return f\"{solver_name}(flow={flow_name}, current={self.current})\"\n\n    def log(self, msg: str, *args, **kwargs):\n        \"\"\"Log a message\n\n        This is always sent to the module `logging.logger` at debug level.\n        If `self.verbose` is true, it's also printed to stdout.\n        If `self.log` is true, it's saved as a str in self.log_history\n        \"\"\"\n        self._log(_BraceMessage(msg, *args, **kwargs))\n\n    def _log(self, bm: _BraceMessage):\n        logger.debug(bm)\n        if self.verbose:\n            pass\n        if self.log_history is not None:\n            self.log_history.append(str(bm))\n\n    def _log_state(self, msg: str):\n        m = _BraceMessage(msg=msg)\n\n        for k, v in self.current.data.items():\n            if k != \"step\":\n                m.append(\", {} = {}\", k, v)\n\n        self._log(m)\n\n    def _log_step(self, c1: Curve):\n        m = _BraceMessage(\"Step {}\", c1[\"step\"])\n        c0 = self.current\n        ks = (c0.data.keys() &amp; c1.data.keys()) - {\"step\"}\n        for k in ks:\n            m.append(\", {}: {} =&gt; {}\", k, c0[k], c1[k])\n        self._log(m)\n\n    def _stop_fn(self) -&gt; bool:\n        \"\"\"Returns True if run should stop\"\"\"\n        if self.max_step is not None and self.current[\"step\"] == self.max_step:\n            self.log(\"Stopping at max step {}\", self.current[\"step\"])\n            return True\n\n        for fn in self._stop_fns:\n            if fn(self):\n                self.log(\"Stopping due to stop fn {}\", fn)\n                return True\n\n        return False\n\n    def add_stop_fn(self, fn: Callable[[Solver], bool]) -&gt; Self:\n        \"\"\"Add a custom stop function. The run is stopped early if `fn(curve)` returns True\n\n        Returns\n        -------\n        self\n\n        \"\"\"\n        self._stop_fns.append(fn)\n        return self\n\n    def add_curve_loggers(self, **kwargs: Callable[[Curve], Any]) -&gt; Self:\n        \"\"\"Log additional information as curve metadata\n\n        e.g. `solver.add_curve_loggers(foo=foo_fn, bar=bar_fn) will store the results of\n        the function calls `foo_fn(curve)` and `bar_fn(curve)` in the curve metadata 'foo' and 'bar'\n        properties.\n\n        Returns\n        -------\n        self\n\n        \"\"\"\n        self._curve_loggers.update(kwargs)\n        return self\n\n    def stop_on_param_limits(\n        self,\n        param: str,\n        min_val=None,\n        max_val=None,\n        param_fn: Callable[[Curve], Any] | None = None,\n    ) -&gt; Self:\n        \"\"\"Add a custom stop function based on a parameter value\n\n        Parameters\n        ----------\n        param\n            The name of the parameter. This is usually a curve metadata object, e.g. one logged\n            via `Solver.add_curve_loggers`. If `param_fn` is supplied, `param` is only used as the\n            parameter name for logging purposes.\n\n        min_val\n            The run is stopped if the parameter value &lt; `min_val`. `None` means no lower limit.\n\n        max_val\n            The run is stopped if the parameter value &gt; `max_val`. `None` means no upper limit.\n\n        param_fn\n            An optional function `Curve -&gt; value`; if supplied `param` doesn't need to be available\n            as `Curve` metadata.\n\n        Returns\n        -------\n        self\n\n        \"\"\"\n        if param_fn is None:\n\n            def param_fn(c: Curve) -&gt; Any:\n                return c[param]\n\n        def param_limits_stop_fn(solver: Solver) -&gt; bool:\n            val = param_fn(solver.current)\n\n            if min_val is not None and val &lt; min_val:\n                solver.log(\"Parameter {} value {} &lt; min value {}, stopping\", param, val, min_val)\n                return True\n\n            if max_val is not None and val &gt; max_val:\n                solver.log(\"Parameter {} value {} &gt; max value {}, stopping\", param, val, max_val)\n                return True\n\n            return False\n\n        self.add_stop_fn(param_limits_stop_fn)\n        return self\n\n    def run(self):\n        \"\"\"Solve the flow by stepping the curve through time\n\n        If no stop criterion are specified by `max_step`, `add_stop_fn`, or\n        `stop_on_param_limits`, this might run forever.\n\n        Returns\n        -------\n        self\n\n        \"\"\"\n        self.current = self.attach_metadata(self.initial, time=0, step=0)\n        if self.history is not None:\n            self.history.append(self.current)\n\n        self._log_state(\"Initial state\")\n        step_fn = self.step_fn or Solver.step\n\n        while not self._stop_fn():\n            try:\n                next_curve = step_fn(self)\n                next_curve = self.flow.poststep(curve=next_curve, solver=self)\n            except RetryStep:\n                continue\n            except StopEarly:\n                break\n\n            if self.stop_on_non_simple and not next_curve.is_simple:\n                self.log(\"Curve is non-simple, stopping\")\n                break\n\n            self._log_step(next_curve)\n            self.previous = self.current\n            self.current = next_curve\n            if self.history is not None:\n                self.history.append(next_curve)\n\n        self._log_state(\"Final state\")\n        return self\n\n    def step(self) -&gt; Curve:\n        \"\"\"Call `Flow.step` with the current state and timestep\"\"\"\n\n        if self.timestep_fn is not None:\n            timestep = self.timestep_fn(self)\n        elif self.timestep is not None:\n            timestep = self.timestep\n        else:\n            msg = \"Neither of `timestep` or `timestep_fn` were provided.\"\n            raise ValueError(msg)\n\n        # The `Flow` does the actual work here\n        curve = self.flow.step(\n            curve=self.current,\n            timestep=timestep,\n            solver=self,\n        )\n\n        return self.attach_metadata(\n            curve=curve,\n            time=self.current[\"time\"] + timestep,\n            timestep=timestep,\n        )\n\n    def attach_metadata(\n        self, curve: Curve, time: float, step: int | None = None, **kwargs\n    ) -&gt; Curve:\n        \"\"\"Store requested metadata on the curve\n\n        Parameters\n        ----------\n        curve\n            The curve after the most recent step.\n\n        time\n            The time of the curve in the solution.\n\n        step\n            Which step this curve belongs to. This is almost always left None; it defaults\n            to `solver.current['step'] + 1`.\n\n        **kwargs\n            Additional metadata to store as key=value pairs.\n\n        Returns\n        -------\n        curve\n            The curve with metadata attached.\n        \"\"\"\n        if step is None:\n            step = self.current[\"step\"] + 1\n\n        params = dict(time=time, step=step, **kwargs)\n        for k, fn in self._curve_loggers.items():\n            params[k] = fn(curve)\n        return curve.with_data(**params)\n</code></pre>"},{"location":"api/flow/#curvey.flow.Solver.add_curve_loggers","title":"<code>add_curve_loggers(**kwargs: Callable[[Curve], Any]) -&gt; Self</code>","text":"<p>Log additional information as curve metadata</p> <p>e.g. <code>solver.add_curve_loggers(foo=foo_fn, bar=bar_fn) will store the results of the function calls</code>foo_fn(curve)<code>and</code>bar_fn(curve)` in the curve metadata 'foo' and 'bar' properties.</p> <p>Returns:</p> Type Description <code>self</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def add_curve_loggers(self, **kwargs: Callable[[Curve], Any]) -&gt; Self:\n    \"\"\"Log additional information as curve metadata\n\n    e.g. `solver.add_curve_loggers(foo=foo_fn, bar=bar_fn) will store the results of\n    the function calls `foo_fn(curve)` and `bar_fn(curve)` in the curve metadata 'foo' and 'bar'\n    properties.\n\n    Returns\n    -------\n    self\n\n    \"\"\"\n    self._curve_loggers.update(kwargs)\n    return self\n</code></pre>"},{"location":"api/flow/#curvey.flow.Solver.add_stop_fn","title":"<code>add_stop_fn(fn: Callable[[Solver], bool]) -&gt; Self</code>","text":"<p>Add a custom stop function. The run is stopped early if <code>fn(curve)</code> returns True</p> <p>Returns:</p> Type Description <code>self</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def add_stop_fn(self, fn: Callable[[Solver], bool]) -&gt; Self:\n    \"\"\"Add a custom stop function. The run is stopped early if `fn(curve)` returns True\n\n    Returns\n    -------\n    self\n\n    \"\"\"\n    self._stop_fns.append(fn)\n    return self\n</code></pre>"},{"location":"api/flow/#curvey.flow.Solver.attach_metadata","title":"<code>attach_metadata(curve: Curve, time: float, step: int | None = None, **kwargs) -&gt; Curve</code>","text":"<p>Store requested metadata on the curve</p> <p>Parameters:</p> Name Type Description Default <code>curve</code> <code>Curve</code> <p>The curve after the most recent step.</p> required <code>time</code> <code>float</code> <p>The time of the curve in the solution.</p> required <code>step</code> <code>int | None</code> <p>Which step this curve belongs to. This is almost always left None; it defaults to <code>solver.current['step'] + 1</code>.</p> <code>None</code> <code>**kwargs</code> <p>Additional metadata to store as key=value pairs.</p> <code>{}</code> <p>Returns:</p> Type Description <code>curve</code> <p>The curve with metadata attached.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def attach_metadata(\n    self, curve: Curve, time: float, step: int | None = None, **kwargs\n) -&gt; Curve:\n    \"\"\"Store requested metadata on the curve\n\n    Parameters\n    ----------\n    curve\n        The curve after the most recent step.\n\n    time\n        The time of the curve in the solution.\n\n    step\n        Which step this curve belongs to. This is almost always left None; it defaults\n        to `solver.current['step'] + 1`.\n\n    **kwargs\n        Additional metadata to store as key=value pairs.\n\n    Returns\n    -------\n    curve\n        The curve with metadata attached.\n    \"\"\"\n    if step is None:\n        step = self.current[\"step\"] + 1\n\n    params = dict(time=time, step=step, **kwargs)\n    for k, fn in self._curve_loggers.items():\n        params[k] = fn(curve)\n    return curve.with_data(**params)\n</code></pre>"},{"location":"api/flow/#curvey.flow.Solver.log","title":"<code>log(msg: str, *args, **kwargs)</code>","text":"<p>Log a message</p> <p>This is always sent to the module <code>logging.logger</code> at debug level. If <code>self.verbose</code> is true, it's also printed to stdout. If <code>self.log</code> is true, it's saved as a str in self.log_history</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def log(self, msg: str, *args, **kwargs):\n    \"\"\"Log a message\n\n    This is always sent to the module `logging.logger` at debug level.\n    If `self.verbose` is true, it's also printed to stdout.\n    If `self.log` is true, it's saved as a str in self.log_history\n    \"\"\"\n    self._log(_BraceMessage(msg, *args, **kwargs))\n</code></pre>"},{"location":"api/flow/#curvey.flow.Solver.run","title":"<code>run()</code>","text":"<p>Solve the flow by stepping the curve through time</p> <p>If no stop criterion are specified by <code>max_step</code>, <code>add_stop_fn</code>, or <code>stop_on_param_limits</code>, this might run forever.</p> <p>Returns:</p> Type Description <code>self</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def run(self):\n    \"\"\"Solve the flow by stepping the curve through time\n\n    If no stop criterion are specified by `max_step`, `add_stop_fn`, or\n    `stop_on_param_limits`, this might run forever.\n\n    Returns\n    -------\n    self\n\n    \"\"\"\n    self.current = self.attach_metadata(self.initial, time=0, step=0)\n    if self.history is not None:\n        self.history.append(self.current)\n\n    self._log_state(\"Initial state\")\n    step_fn = self.step_fn or Solver.step\n\n    while not self._stop_fn():\n        try:\n            next_curve = step_fn(self)\n            next_curve = self.flow.poststep(curve=next_curve, solver=self)\n        except RetryStep:\n            continue\n        except StopEarly:\n            break\n\n        if self.stop_on_non_simple and not next_curve.is_simple:\n            self.log(\"Curve is non-simple, stopping\")\n            break\n\n        self._log_step(next_curve)\n        self.previous = self.current\n        self.current = next_curve\n        if self.history is not None:\n            self.history.append(next_curve)\n\n    self._log_state(\"Final state\")\n    return self\n</code></pre>"},{"location":"api/flow/#curvey.flow.Solver.step","title":"<code>step() -&gt; Curve</code>","text":"<p>Call <code>Flow.step</code> with the current state and timestep</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def step(self) -&gt; Curve:\n    \"\"\"Call `Flow.step` with the current state and timestep\"\"\"\n\n    if self.timestep_fn is not None:\n        timestep = self.timestep_fn(self)\n    elif self.timestep is not None:\n        timestep = self.timestep\n    else:\n        msg = \"Neither of `timestep` or `timestep_fn` were provided.\"\n        raise ValueError(msg)\n\n    # The `Flow` does the actual work here\n    curve = self.flow.step(\n        curve=self.current,\n        timestep=timestep,\n        solver=self,\n    )\n\n    return self.attach_metadata(\n        curve=curve,\n        time=self.current[\"time\"] + timestep,\n        timestep=timestep,\n    )\n</code></pre>"},{"location":"api/flow/#curvey.flow.Solver.stop_on_param_limits","title":"<code>stop_on_param_limits(param: str, min_val=None, max_val=None, param_fn: Callable[[Curve], Any] | None = None) -&gt; Self</code>","text":"<p>Add a custom stop function based on a parameter value</p> <p>Parameters:</p> Name Type Description Default <code>param</code> <code>str</code> <p>The name of the parameter. This is usually a curve metadata object, e.g. one logged via <code>Solver.add_curve_loggers</code>. If <code>param_fn</code> is supplied, <code>param</code> is only used as the parameter name for logging purposes.</p> required <code>min_val</code> <p>The run is stopped if the parameter value &lt; <code>min_val</code>. <code>None</code> means no lower limit.</p> <code>None</code> <code>max_val</code> <p>The run is stopped if the parameter value &gt; <code>max_val</code>. <code>None</code> means no upper limit.</p> <code>None</code> <code>param_fn</code> <code>Callable[[Curve], Any] | None</code> <p>An optional function <code>Curve -&gt; value</code>; if supplied <code>param</code> doesn't need to be available as <code>Curve</code> metadata.</p> <code>None</code> <p>Returns:</p> Type Description <code>self</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def stop_on_param_limits(\n    self,\n    param: str,\n    min_val=None,\n    max_val=None,\n    param_fn: Callable[[Curve], Any] | None = None,\n) -&gt; Self:\n    \"\"\"Add a custom stop function based on a parameter value\n\n    Parameters\n    ----------\n    param\n        The name of the parameter. This is usually a curve metadata object, e.g. one logged\n        via `Solver.add_curve_loggers`. If `param_fn` is supplied, `param` is only used as the\n        parameter name for logging purposes.\n\n    min_val\n        The run is stopped if the parameter value &lt; `min_val`. `None` means no lower limit.\n\n    max_val\n        The run is stopped if the parameter value &gt; `max_val`. `None` means no upper limit.\n\n    param_fn\n        An optional function `Curve -&gt; value`; if supplied `param` doesn't need to be available\n        as `Curve` metadata.\n\n    Returns\n    -------\n    self\n\n    \"\"\"\n    if param_fn is None:\n\n        def param_fn(c: Curve) -&gt; Any:\n            return c[param]\n\n    def param_limits_stop_fn(solver: Solver) -&gt; bool:\n        val = param_fn(solver.current)\n\n        if min_val is not None and val &lt; min_val:\n            solver.log(\"Parameter {} value {} &lt; min value {}, stopping\", param, val, min_val)\n            return True\n\n        if max_val is not None and val &gt; max_val:\n            solver.log(\"Parameter {} value {} &gt; max value {}, stopping\", param, val, max_val)\n            return True\n\n        return False\n\n    self.add_stop_fn(param_limits_stop_fn)\n    return self\n</code></pre>"},{"location":"api/flow/#curvey.flow.StopEarly","title":"<code>StopEarly</code>","text":"<p>             Bases: <code>Exception</code></p> <p>This can be raised in a custom <code>Solver.step_fn</code> to stop the current run</p> <p>Usually after reaching some stopping criterion.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>class StopEarly(Exception):\n    \"\"\"This can be raised in a custom `Solver.step_fn` to stop the current run\n\n    Usually after reaching some stopping criterion.\n    \"\"\"\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow","title":"<code>WillmoreFlow</code>","text":"<p>             Bases: <code>AbstractCurvatureFlow[_WillmoreFlowData]</code></p> <p>Willmore Flow</p> <p>As explained in Robust Fairing via Conformal Curvature Flow. Keenan Crane, Ulrich Pinkall, and Peter Schr\u00f6der. 2014.</p> <p>Parameters:</p> Name Type Description Default <code>filter_width</code> <code>float | None</code> <code>None</code> <code>filter_shape</code> <code>int | None</code> <p>The \\(\\theta\\) and \\(k\\) parameters in Crane \u00a74. These filter the curvature flow direction and can be used to prioritize high or low frequency smoothing.</p> <code>None</code> <code>constrain</code> <code>bool</code> <p>Whether to apply the closed curve constraints on the curvature flow direction at each timestep. See method <code>WillmoreFlow.constrain_flow</code> for more details.</p> <code>True</code> <code>solve_vertices</code> <code>bool</code> <p>Whether to distribute length discretization errors. See method <code>Curve.with_curvatures</code> for more details.</p> <code>True</code> <code>realign</code> <code>bool</code> <p>Whether to realign the curve at each timestep to the preceeding one. Because flipping back and forth between extrinsic and intrinsic representations loses rotation and translation information, this helps visually align the curve at each step, but may be an unnecessary computation each iteration if alignment isn't important. See method <code>Curve.with_curvatures</code> for more details.</p> <code>True</code> <code>tgt_curvature</code> <code>ndarray | None</code> <p>Vector of target vertex curvatures to flow towards.</p> <code>None</code> Source code in <code>src\\curvey\\flow.py</code> <pre><code>class WillmoreFlow(AbstractCurvatureFlow[_WillmoreFlowData]):\n    r\"\"\"Willmore Flow\n\n    As explained in [*Robust Fairing via Conformal Curvature Flow.* Keenan Crane, Ulrich Pinkall,\n    and Peter Schr\u00f6der. 2014.](\n    https://www.cs.cmu.edu/~kmcrane/Projects/ConformalWillmoreFlow/paper.pdf)\n\n    Parameters\n    ----------\n    filter_width\n    filter_shape\n        The $\\theta$ and $k$ parameters in Crane \u00a74. These filter the curvature flow direction and\n        can be used to prioritize high or low frequency smoothing.\n\n    constrain\n        Whether to apply the closed curve constraints on the curvature flow direction at each\n        timestep. See method `WillmoreFlow.constrain_flow` for more details.\n\n    solve_vertices\n        Whether to distribute length discretization errors.\n        See method `Curve.with_curvatures` for more details.\n\n    realign\n        Whether to realign the curve at each timestep to the preceeding one. Because flipping\n        back and forth between extrinsic and intrinsic representations loses rotation and\n        translation information, this helps visually align the curve at each step, but may be\n        an unnecessary computation each iteration if alignment isn't important. See method\n        `Curve.with_curvatures` for more details.\n\n    tgt_curvature\n        Vector of target vertex curvatures to flow towards.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        constrain: bool = True,\n        filter_width: float | None = None,\n        filter_shape: int | None = None,\n        solve_vertices: bool = True,\n        realign: bool = True,\n        tgt_curvature: ndarray | None = None,\n        **kwargs,\n    ):\n        super().__init__(**kwargs)\n        self.constrain = constrain\n        self.filter_width = filter_width\n        self.filter_shape = filter_shape\n        _filter_params_specified = {filter_shape is not None, filter_width is not None}\n        if len(_filter_params_specified) != 1:\n            msg = (\n                \"Both `filter_width` and `filter_shape` must be specified to filter curvature flow\"\n            )\n            raise ValueError(msg)\n        self._do_filter: bool = _filter_params_specified.pop()\n\n        self.solve_vertices = solve_vertices\n        self.realign = realign\n        self.tgt_curvature = tgt_curvature\n\n    @staticmethod\n    def constrain_flow(curve: Curve, dk: ndarray) -&gt; ndarray:\n        \"\"\"Constrain curvature flow as per Crane \u00a75\n\n        Constraints are\n\n        1. end points must meet: $f(0) = f(L)$\n        2. tangents must agree at endpoints: $T(0) = T(L)$.\n\n        Parameters\n        ----------\n        curve\n            The curve to constrain flow for.\n\n        dk\n            A `n_vertices` length vector indicating the curvature flow.\n\n        Returns\n        -------\n        dk_constrained\n            the curvature flow direction after applying the constraints.\n\n        \"\"\"\n        mass = curve.dual_edge_length\n\n        def inner_product(f: ndarray, g: ndarray) -&gt; float:\n            \"\"\"The L2 inner product \u27e8\u27e8F G\u27e9\u27e9\"\"\"\n            return (f * mass * g).sum()\n\n        def proj(f: ndarray, g: ndarray) -&gt; ndarray:\n            \"\"\"Projection of f onto g\"\"\"\n            return inner_product(f, g) / inner_product(g, g) * g\n\n        # Construct orthogonal constraint basis (Crane \u00a74, the `c_i` terms) via Gram-Schmidt\n        x, y = curve.points.T\n        c0 = ones(curve.n)\n        c1 = x - proj(x, c0)\n        c2 = y - proj(y, c1) - proj(y, c0)\n\n        # Subtract flow along the constraint basis\n        return dk - proj(dk, c0) - proj(dk, c1) - proj(dk, c2)\n\n    def filter_flow_direction(self, curve: Curve, dk: ndarray) -&gt; ndarray:\n        \"\"\"Filter curvature flow gradient\"\"\"\n        sigma, order = self.filter_width, self.filter_shape\n        if sigma is None:\n            msg = \"filter_width is None\"\n            raise ValueError(msg)\n        if order is None:\n            msg = \"filter_shape is None\"\n            raise ValueError(msg)\n\n        n = curve.n\n\n        # Square matrix `a` here is the term `id - \u03c3\u2206^k` in Crane \u00a74\n        # `filtered` is inv(a) @ dk\n        if order == 0:\n            # can't be a sparse array\n            a = eye(n, n) - sigma * ones((n, n))\n            filtered = np.linalg.solve(a, dk)\n        else:\n            # lb = curve.laplacian\n            lb = scipy.sparse.diags_array(-1 / curve.dual_edge_length) @ curve.laplacian\n            a = scipy.sparse.eye(n, n) - sigma * (lb**order)\n            filtered = scipy.sparse.linalg.spsolve(a, dk)\n\n        return dk - filtered  # v \u2190 v - inv(a)v\n\n    def solver(\n        self,\n        initial: Curve,\n        stop_tol: float | None = None,\n        stop_on_energy_increase: bool = False,\n        **kwargs,\n    ) -&gt; Solver[_WillmoreFlowData]:\n        \"\"\"Construct a `Solver` for the flow\n\n        Parameters\n        ----------\n        initial\n            The initial `Curve`.\n\n        stop_tol\n            Optional stopping tolerance. See `WillmoreFlow.stop_on_gradient_tolerance`\n            for more details.\n\n        stop_on_energy_increase\n            Stop the first time energy is increased. The step with increased energy is discarded.\n\n        **kwargs\n            Remaining kwargs passed to the `Solver` constructor.\n\n        Notes\n        -----\n        If neither `timestep` nor `timestep_fn` are supplied to the solver, sets the solver\n        `timestep_fn` to `self.autotimestep_fn` for adaptive timestep selection. When\n        `tgt_curvatures` is None, it's probably safe to just use a reasonably large timestep &lt; 1,\n        but an adaptive timestep seems to be safer for targeted curvature flow.\n        \"\"\"\n\n        data = _WillmoreFlowData(stop_on_energy_increase=stop_on_energy_increase)\n        solver = Solver(flow=self, initial=initial, data=data, **kwargs)\n        solver.add_curve_loggers(willmore_energy=self.energy)\n\n        if solver.timestep is solver.timestep_fn is None:\n            solver.timestep_fn = self.autotimestep_fn()\n\n        if stop_tol is not None:\n            solver.add_stop_fn(self.stop_on_gradient_tolerance(stop_tol))\n\n        return solver\n\n    def step(self, curve: Curve, timestep: float, solver: Solver[_WillmoreFlowData]) -&gt; Curve:\n        \"\"\"Step the curve along its Willmore energy gradient\"\"\"\n        k0 = self.curvature_fn(curve)\n\n        # Calculate curvature gradient, i.e. the derivative of E(k) = ||k||^2\n        dk = -2 * k0 if self.tgt_curvature is None else -2 * (k0 - self.tgt_curvature)\n\n        if self._do_filter:\n            dk = self.filter_flow_direction(curve, dk)\n\n        if self.constrain:\n            dk = self.constrain_flow(curve, dk)\n\n        k1 = k0 + timestep * dk\n        curve = curve.with_curvature(\n            curvature=k1,\n            solve_vertices=self.solve_vertices,\n            realign=self.realign,\n        )\n        return self._postprocess(curve, solver=solver)\n\n    def poststep(self, curve: Curve, solver: Solver[_WillmoreFlowData]) -&gt; Curve:\n        if solver.data[\"stop_on_energy_increase\"]:\n            e1 = curve[\"willmore_energy\"]\n            e0 = solver.current[\"willmore_energy\"]\n            if e1 &gt; e0:\n                solver.log(\"Willmore energy increased {} =&gt; {}, stopping\", e0, e1)\n                raise StopEarly()\n\n        return curve\n\n    def energy(\n        self,\n        curve: Curve,\n        tgt_curvature: ndarray | _Sentinel | None = _Sentinel.DEFAULT,\n    ) -&gt; float:\n        r\"\"\"Calculate curve energy\n\n        By default uses `self.tgt_curvature`, but can be overridden with the supplied\n        `tgt_curvature`.\n\n        If `tgt_curvature` is None, calculates the Willmore energy\n\n        $$\n            E(c) = \\sum_i^n \\kappa_i^2 l_i$\n        $$\n\n        for vertex curvatures $\\kappa_i$ and dual edge lengths $l_i$.\n\n        If `tgt_curvature` is not None, calculates\n\n        $$\n            E(c) = \\sum_i^n ( \\kappa_i - \\hat \\kappa_i)^2 l_i\n        $$\n\n        for target vertex curvatures $\\hat \\kappa_i$.\n\n        \"\"\"\n        if tgt_curvature is _Sentinel.DEFAULT:\n            tgt_curvature = self.tgt_curvature\n\n        if tgt_curvature is None:\n            return (self.curvature_fn(curve) ** 2 * curve.dual_edge_length).sum()\n\n        dk = self.curvature_fn(curve) - tgt_curvature\n        return (dk**2 * curve.dual_edge_length).sum()\n\n    @staticmethod\n    def autotimestep_fn(\n        min_step: float | None = 1e-5,\n        max_step: float | None = 0.9,\n    ) -&gt; Callable[[Solver], float]:\n        r\"\"\"Construct an adaptive timestep function\n\n        For curve $c$, calculates the timestep as $1 / \\sqrt {E(c)}$, for energy $E$, defined\n        in `WillmoreFlow.energy`. This value is then clamped to `min_step` and `max_step`,\n        if supplied.\n\n        Parameters\n        ----------\n        min_step\n            Minimum timestep.\n\n        max_step\n            Maximum timestep\n\n        Returns\n        -------\n        timestep_fn\n            A function `Solver -&gt; timestep`.\n        \"\"\"\n\n        def timestep_fn(solver: Solver) -&gt; float:\n            # NB WillmoreFlow.solver adds an energy logger\n            e = solver.current[\"willmore_energy\"]\n            if e == 0:\n                # Doesn't matter what the stepsize is\n                dt = solver.current.data.get(\"timestep\", nan)\n                return cast(float, np.nan_to_num(dt))\n\n            return float(clip(1 / sqrt(e), min_step, max_step))\n\n        return timestep_fn\n\n    @staticmethod\n    def stop_on_gradient_tolerance(tol: float) -&gt; Callable[[Solver], bool]:\n        \"\"\"Construct a `Solver` stopping function for the supplied tolerance\"\"\"\n\n        def stop_fn(solver: Solver):\n            if solver.previous is None:\n                return False\n\n            e1 = solver.current[\"willmore_energy\"]\n            e0 = solver.previous[\"willmore_energy\"]\n            dt = solver.current[\"timestep\"]\n            gradient = abs(e1 - e0) / dt\n            if gradient &lt; tol:\n                solver.log(\"Willmore energy gradient {} &lt; tol {}, stopping\", gradient, tol)\n                return True\n\n            return False\n\n        return stop_fn\n\n    def with_tgt_curvature(self, tgt_curvature: ndarray) -&gt; WillmoreFlow:\n        \"\"\"Replace the target curvatures\"\"\"\n        out = copy(self)\n        out.tgt_curvature = tgt_curvature\n        return out\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.autotimestep_fn","title":"<code>autotimestep_fn(min_step: float | None = 1e-05, max_step: float | None = 0.9) -&gt; Callable[[Solver], float]</code>  <code>staticmethod</code>","text":"<p>Construct an adaptive timestep function</p> <p>For curve \\(c\\), calculates the timestep as \\(1 / \\sqrt {E(c)}\\), for energy \\(E\\), defined in <code>WillmoreFlow.energy</code>. This value is then clamped to <code>min_step</code> and <code>max_step</code>, if supplied.</p> <p>Parameters:</p> Name Type Description Default <code>min_step</code> <code>float | None</code> <p>Minimum timestep.</p> <code>1e-05</code> <code>max_step</code> <code>float | None</code> <p>Maximum timestep</p> <code>0.9</code> <p>Returns:</p> Type Description <code>timestep_fn</code> <p>A function <code>Solver -&gt; timestep</code>.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@staticmethod\ndef autotimestep_fn(\n    min_step: float | None = 1e-5,\n    max_step: float | None = 0.9,\n) -&gt; Callable[[Solver], float]:\n    r\"\"\"Construct an adaptive timestep function\n\n    For curve $c$, calculates the timestep as $1 / \\sqrt {E(c)}$, for energy $E$, defined\n    in `WillmoreFlow.energy`. This value is then clamped to `min_step` and `max_step`,\n    if supplied.\n\n    Parameters\n    ----------\n    min_step\n        Minimum timestep.\n\n    max_step\n        Maximum timestep\n\n    Returns\n    -------\n    timestep_fn\n        A function `Solver -&gt; timestep`.\n    \"\"\"\n\n    def timestep_fn(solver: Solver) -&gt; float:\n        # NB WillmoreFlow.solver adds an energy logger\n        e = solver.current[\"willmore_energy\"]\n        if e == 0:\n            # Doesn't matter what the stepsize is\n            dt = solver.current.data.get(\"timestep\", nan)\n            return cast(float, np.nan_to_num(dt))\n\n        return float(clip(1 / sqrt(e), min_step, max_step))\n\n    return timestep_fn\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.constrain_flow","title":"<code>constrain_flow(curve: Curve, dk: ndarray) -&gt; ndarray</code>  <code>staticmethod</code>","text":"<p>Constrain curvature flow as per Crane \u00a75</p> <p>Constraints are</p> <ol> <li>end points must meet: \\(f(0) = f(L)\\)</li> <li>tangents must agree at endpoints: \\(T(0) = T(L)\\).</li> </ol> <p>Parameters:</p> Name Type Description Default <code>curve</code> <code>Curve</code> <p>The curve to constrain flow for.</p> required <code>dk</code> <code>ndarray</code> <p>A <code>n_vertices</code> length vector indicating the curvature flow.</p> required <p>Returns:</p> Type Description <code>dk_constrained</code> <p>the curvature flow direction after applying the constraints.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@staticmethod\ndef constrain_flow(curve: Curve, dk: ndarray) -&gt; ndarray:\n    \"\"\"Constrain curvature flow as per Crane \u00a75\n\n    Constraints are\n\n    1. end points must meet: $f(0) = f(L)$\n    2. tangents must agree at endpoints: $T(0) = T(L)$.\n\n    Parameters\n    ----------\n    curve\n        The curve to constrain flow for.\n\n    dk\n        A `n_vertices` length vector indicating the curvature flow.\n\n    Returns\n    -------\n    dk_constrained\n        the curvature flow direction after applying the constraints.\n\n    \"\"\"\n    mass = curve.dual_edge_length\n\n    def inner_product(f: ndarray, g: ndarray) -&gt; float:\n        \"\"\"The L2 inner product \u27e8\u27e8F G\u27e9\u27e9\"\"\"\n        return (f * mass * g).sum()\n\n    def proj(f: ndarray, g: ndarray) -&gt; ndarray:\n        \"\"\"Projection of f onto g\"\"\"\n        return inner_product(f, g) / inner_product(g, g) * g\n\n    # Construct orthogonal constraint basis (Crane \u00a74, the `c_i` terms) via Gram-Schmidt\n    x, y = curve.points.T\n    c0 = ones(curve.n)\n    c1 = x - proj(x, c0)\n    c2 = y - proj(y, c1) - proj(y, c0)\n\n    # Subtract flow along the constraint basis\n    return dk - proj(dk, c0) - proj(dk, c1) - proj(dk, c2)\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.default_curvature_fn","title":"<code>default_curvature_fn(curve: Curve) -&gt; ndarray</code>  <code>staticmethod</code>","text":"<p>Simply return the value of the <code>Curve.curvature</code> property</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@staticmethod\ndef default_curvature_fn(curve: Curve) -&gt; ndarray:\n    \"\"\"Simply return the value of the `Curve.curvature` property\"\"\"\n    return curve.curvature\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.energy","title":"<code>energy(curve: Curve, tgt_curvature: ndarray | _Sentinel | None = _Sentinel.DEFAULT) -&gt; float</code>","text":"<p>Calculate curve energy</p> <p>By default uses <code>self.tgt_curvature</code>, but can be overridden with the supplied <code>tgt_curvature</code>.</p> <p>If <code>tgt_curvature</code> is None, calculates the Willmore energy</p> \\[     E(c) = \\sum_i^n \\kappa_i^2 l_i$ \\] <p>for vertex curvatures \\(\\kappa_i\\) and dual edge lengths \\(l_i\\).</p> <p>If <code>tgt_curvature</code> is not None, calculates</p> \\[     E(c) = \\sum_i^n ( \\kappa_i - \\hat \\kappa_i)^2 l_i \\] <p>for target vertex curvatures \\(\\hat \\kappa_i\\).</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def energy(\n    self,\n    curve: Curve,\n    tgt_curvature: ndarray | _Sentinel | None = _Sentinel.DEFAULT,\n) -&gt; float:\n    r\"\"\"Calculate curve energy\n\n    By default uses `self.tgt_curvature`, but can be overridden with the supplied\n    `tgt_curvature`.\n\n    If `tgt_curvature` is None, calculates the Willmore energy\n\n    $$\n        E(c) = \\sum_i^n \\kappa_i^2 l_i$\n    $$\n\n    for vertex curvatures $\\kappa_i$ and dual edge lengths $l_i$.\n\n    If `tgt_curvature` is not None, calculates\n\n    $$\n        E(c) = \\sum_i^n ( \\kappa_i - \\hat \\kappa_i)^2 l_i\n    $$\n\n    for target vertex curvatures $\\hat \\kappa_i$.\n\n    \"\"\"\n    if tgt_curvature is _Sentinel.DEFAULT:\n        tgt_curvature = self.tgt_curvature\n\n    if tgt_curvature is None:\n        return (self.curvature_fn(curve) ** 2 * curve.dual_edge_length).sum()\n\n    dk = self.curvature_fn(curve) - tgt_curvature\n    return (dk**2 * curve.dual_edge_length).sum()\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.filter_flow_direction","title":"<code>filter_flow_direction(curve: Curve, dk: ndarray) -&gt; ndarray</code>","text":"<p>Filter curvature flow gradient</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def filter_flow_direction(self, curve: Curve, dk: ndarray) -&gt; ndarray:\n    \"\"\"Filter curvature flow gradient\"\"\"\n    sigma, order = self.filter_width, self.filter_shape\n    if sigma is None:\n        msg = \"filter_width is None\"\n        raise ValueError(msg)\n    if order is None:\n        msg = \"filter_shape is None\"\n        raise ValueError(msg)\n\n    n = curve.n\n\n    # Square matrix `a` here is the term `id - \u03c3\u2206^k` in Crane \u00a74\n    # `filtered` is inv(a) @ dk\n    if order == 0:\n        # can't be a sparse array\n        a = eye(n, n) - sigma * ones((n, n))\n        filtered = np.linalg.solve(a, dk)\n    else:\n        # lb = curve.laplacian\n        lb = scipy.sparse.diags_array(-1 / curve.dual_edge_length) @ curve.laplacian\n        a = scipy.sparse.eye(n, n) - sigma * (lb**order)\n        filtered = scipy.sparse.linalg.spsolve(a, dk)\n\n    return dk - filtered  # v \u2190 v - inv(a)v\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.solver","title":"<code>solver(initial: Curve, stop_tol: float | None = None, stop_on_energy_increase: bool = False, **kwargs) -&gt; Solver[_WillmoreFlowData]</code>","text":"<p>Construct a <code>Solver</code> for the flow</p> <p>Parameters:</p> Name Type Description Default <code>initial</code> <code>Curve</code> <p>The initial <code>Curve</code>.</p> required <code>stop_tol</code> <code>float | None</code> <p>Optional stopping tolerance. See <code>WillmoreFlow.stop_on_gradient_tolerance</code> for more details.</p> <code>None</code> <code>stop_on_energy_increase</code> <code>bool</code> <p>Stop the first time energy is increased. The step with increased energy is discarded.</p> <code>False</code> <code>**kwargs</code> <p>Remaining kwargs passed to the <code>Solver</code> constructor.</p> <code>{}</code> Notes <p>If neither <code>timestep</code> nor <code>timestep_fn</code> are supplied to the solver, sets the solver <code>timestep_fn</code> to <code>self.autotimestep_fn</code> for adaptive timestep selection. When <code>tgt_curvatures</code> is None, it's probably safe to just use a reasonably large timestep &lt; 1, but an adaptive timestep seems to be safer for targeted curvature flow.</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def solver(\n    self,\n    initial: Curve,\n    stop_tol: float | None = None,\n    stop_on_energy_increase: bool = False,\n    **kwargs,\n) -&gt; Solver[_WillmoreFlowData]:\n    \"\"\"Construct a `Solver` for the flow\n\n    Parameters\n    ----------\n    initial\n        The initial `Curve`.\n\n    stop_tol\n        Optional stopping tolerance. See `WillmoreFlow.stop_on_gradient_tolerance`\n        for more details.\n\n    stop_on_energy_increase\n        Stop the first time energy is increased. The step with increased energy is discarded.\n\n    **kwargs\n        Remaining kwargs passed to the `Solver` constructor.\n\n    Notes\n    -----\n    If neither `timestep` nor `timestep_fn` are supplied to the solver, sets the solver\n    `timestep_fn` to `self.autotimestep_fn` for adaptive timestep selection. When\n    `tgt_curvatures` is None, it's probably safe to just use a reasonably large timestep &lt; 1,\n    but an adaptive timestep seems to be safer for targeted curvature flow.\n    \"\"\"\n\n    data = _WillmoreFlowData(stop_on_energy_increase=stop_on_energy_increase)\n    solver = Solver(flow=self, initial=initial, data=data, **kwargs)\n    solver.add_curve_loggers(willmore_energy=self.energy)\n\n    if solver.timestep is solver.timestep_fn is None:\n        solver.timestep_fn = self.autotimestep_fn()\n\n    if stop_tol is not None:\n        solver.add_stop_fn(self.stop_on_gradient_tolerance(stop_tol))\n\n    return solver\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.step","title":"<code>step(curve: Curve, timestep: float, solver: Solver[_WillmoreFlowData]) -&gt; Curve</code>","text":"<p>Step the curve along its Willmore energy gradient</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def step(self, curve: Curve, timestep: float, solver: Solver[_WillmoreFlowData]) -&gt; Curve:\n    \"\"\"Step the curve along its Willmore energy gradient\"\"\"\n    k0 = self.curvature_fn(curve)\n\n    # Calculate curvature gradient, i.e. the derivative of E(k) = ||k||^2\n    dk = -2 * k0 if self.tgt_curvature is None else -2 * (k0 - self.tgt_curvature)\n\n    if self._do_filter:\n        dk = self.filter_flow_direction(curve, dk)\n\n    if self.constrain:\n        dk = self.constrain_flow(curve, dk)\n\n    k1 = k0 + timestep * dk\n    curve = curve.with_curvature(\n        curvature=k1,\n        solve_vertices=self.solve_vertices,\n        realign=self.realign,\n    )\n    return self._postprocess(curve, solver=solver)\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.stop_on_gradient_tolerance","title":"<code>stop_on_gradient_tolerance(tol: float) -&gt; Callable[[Solver], bool]</code>  <code>staticmethod</code>","text":"<p>Construct a <code>Solver</code> stopping function for the supplied tolerance</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>@staticmethod\ndef stop_on_gradient_tolerance(tol: float) -&gt; Callable[[Solver], bool]:\n    \"\"\"Construct a `Solver` stopping function for the supplied tolerance\"\"\"\n\n    def stop_fn(solver: Solver):\n        if solver.previous is None:\n            return False\n\n        e1 = solver.current[\"willmore_energy\"]\n        e0 = solver.previous[\"willmore_energy\"]\n        dt = solver.current[\"timestep\"]\n        gradient = abs(e1 - e0) / dt\n        if gradient &lt; tol:\n            solver.log(\"Willmore energy gradient {} &lt; tol {}, stopping\", gradient, tol)\n            return True\n\n        return False\n\n    return stop_fn\n</code></pre>"},{"location":"api/flow/#curvey.flow.WillmoreFlow.with_tgt_curvature","title":"<code>with_tgt_curvature(tgt_curvature: ndarray) -&gt; WillmoreFlow</code>","text":"<p>Replace the target curvatures</p> Source code in <code>src\\curvey\\flow.py</code> <pre><code>def with_tgt_curvature(self, tgt_curvature: ndarray) -&gt; WillmoreFlow:\n    \"\"\"Replace the target curvatures\"\"\"\n    out = copy(self)\n    out.tgt_curvature = tgt_curvature\n    return out\n</code></pre>"},{"location":"api/shape_structure_dataset/","title":"curvey.shape_structure_dataset","text":""},{"location":"api/shape_structure_dataset/#curvey.shape_structure_dataset","title":"<code>shape_structure_dataset</code>","text":"<p>Interface to the 2D Shape Structure Dataset</p> <p>Download the shapes zip file here.</p> <p>The dataset groups shapes by class; shapes can be loaded either by an exact name or a class name and an index.</p> <pre><code>from curvey.shape_structure_dataset import ShapeStructureDataset\n\ntry:\n    dataset = ShapeStructureDataset('~/Downloads/ShapesJSON.zip')\nexcept FileNotFoundError:\n    print(\"Couldn't find the ShapesJSON.zip file\")\nelse:\n    print(', '.join(dataset.classes))\n    curve = dataset.load_curve('elephant-1')  # or load_curve('elephant', 0)\n    curve.plot()\n</code></pre>"},{"location":"api/shape_structure_dataset/#curvey.shape_structure_dataset.ShapeStructureDataset","title":"<code>ShapeStructureDataset</code>","text":"<p>Interface to the 2D Shape Structure Dataset zip file</p> <p>Parameters:</p> Name Type Description Default <code>dataset</code> <code>str | Path</code> <p>the path to the <code>ShapesJSON.zip</code> zip file. Download it here</p> required Notes <p>Shapes in the dataset are actually a 2d triangular mesh, not a curve. Curves are loaded without any processing, assuming vertices are listed in order, so they may have irregularities, such as repeated points or self-intersections. Shapes with topological holes like the coffee cup are returned as a single curve without a care in the world.</p> Source code in <code>src\\curvey\\shape_structure_dataset.py</code> <pre><code>class ShapeStructureDataset:\n    \"\"\"Interface to the 2D Shape Structure Dataset zip file\n\n    Parameters\n    ----------\n    dataset\n        the path to the `ShapesJSON.zip` zip file. Download it\n        [here](https://2dshapesstructure.github.io/data/ShapesJSON.zip)\n\n    Notes\n    -----\n    Shapes in the dataset are actually a 2d triangular mesh, not a curve. Curves are loaded without\n    any processing, assuming vertices are listed in order, so they may have irregularities, such as\n    repeated points or self-intersections. Shapes with topological holes like the coffee cup are\n    returned as a single curve without a care in the world.\n    \"\"\"\n\n    # regex to match e.g. 'Shapes/Bone-13.json'\n    _shape_file_regex = re.compile(r\"Shapes/([^.]+)\\.json\")\n\n    def __init__(self, dataset: str | Path):\n        self.dataset = ZipFile(Path(dataset).expanduser())\n        self.cache: dict[str, ndarray] = {}\n\n    def _load_json(self, name: str, idx: int | None = True) -&gt; _JsonShape:\n        name = self._canonical_name(name, idx)\n        shape_bytes = self.dataset.read(f\"Shapes/{name}.json\")\n        return json.loads(shape_bytes)\n\n    def load_shape(\n        self,\n        name: str,\n        idx: int | None = None,\n        load_triangles: bool = True,\n    ) -&gt; tuple[ndarray, ndarray | None]:\n        \"\"\"A `(n_verts, 2)` array of points and a `(n_faces, 3)` array of triangles\"\"\"\n        data = self._load_json(name, idx)\n        pts = array([[d[\"x\"], d[\"y\"]] for d in data[\"points\"]])\n        if load_triangles:\n            tris = array([[d[\"p1\"], d[\"p2\"], d[\"p3\"]] for d in data[\"triangles\"]])\n        else:\n            tris = None\n        return pts, tris\n\n    def load_points(self, name: str, idx: int | None = None) -&gt; ndarray:\n        \"\"\"Load the points from the specified dataset\n\n        Note\n        ----\n        Some shapes in the dataset include repeated points. This method returns point-sets\n        as-is, without any further processing.\n\n        The dataset also includes triangulations. Use method `load_shape` to load those as well.\n        \"\"\"\n        name = self._canonical_name(name, idx)\n        if name in self.cache:\n            return self.cache[name]\n        pts, _ = self.load_shape(name, load_triangles=False)\n        self.cache[name] = pts\n        return pts\n\n    def load_curve(self, name: str, idx: int | None = None) -&gt; Curve:\n        \"\"\"Construct a `Curve` from the named shape in the dataset\n\n        Can load curves by explicit name, e.g. `dataset.load_curve('Bone-13')`,\n        or a class name and an index, e.g. `dataset.load_curve('Bone', 1)`.\n        Names are case-insensitive. Curves have `drop_repeated_points` applied automatically.\n        \"\"\"\n        name = self._canonical_name(name, idx)\n        pts = self.load_points(name).copy()\n        return Curve(pts).drop_repeated_points().with_data(ssd_name=name)\n\n    def _canonical_name(self, name: str, idx: int | None = None) -&gt; str:\n        if idx is None:\n            return name\n\n        return self.names_by_class[name][idx]\n\n    @cached_property\n    def all_names(self) -&gt; set[str]:\n        \"\"\"Names of the shapes in the dataset\"\"\"\n        return set(self._iter_all_names())\n\n    @cached_property\n    def names_by_class(self) -&gt; dict[str, tuple[str, ...]]:\n        \"\"\"Shape names grouped by their class\n\n        Returns\n        -------\n        classes :\n            `dict[class_name] -&gt; tuple[object_names, ...]`\n        \"\"\"\n        from collections import defaultdict\n\n        classes = defaultdict(list)\n        special_classes = (\"image\", \"device\", \"dino\")\n\n        for name in self.all_names:\n            for special in special_classes:\n                if name.startswith(special):\n                    classes[special].append(name)\n                    is_special = True\n                    break\n            else:\n                is_special = False\n\n            if is_special:\n                continue\n\n            class_name = name.split(\"-\")[0].lower()\n            classes[class_name].append(name)\n        return {k: tuple(sorted(v)) for k, v in classes.items()}\n\n    @cached_property\n    def class_names(self) -&gt; tuple[str, ...]:\n        \"\"\"Names of the unique shape classes in the dataset\"\"\"\n        return tuple(sorted(self.names_by_class.keys()))\n\n    def _iter_all_names(self) -&gt; Iterator[str]:\n        for f in self.dataset.filelist:\n            if match := self._shape_file_regex.match(f.filename):\n                yield match.group(1)\n</code></pre>"},{"location":"api/shape_structure_dataset/#curvey.shape_structure_dataset.ShapeStructureDataset.all_names","title":"<code>all_names: set[str]</code>  <code>cached</code> <code>property</code>","text":"<p>Names of the shapes in the dataset</p>"},{"location":"api/shape_structure_dataset/#curvey.shape_structure_dataset.ShapeStructureDataset.class_names","title":"<code>class_names: tuple[str, ...]</code>  <code>cached</code> <code>property</code>","text":"<p>Names of the unique shape classes in the dataset</p>"},{"location":"api/shape_structure_dataset/#curvey.shape_structure_dataset.ShapeStructureDataset.names_by_class","title":"<code>names_by_class: dict[str, tuple[str, ...]]</code>  <code>cached</code> <code>property</code>","text":"<p>Shape names grouped by their class</p> <p>Returns:</p> Name Type Description <code>classes</code> <code>dict[str, tuple[str, ...]]</code> <p><code>dict[class_name] -&gt; tuple[object_names, ...]</code></p>"},{"location":"api/shape_structure_dataset/#curvey.shape_structure_dataset.ShapeStructureDataset.load_curve","title":"<code>load_curve(name: str, idx: int | None = None) -&gt; Curve</code>","text":"<p>Construct a <code>Curve</code> from the named shape in the dataset</p> <p>Can load curves by explicit name, e.g. <code>dataset.load_curve('Bone-13')</code>, or a class name and an index, e.g. <code>dataset.load_curve('Bone', 1)</code>. Names are case-insensitive. Curves have <code>drop_repeated_points</code> applied automatically.</p> Source code in <code>src\\curvey\\shape_structure_dataset.py</code> <pre><code>def load_curve(self, name: str, idx: int | None = None) -&gt; Curve:\n    \"\"\"Construct a `Curve` from the named shape in the dataset\n\n    Can load curves by explicit name, e.g. `dataset.load_curve('Bone-13')`,\n    or a class name and an index, e.g. `dataset.load_curve('Bone', 1)`.\n    Names are case-insensitive. Curves have `drop_repeated_points` applied automatically.\n    \"\"\"\n    name = self._canonical_name(name, idx)\n    pts = self.load_points(name).copy()\n    return Curve(pts).drop_repeated_points().with_data(ssd_name=name)\n</code></pre>"},{"location":"api/shape_structure_dataset/#curvey.shape_structure_dataset.ShapeStructureDataset.load_points","title":"<code>load_points(name: str, idx: int | None = None) -&gt; ndarray</code>","text":"<p>Load the points from the specified dataset</p> Note <p>Some shapes in the dataset include repeated points. This method returns point-sets as-is, without any further processing.</p> <p>The dataset also includes triangulations. Use method <code>load_shape</code> to load those as well.</p> Source code in <code>src\\curvey\\shape_structure_dataset.py</code> <pre><code>def load_points(self, name: str, idx: int | None = None) -&gt; ndarray:\n    \"\"\"Load the points from the specified dataset\n\n    Note\n    ----\n    Some shapes in the dataset include repeated points. This method returns point-sets\n    as-is, without any further processing.\n\n    The dataset also includes triangulations. Use method `load_shape` to load those as well.\n    \"\"\"\n    name = self._canonical_name(name, idx)\n    if name in self.cache:\n        return self.cache[name]\n    pts, _ = self.load_shape(name, load_triangles=False)\n    self.cache[name] = pts\n    return pts\n</code></pre>"},{"location":"api/shape_structure_dataset/#curvey.shape_structure_dataset.ShapeStructureDataset.load_shape","title":"<code>load_shape(name: str, idx: int | None = None, load_triangles: bool = True) -&gt; tuple[ndarray, ndarray | None]</code>","text":"<p>A <code>(n_verts, 2)</code> array of points and a <code>(n_faces, 3)</code> array of triangles</p> Source code in <code>src\\curvey\\shape_structure_dataset.py</code> <pre><code>def load_shape(\n    self,\n    name: str,\n    idx: int | None = None,\n    load_triangles: bool = True,\n) -&gt; tuple[ndarray, ndarray | None]:\n    \"\"\"A `(n_verts, 2)` array of points and a `(n_faces, 3)` array of triangles\"\"\"\n    data = self._load_json(name, idx)\n    pts = array([[d[\"x\"], d[\"y\"]] for d in data[\"points\"]])\n    if load_triangles:\n        tris = array([[d[\"p1\"], d[\"p2\"], d[\"p3\"]] for d in data[\"triangles\"]])\n    else:\n        tris = None\n    return pts, tris\n</code></pre>"},{"location":"api/util/","title":"Util","text":""},{"location":"api/util/#curvey.util","title":"<code>util</code>","text":""},{"location":"api/util/#curvey.util.align_edges","title":"<code>align_edges(src_pts: ndarray, src_edges: ndarray, tgt_pts: ndarray, tgt_edges: ndarray, return_transform: bool = False) -&gt; ndarray</code>","text":"<p>Calulate mean change in angle and position between two curves</p> <p>Parameters:</p> Name Type Description Default <code>src_pts</code> <code>ndarray</code> <p><code>(n, 2)</code> source vertex coordinates.</p> required <code>tgt_pts</code> <code>ndarray</code> <p><code>(n, 2)</code> target vertex coordinates.</p> required <code>src_edges</code> <code>ndarray</code> <p><code>(n, 2)</code> source edge vectors.</p> required <code>tgt_edges</code> <code>ndarray</code> <p><code>(n, 2)</code> target edge vectors.</p> required <code>return_transform</code> <code>bool</code> <p>If True, return a 3x3 transformation matrix. Otherwise, return the transformed points.</p> <code>False</code> Source code in <code>src\\curvey\\util.py</code> <pre><code>def align_edges(\n    src_pts: ndarray,\n    src_edges: ndarray,\n    tgt_pts: ndarray,\n    tgt_edges: ndarray,\n    return_transform: bool = False,\n) -&gt; ndarray:\n    \"\"\"Calulate mean change in angle and position between two curves\n\n    Parameters\n    ----------\n    src_pts\n        `(n, 2)` source vertex coordinates.\n\n    tgt_pts\n        `(n, 2)` target vertex coordinates.\n\n    src_edges\n        `(n, 2)` source edge vectors.\n\n    tgt_edges\n        `(n, 2)` target edge vectors.\n\n    return_transform\n        If True, return a 3x3 transformation matrix. Otherwise, return the transformed points.\n\n    \"\"\"\n    # Calculate the mean angle between source and target edge vectors\n    # Because these are unnormalized, larger edges are weighted more heavily\n    cos_theta = (src_edges * tgt_edges).sum()\n    sin_theta = cross(src_edges, tgt_edges).sum()\n    theta = arctan2(sin_theta, cos_theta)\n    # NB negative sign here bc we're post-multipying, equiv. to transposing the rot matrix\n    pts = src_pts @ rotation_matrix(-theta)\n    # AFTER applying the rotation, check mean change in vertex position\n    offset = (tgt_pts - pts).mean(axis=0, keepdims=True)\n\n    if return_transform:\n        transform = eye(3)\n        transform[:2, :2] = rotation_matrix(theta)\n        transform[:2, 2] = offset\n        return transform\n\n    return pts + offset\n</code></pre>"},{"location":"api/util/#curvey.util.periodic_interpolator","title":"<code>periodic_interpolator(x: ndarray, f: ndarray, typ: InterpType | str = 'cubic') -&gt; Callable[[ndarray], ndarray]</code>","text":"<p>Construct a periodic interpolator of the function f(x)</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>ndarray</code> <p><code>(n + 1,)</code> array of independent variable values.</p> required <code>f</code> <code>ndarray</code> <p><code>(n,)</code> or <code>(n, ndim)</code> array of function values. <code>f(x[-1])</code> is assumed equal to <code>f(x[0])</code>.</p> required <code>typ</code> <code>InterpType | str</code> <p>The type of interpolator. One of</p> <ul> <li>'linear' for linear interpolation via <code>scipy.interpolate.interp1d</code></li> <li><code>cubic</code> for cubic spline interpolation via <code>scipy.interpolate.CubicSpline</code></li> <li>'pchip`<ul> <li>for piecewise cubic hermite interpolating polynomial via <code>scipy.interpolate.PchipInterpolator</code>.</li> </ul> </li> </ul> <code>'cubic'</code> <p>Returns:</p> Type Description <code>interpolator</code> <p>A function <code>f</code> that returns interpolated values.</p> Source code in <code>src\\curvey\\util.py</code> <pre><code>def periodic_interpolator(\n    x: ndarray,\n    f: ndarray,\n    typ: InterpType | str = \"cubic\",\n) -&gt; Callable[[ndarray], ndarray]:\n    \"\"\"Construct a periodic interpolator of the function f(x)\n\n    Parameters\n    ----------\n    x\n        `(n + 1,)` array of independent variable values.\n\n    f\n        `(n,)` or `(n, ndim)` array of function values.\n        `f(x[-1])` is assumed equal to `f(x[0])`.\n\n    typ\n        The type of interpolator. One of\n\n        - 'linear' for linear interpolation via `scipy.interpolate.interp1d`\n        - `cubic` for cubic spline interpolation via `scipy.interpolate.CubicSpline`\n        - 'pchip`\n            - for piecewise cubic hermite interpolating polynomial via\n            `scipy.interpolate.PchipInterpolator`.\n\n    Returns\n    -------\n    interpolator\n        A function `f` that returns interpolated values.\n    \"\"\"\n\n    if typ == \"linear\":\n        return _periodic_interp1d(x, f)\n\n    if typ == \"cubic\":\n        return CubicSpline(x, concatenate([f, f[[0]]]), bc_type=\"periodic\")\n\n    if typ == \"pchip\":\n        return _periodic_pchip(x, f)\n\n    msg = f\"Unrecognized interpolator type {typ}\"\n    raise ValueError(msg)\n</code></pre>"},{"location":"api/util/#curvey.util.reflection_matrix","title":"<code>reflection_matrix(theta: float) -&gt; ndarray</code>","text":"<p>A 2x2 reflection matrix</p> Source code in <code>src\\curvey\\util.py</code> <pre><code>def reflection_matrix(theta: float) -&gt; ndarray:\n    \"\"\"A 2x2 reflection matrix\"\"\"\n    cos_2theta, sin_2theta = cos(2 * theta), sin(2 * theta)\n    return array([[cos_2theta, sin_2theta], [sin_2theta, -cos_2theta]])\n</code></pre>"},{"location":"api/util/#curvey.util.rotation_matrix","title":"<code>rotation_matrix(theta: float) -&gt; ndarray</code>","text":"<p>A 2x2 rotation matrix</p> Source code in <code>src\\curvey\\util.py</code> <pre><code>def rotation_matrix(theta: float) -&gt; ndarray:\n    \"\"\"A 2x2 rotation matrix\"\"\"\n    cos_theta, sin_theta = cos(theta), sin(theta)\n    return array([[cos_theta, -sin_theta], [sin_theta, cos_theta]])\n</code></pre>"},{"location":"tutorial/","title":"Tutorials","text":"<p>These are Jupyter lab notebooks --</p> <ul> <li> <p>Introduction</p> <ul> <li>Constructing a curve, plotting curves, sequences of curves</li> </ul> </li> <li> <p>Shape structure dataset</p> <ul> <li>Loading curves from the 2D Shape Structure Dataset</li> </ul> </li> <li> <p>Flow</p> <ul> <li>Curve shortening flow, singularity free curvature flow, Willmore flow</li> </ul> </li> <li> <p>Blend</p> <ul> <li>Linear blending, curvature blending</li> </ul> </li> </ul>"},{"location":"tutorial/blend/","title":"Blends","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\nfrom curvey import Curve, Curves\nfrom curvey.shape_structure_dataset import ShapeStructureDataset\nfrom curvey.flow import WillmoreFlow\nfrom curvey.blend import Processed, CurvatureShapeBlending, LinearBlending\n</pre> import numpy as np from matplotlib import pyplot as plt from curvey import Curve, Curves from curvey.shape_structure_dataset import ShapeStructureDataset from curvey.flow import WillmoreFlow from curvey.blend import Processed, CurvatureShapeBlending, LinearBlending <p>To demonstrate shape blending we'll use a couple of examples from the Shape Structure Dataset:</p> In\u00a0[2]: Copied! <pre>dataset = ShapeStructureDataset(\"~/Downloads/ShapesJSON.zip\")\n\n# Load curves and center them so they're reasonably well-aligned,\n# make sure they have the same orientation, and resample both\n# to the same number of vertices\nsrc = dataset.load_curve(\"dino\", 0).translate(\"center\").to_ccw().interpolate_n(n=200)\ntgt = dataset.load_curve(\"bird\", 8).reflect(\"y\").to_ccw().translate(\"center\").interpolate_n(n=200)\n\n# Finds the best vertex in the `tgt` shape to call the first vertex, to\n# minimize the sum of square distances between corresponding vertices\ntgt = tgt.roll_to(src)\n\n_ = plt.subplots(figsize=(4, 4))\n_ = src.plot_edges(directed=False)\n_ = tgt.plot_edges(directed=False, linestyle=\"-:\")\n</pre> dataset = ShapeStructureDataset(\"~/Downloads/ShapesJSON.zip\")  # Load curves and center them so they're reasonably well-aligned, # make sure they have the same orientation, and resample both # to the same number of vertices src = dataset.load_curve(\"dino\", 0).translate(\"center\").to_ccw().interpolate_n(n=200) tgt = dataset.load_curve(\"bird\", 8).reflect(\"y\").to_ccw().translate(\"center\").interpolate_n(n=200)  # Finds the best vertex in the `tgt` shape to call the first vertex, to # minimize the sum of square distances between corresponding vertices tgt = tgt.roll_to(src)  _ = plt.subplots(figsize=(4, 4)) _ = src.plot_edges(directed=False) _ = tgt.plot_edges(directed=False, linestyle=\"-:\") In\u00a0[3]: Copied! <pre>lb = LinearBlending(src, tgt)\nlb_curves = lb.interpolate(t=np.linspace(0, 1, 5))\n_ = lb_curves.subplots(\n    figsize=(6, 4),\n    subtitle=lambda c: f\"t = {c['time']}\",\n)\n</pre> lb = LinearBlending(src, tgt) lb_curves = lb.interpolate(t=np.linspace(0, 1, 5)) _ = lb_curves.subplots(     figsize=(6, 4),     subtitle=lambda c: f\"t = {c['time']}\", ) <p>The weakness of linear blending is that it can difficult to avoid small self intersections.</p> In\u00a0[4]: Copied! <pre>for c in lb_curves:\n    if not c.is_simple:\n        print(c)\n        print(c.edge_intersections())\n</pre> for c in lb_curves:     if not c.is_simple:         print(c)         print(c.edge_intersections()) <pre>Curve(n=200, ssd_name=dino, time=0.5, idx=2)\n[[0.25351013 0.32599915]]\n</pre> In\u00a0[5]: Copied! <pre># These steps are performed by `CurvatureShapeBlending.preprocess`\n# for convenience, but done here explicitly for reference\nsrc1 = src.to_length(1.0)\ntgt1 = tgt.to_length(1.0)\nsrc1 = src1.optimize_edge_lengths_to(tgt1)\ntgt1 = tgt1.optimize_edge_lengths_to(src1)\np_src = Processed(original=src, processed=src1)\np_tgt = Processed(original=tgt, processed=tgt1)\n</pre> # These steps are performed by `CurvatureShapeBlending.preprocess` # for convenience, but done here explicitly for reference src1 = src.to_length(1.0) tgt1 = tgt.to_length(1.0) src1 = src1.optimize_edge_lengths_to(tgt1) tgt1 = tgt1.optimize_edge_lengths_to(src1) p_src = Processed(original=src, processed=src1) p_tgt = Processed(original=tgt, processed=tgt1) <p>In the Hirano et al. paper, they describe first flowing from the initial source shape to the first interpolated curvatures, from that to the second, and so on to the final target shape curvatures. I've found that this approach is vulnerable to getting 'stuck' in the middle, and never really hitting the final target shape. Instead, we'll first flow the initial source shape to a circle, and then flow that circle to each interpolated curvature independently. (The original approach is still available by using the <code>path_dependent</code> argument to <code>CurvatureShapeBlending.interpolate</code>.)</p> In\u00a0[6]: Copied! <pre>wf = WillmoreFlow()\nsolver = wf.solver(initial=p_src.processed, stop_tol=1e-3)\ncircle = solver.run().current\n</pre> wf = WillmoreFlow() solver = wf.solver(initial=p_src.processed, stop_tol=1e-3) circle = solver.run().current <p>The <code>CurvatureShapeBlending</code> class uses target Willmore flow to flow from the initial shape, in this case that circle, to a number of intermediate curvatures $\\kappa_t = (1 - t) \\kappa_0 + t \\kappa_1$. Because it does the flow on the rescaled curves, it will then rescale the interpolated curve back to a length or area interpolated from the original curves.</p> In\u00a0[7]: Copied! <pre>csb = CurvatureShapeBlending(\n    processed0=p_src,\n    processed1=p_tgt,\n    initial=circle,\n    flow=wf,\n)\nt_interp = np.linspace(0, 1, 5)\ncurv_blend_curves = csb.interpolate(\n    t=t_interp,\n    stop_tol=1e-3,\n    interp_size=\"area\",\n)\n</pre> csb = CurvatureShapeBlending(     processed0=p_src,     processed1=p_tgt,     initial=circle,     flow=wf, ) t_interp = np.linspace(0, 1, 5) curv_blend_curves = csb.interpolate(     t=t_interp,     stop_tol=1e-3,     interp_size=\"area\", ) <p><code>CurvatureShapeBlending.interpolate</code> returns a <code>Curves</code> object containing the interpolated curves:</p> In\u00a0[8]: Copied! <pre>axs = curv_blend_curves.subplots(\n    figsize=(6, 3),\n    plot_fn=lambda c: c.plot(color=\"black\"),\n    subtitle=lambda c: f\"t = {c['time']:.02f}\",\n)\n_ = src.plot(color=\"red\", ax=axs[0, 0], alpha=0.5)\n_ = tgt.plot(color=\"red\", ax=axs[0, -1], alpha=0.5)\n</pre> axs = curv_blend_curves.subplots(     figsize=(6, 3),     plot_fn=lambda c: c.plot(color=\"black\"),     subtitle=lambda c: f\"t = {c['time']:.02f}\", ) _ = src.plot(color=\"red\", ax=axs[0, 0], alpha=0.5) _ = tgt.plot(color=\"red\", ax=axs[0, -1], alpha=0.5) <p>The original curves are shown above in red at <code>t=0</code> and <code>t=1</code>, overlayed by the interpolated shapes, showing the curvature interpolation doesn't exactly hit its endpoint targets, but gets pretty close. (You can pass <code>exact_endpoints=(True, True)</code> to <code>CurvatureShapeBlending.interpolate</code> to have it automatically return the original curves at <code>t=0</code> and <code>t=1</code> instead of using curvature flow on those endpoints.)</p> <p><code>CurvatureShapeBlending.interpolate</code> stores three curve metadata properties on the interpolated curves:</p> <ul> <li><code>src_error</code>: $e(\\tilde \\kappa - \\kappa_0)$</li> <li><code>tgt_error</code> $e(\\tilde \\kappa - \\kappa_1)$</li> <li><code>interp_error</code>$e(\\tilde \\kappa - \\kappa_t)$</li> </ul> <p>Where $\\tilde \\kappa$ is the observed curvature at that interpolation point, $\\kappa_0$ and $\\kappa_1$ are the start and end curvatures to interpolate between, and $\\kappa_t = (1 - t) \\kappa_0 + t \\kappa_1$ are the interpolated curvatures, and the error $e(\\kappa)$ is</p> <p>$$ e(\\kappa) = \\left( \\sum_i \\kappa_i^2 d_i \\right) ^ {1/2} $$</p> <p>for vertex dual edge lengths $d_i$, i.e. the error is the $\\mathscr{L}^2$ norm of the difference in curvatures.</p> In\u00a0[9]: Copied! <pre>_ = plt.subplots(figsize=(3, 3))\ncurv_blend_curves.plot(\"src_error\", marker=\"o\")\ncurv_blend_curves.plot(\"tgt_error\", marker=\"o\")\ncurv_blend_curves.plot(\"interp_error\", marker=\"o\")\n_ = plt.gca().set_ylabel(\"error\")\n_ = plt.legend(bbox_to_anchor=(1, 0.75))\n</pre> _ = plt.subplots(figsize=(3, 3)) curv_blend_curves.plot(\"src_error\", marker=\"o\") curv_blend_curves.plot(\"tgt_error\", marker=\"o\") curv_blend_curves.plot(\"interp_error\", marker=\"o\") _ = plt.gca().set_ylabel(\"error\") _ = plt.legend(bbox_to_anchor=(1, 0.75))"},{"location":"tutorial/blend/#linear-blending","title":"Linear blending\u00b6","text":"<p>Linear blending is extremely fast and simple, and requires only that the curves have the same number of vertices. (This can be done manually as above, or with <code>JointSampled.to_common_vertex_count</code>, which will simply split edges in the fewer-vertices curve until the counts match.)</p>"},{"location":"tutorial/blend/#curvature-blending","title":"Curvature blending\u00b6","text":"<p>Based on Rapid blending of closed curves based on curvature flow. Masahiro Hirano, Yoshihiro Watanabe, and Masatoshi Ishikawa. 2017..</p> <p>Curvature blending uses Willmore flow. Instead of interpolating between vertex coordinates, it interpolates between vertex curvatures. For this to work, we'll need more than just the number of vertices to match\u2014because Willmore flow operates isometrically, we'll need the total arclengths and individual edge lengths to match. The <code>curvey.blend.Processed</code> class is just a convenience class to store the original and processed copies of a curve; <code>CurvatureShapeBlending</code> will need to reference both.</p>"},{"location":"tutorial/flow/","title":"Flows","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\n\nfrom curvey import Curve, Curves\nfrom curvey.shape_structure_dataset import ShapeStructureDataset\nfrom curvey.flow import (\n    CurveShorteningFlow,\n    SingularityFreeMeanCurvatureFlow,\n    WillmoreFlow,\n)\n</pre> import numpy as np from matplotlib import pyplot as plt  from curvey import Curve, Curves from curvey.shape_structure_dataset import ShapeStructureDataset from curvey.flow import (     CurveShorteningFlow,     SingularityFreeMeanCurvatureFlow,     WillmoreFlow, ) In\u00a0[2]: Copied! <pre>plt.rcParams[\"axes.titlesize\"] = 10\n</pre> plt.rcParams[\"axes.titlesize\"] = 10 <p>Flows are calculated with an auxillary <code>Solver</code> object constructed by the <code>Flow.solver</code> method:</p> In\u00a0[3]: Copied! <pre>dumbbell = Curve.dumbbell(n=100, rx=1.25).rotate(np.pi / 2)\ncsf = CurveShorteningFlow()\nsolver = csf.solver(\n    initial=dumbbell,\n    timestep=1e-3,\n    max_step=300,\n)\nsolver.run()  # returns the same solver object for convenience\n</pre> dumbbell = Curve.dumbbell(n=100, rx=1.25).rotate(np.pi / 2) csf = CurveShorteningFlow() solver = csf.solver(     initial=dumbbell,     timestep=1e-3,     max_step=300, ) solver.run()  # returns the same solver object for convenience Out[3]: <pre>Solver(flow=CurveShorteningFlow, current=Curve(n=36, time=0.3000000000000002, step=300, timestep=0.001))</pre> <p>By default, the solver stores the curve at each timestep during the run in its <code>history</code> property, a <code>curvey.Curves</code> object.</p> In\u00a0[4]: Copied! <pre>solver.history\n</pre> solver.history Out[4]: <pre>Curves(n=301, data={idx, step, time, timestep})</pre> <p>Under curve-shortening flow, the curve should smooth out and approach a circle, eventually collapsing into a round point. Plotted on the left below is the curve roundness $P^2/ {4 \\pi A}$ for perimeter $P$ and area $A$, which should be 1.0 for a perfect circle and greater than 1 otherwise</p> In\u00a0[5]: Copied! <pre>fig = plt.figure(layout=\"constrained\", figsize=(7, 3))\nsubfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[1, 1])\nax0 = subfigs[0].subplots()\nsolver.history.plot(y=\"roundness\", x=\"step\", label_axes=True, ax=ax0)\n\naxs1 = subfigs[1].subplots(2, 3, sharex=True, sharey=True)\nsolver.history.subplots(subtitle=\"step\", axs=axs1);\n</pre> fig = plt.figure(layout=\"constrained\", figsize=(7, 3)) subfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[1, 1]) ax0 = subfigs[0].subplots() solver.history.plot(y=\"roundness\", x=\"step\", label_axes=True, ax=ax0)  axs1 = subfigs[1].subplots(2, 3, sharex=True, sharey=True) solver.history.subplots(subtitle=\"step\", axs=axs1); <p>A difficulty with CSF is that it can be numerically unstable; by default the curve is resampled each iteration to maintain a uniform distribution of vertices. With resampling off, we can see the flow break down:</p> In\u00a0[6]: Copied! <pre>_ = (\n    CurveShorteningFlow(resample_mode=None)\n    .solver(\n        initial=dumbbell,\n        timestep=1e-3,\n        max_step=500,\n    )\n    .run()\n    .history.subplots(1, 5, subtitle=\"step\", figsize=(6, 3))\n)\n</pre> _ = (     CurveShorteningFlow(resample_mode=None)     .solver(         initial=dumbbell,         timestep=1e-3,         max_step=500,     )     .run()     .history.subplots(1, 5, subtitle=\"step\", figsize=(6, 3)) ) In\u00a0[7]: Copied! <pre>_ = (\n    SingularityFreeMeanCurvatureFlow()\n    .solver(\n        initial=dumbbell,\n        timestep=0.1,\n        max_step=500,\n    )\n    .run()\n    .history.subplots(\n        n_cols=5,\n        subtitle=\"step\",\n        figsize=(6, 3),\n    )\n)\n</pre> _ = (     SingularityFreeMeanCurvatureFlow()     .solver(         initial=dumbbell,         timestep=0.1,         max_step=500,     )     .run()     .history.subplots(         n_cols=5,         subtitle=\"step\",         figsize=(6, 3),     ) ) In\u00a0[8]: Copied! <pre>wf = WillmoreFlow()\ncircle_solver = wf.solver(initial=dumbbell, stop_tol=1e-3).run()\n\nfig = plt.figure(layout=\"constrained\", figsize=(7, 3))\nsubfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[1, 1])\nax0 = subfigs[0].subplots()\ncircle_solver.history.plot(y=\"willmore_energy\", x=\"time\", label_axes=True, ax=ax0, marker=\"o\")\n\naxs1 = subfigs[1].subplots(2, 3, sharex=True, sharey=True)\ncircle_solver.history.subplots(subtitle=\"step\", axs=axs1);\n</pre> wf = WillmoreFlow() circle_solver = wf.solver(initial=dumbbell, stop_tol=1e-3).run()  fig = plt.figure(layout=\"constrained\", figsize=(7, 3)) subfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[1, 1]) ax0 = subfigs[0].subplots() circle_solver.history.plot(y=\"willmore_energy\", x=\"time\", label_axes=True, ax=ax0, marker=\"o\")  axs1 = subfigs[1].subplots(2, 3, sharex=True, sharey=True) circle_solver.history.subplots(subtitle=\"step\", axs=axs1); In\u00a0[9]: Copied! <pre>dataset = ShapeStructureDataset(\"~/Downloads/ShapesJSON.zip\")\ndino = dataset.load_curve(\"dino\")\n\nfilter_shapes = (0, 1, 3)\nn_shapes = len(filter_shapes)\nn_steps = 5\nsz = 1.5\nfig, axs = plt.subplots(\n    nrows=n_shapes,\n    ncols=n_steps,\n    figsize=(sz * n_steps, sz * n_shapes),\n)\n\nfor i, filter_shape in enumerate(filter_shapes):\n    wf = WillmoreFlow(filter_width=0.1, filter_shape=filter_shape)\n    solver = wf.solver(initial=dino, max_step=n_steps, timestep=0.075)\n    solver.run()\n    solver.history.subplots(axs=axs[[i], :], plot_fn=Curve.plot, show_axes=False)\n\nfor i in range(n_steps):\n    axs[0, i].set_title(f\"step = {i}\")\n\nfor i, k in enumerate(filter_shapes):\n    axs[i, 0].set_ylabel(f\"k = {k}\")\n</pre> dataset = ShapeStructureDataset(\"~/Downloads/ShapesJSON.zip\") dino = dataset.load_curve(\"dino\")  filter_shapes = (0, 1, 3) n_shapes = len(filter_shapes) n_steps = 5 sz = 1.5 fig, axs = plt.subplots(     nrows=n_shapes,     ncols=n_steps,     figsize=(sz * n_steps, sz * n_shapes), )  for i, filter_shape in enumerate(filter_shapes):     wf = WillmoreFlow(filter_width=0.1, filter_shape=filter_shape)     solver = wf.solver(initial=dino, max_step=n_steps, timestep=0.075)     solver.run()     solver.history.subplots(axs=axs[[i], :], plot_fn=Curve.plot, show_axes=False)  for i in range(n_steps):     axs[0, i].set_title(f\"step = {i}\")  for i, k in enumerate(filter_shapes):     axs[i, 0].set_ylabel(f\"k = {k}\") In\u00a0[10]: Copied! <pre># Start from the circle we just flowed to in the last example\ncircle = circle_solver.current\n\n# Resample to make sure we have uniform distribution of edge lengths\ncircle = circle.interpolate_n(n=circle.n)\n\n# Construct a target with the same total length and number of vertices\nstar = Curve.star(n=5, r0=0.75, r1=1.5).interpolate_n(n=circle.n).to_length(circle.length)\n\n# Flow from the circle to the star\nwf = WillmoreFlow(tgt_curvature=star.curvature)\ntgt_solver = wf.solver(initial=circle, max_step=10).run()\n</pre> # Start from the circle we just flowed to in the last example circle = circle_solver.current  # Resample to make sure we have uniform distribution of edge lengths circle = circle.interpolate_n(n=circle.n)  # Construct a target with the same total length and number of vertices star = Curve.star(n=5, r0=0.75, r1=1.5).interpolate_n(n=circle.n).to_length(circle.length)  # Flow from the circle to the star wf = WillmoreFlow(tgt_curvature=star.curvature) tgt_solver = wf.solver(initial=circle, max_step=10).run() In\u00a0[11]: Copied! <pre>fig = plt.figure(layout=\"constrained\", figsize=(7, 3))\nsubfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[1, 1])\nax0 = subfigs[0].subplots()\ntgt_solver.history.plot(\n    y=\"willmore_energy\",\n    x=\"step\",\n    label_axes=True,\n    ax=ax0,\n    marker=\"o\",\n)\n\naxs1 = subfigs[1].subplots(3, 4, sharex=True, sharey=True)\ntgt_solver.history.subplots(subtitle=\"step\", axs=axs1)\n# Plot the target in the last axes for comparison\n# Account for rotation/translation\naligned = star.align_to(tgt_solver.history[-1])\nlast_ax = axs1.flatten()[-1]\n_ = aligned.plot_edges(directed=False, ax=last_ax)\n_ = last_ax.set_title(\"Target\")\n</pre> fig = plt.figure(layout=\"constrained\", figsize=(7, 3)) subfigs = fig.subfigures(1, 2, wspace=0.07, width_ratios=[1, 1]) ax0 = subfigs[0].subplots() tgt_solver.history.plot(     y=\"willmore_energy\",     x=\"step\",     label_axes=True,     ax=ax0,     marker=\"o\", )  axs1 = subfigs[1].subplots(3, 4, sharex=True, sharey=True) tgt_solver.history.subplots(subtitle=\"step\", axs=axs1) # Plot the target in the last axes for comparison # Account for rotation/translation aligned = star.align_to(tgt_solver.history[-1]) last_ax = axs1.flatten()[-1] _ = aligned.plot_edges(directed=False, ax=last_ax) _ = last_ax.set_title(\"Target\")"},{"location":"tutorial/flow/#flows","title":"Flows\u00b6","text":"<p>Flows are used to evolve a curve over time. Specific flows are subclasses of the abstract superclass <code>curvey.flow.Flow</code>.</p>"},{"location":"tutorial/flow/#curve-shortening-flow","title":"Curve shortening flow\u00b6","text":"<p>The simplest form implemented in curvey is Curve Shortening Flow, which moves curve vertices in the direction of the vertex normal, scaled by the curvature at that vertex. For a cool interactive demonstration of CSF, see https://a.carapetis.com/csf/.</p>"},{"location":"tutorial/flow/#singularity-free-mean-curvature-flow","title":"Singularity-free mean curvature flow\u00b6","text":"<p>An implementation of Can Mean-Curvature Flow Be Made Non-Singular? Michael Kazhdan, Jake Solomon, and Mirela Ben-Chen. 2012. It's much more stable and doesn't require reparametrization:</p>"},{"location":"tutorial/flow/#willmore-flow","title":"Willmore flow\u00b6","text":"<p>An implementation of Robust Fairing via Conformal Curvature Flow. Keenan Crane, Ulrich Pinkall, and Peter Schr\u00f6der. 2014. Willmore flow operates on vertex curvatures, rather than vertex coordinates, and is faster because it can take much larger timesteps. Because it operates isometrically, the curve doesn't shrink but instead maintains its total length. In this example, instead of specifying a <code>timestep</code> and <code>max_step</code>, we'll specify a <code>stop_tol</code> which allows the solver to automatically determine an adaptive step-size and stopping condition from the energy gradient.</p>"},{"location":"tutorial/flow/#filtered-willmore-flow","title":"Filtered Willmore flow\u00b6","text":"<p><code>WillmoreFlow</code> accepts two filter arguments <code>filter_width</code> and <code>filter_shape</code>. These are the $\\sigma$ and $k$ parameters in the Crane et al. paper. (Section 4, see Figure 8.) They shape the flow by filtering out high or low frequency curvature changes, depending on the <code>filter_shape</code> parameter.</p>"},{"location":"tutorial/flow/#targeted-willmore-flow","title":"Targeted Willmore flow\u00b6","text":"<p>Instead of flowing down the gradient of Wilmore energy $\\kappa^2$, we can supply a target curvature and flow down the gradient $(\\kappa - \\kappa_{\\text {target}})^2$</p>"},{"location":"tutorial/introduction/","title":"Introduction","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\nfrom curvey import Curve, Curves\n</pre> import numpy as np from matplotlib import pyplot as plt from curvey import Curve, Curves In\u00a0[2]: Copied! <pre>plt.rcParams[\"figure.figsize\"] = (3, 3)\nplt.rcParams[\"axes.titlesize\"] = 10\nplt.rcParams[\"axes.labelsize\"] = 8\nplt.rcParams[\"xtick.labelsize\"] = 8\nplt.rcParams[\"ytick.labelsize\"] = 8\n</pre> plt.rcParams[\"figure.figsize\"] = (3, 3) plt.rcParams[\"axes.titlesize\"] = 10 plt.rcParams[\"axes.labelsize\"] = 8 plt.rcParams[\"xtick.labelsize\"] = 8 plt.rcParams[\"ytick.labelsize\"] = 8 <p>A <code>Curve</code> is defined and constructed its vertex coordinates:</p> In\u00a0[3]: Copied! <pre>triangle = Curve([[0, 0], [1, 0], [1, 1]])\n_ = triangle.plot()\n</pre> triangle = Curve([[0, 0], [1, 0], [1, 1]]) _ = triangle.plot() <p>Note: all of the <code>curvey</code> plotting routines return matplotlib handles to the plotted object; they're assigned throughout these tutorials to the discarded variable <code>_</code> to avoid clutter.</p> <p>The vertex coordinates can be accessed by the <code>points</code> property (they've been converted to a numpy array automatically.)</p> In\u00a0[4]: Copied! <pre>triangle.points\n</pre> triangle.points Out[4]: <pre>array([[0, 0],\n       [1, 0],\n       [1, 1]])</pre> <p>Note: the curve is only implicitly closed; there is an assumed edge between the last point and the first.</p> <p>A <code>Curve</code> with <code>n</code> vertices has <code>n</code> edges.</p> <p>Edges are directed, giving the curve an orientation. We can visualize the orientation with <code>Curve.plot_edges</code>, which draws each edge as a little arrow. By default, edges are colored by their cumulative length:</p> In\u00a0[5]: Copied! <pre>circle = Curve.circle(n=16, r=1)\n_ = circle.plot_edges()\n</pre> circle = Curve.circle(n=16, r=1) _ = circle.plot_edges() <p>The curve starts at $(x=1, y=0)$ and travels counterclockwise. Curve constructors like <code>Curve.circle</code> construct the curve in counterclockwise orientation. <code>Curve.orientation</code> is <code>+1</code> for counterclockwise curves, and <code>-1</code> for clockwise. This has the same sign conventions as <code>Curve.signed_area</code>.</p> In\u00a0[6]: Copied! <pre>circle.orientation, circle.signed_area\n</pre> circle.orientation, circle.signed_area Out[6]: <pre>(1, 3.061467458920718)</pre> <p><code>Curve.reverse()</code> flips the orientation; <code>Curve.to_ccw()</code> and <code>Curve.to_cw()</code> do so as appropriate.</p> In\u00a0[7]: Copied! <pre>elcric = circle.reverse()\nelcric.orientation, elcric.signed_area\n</pre> elcric = circle.reverse() elcric.orientation, elcric.signed_area Out[7]: <pre>(-1, -3.0614674589207183)</pre> <p>Geometric properties of the curve are mostly represented as curve properties, which may be scalar, vertex-valued, or edge-valued. They are computed on-demand on their first access, and cached for later reuse.</p> In\u00a0[8]: Copied! <pre>circle.length  # A scalar\n</pre> circle.length  # A scalar Out[8]: <pre>6.242890304516104</pre> In\u00a0[9]: Copied! <pre>circle.centroid  # A two element array\n</pre> circle.centroid  # A two element array Out[9]: <pre>array([6.04406786e-18, 0.00000000e+00])</pre> In\u00a0[10]: Copied! <pre>circle.edge_length  # A length-`n` vector of edge lengths\n</pre> circle.edge_length  # A length-`n` vector of edge lengths Out[10]: <pre>array([0.39018064, 0.39018064, 0.39018064, 0.39018064, 0.39018064,\n       0.39018064, 0.39018064, 0.39018064, 0.39018064, 0.39018064,\n       0.39018064, 0.39018064, 0.39018064, 0.39018064, 0.39018064,\n       0.39018064])</pre> In\u00a0[11]: Copied! <pre>circle.tangent  # A (`n`, 2) array of tangent directions\n</pre> circle.tangent  # A (`n`, 2) array of tangent directions Out[11]: <pre>array([[ 0.00000000e+00,  1.00000000e+00],\n       [-3.82683432e-01,  9.23879533e-01],\n       [-7.07106781e-01,  7.07106781e-01],\n       [-9.23879533e-01,  3.82683432e-01],\n       [-1.00000000e+00,  0.00000000e+00],\n       [-9.23879533e-01, -3.82683432e-01],\n       [-7.07106781e-01, -7.07106781e-01],\n       [-3.82683432e-01, -9.23879533e-01],\n       [-2.26394716e-16, -1.00000000e+00],\n       [ 3.82683432e-01, -9.23879533e-01],\n       [ 7.07106781e-01, -7.07106781e-01],\n       [ 9.23879533e-01, -3.82683432e-01],\n       [ 1.00000000e+00, -2.26394716e-16],\n       [ 9.23879533e-01,  3.82683432e-01],\n       [ 7.07106781e-01,  7.07106781e-01],\n       [ 3.82683432e-01,  9.23879533e-01]])</pre> <p>Curve transformations like <code>Curve.scale</code> are methods that return a new curve:</p> In\u00a0[12]: Copied! <pre>bigger_circle = circle.scale(1.5)\ncircle.plot(color=\"red\")\nbigger_circle.plot(color=\"blue\");\n</pre> bigger_circle = circle.scale(1.5) circle.plot(color=\"red\") bigger_circle.plot(color=\"blue\"); <p>In addition to <code>Curve.plot</code> and <code>Curve.plot_edges</code>, already demonstrated, there is also <code>Curve.plot_points</code> and <code>Curve.plot_vectors</code>.</p> In\u00a0[13]: Copied! <pre>c = Curve.ellipse(n=20, ra=1, rb=2)\nfig, axs = plt.subplots(1, 5, figsize=(8, 3), sharex=True, sharey=True)\n\n_ = c.plot(ax=axs[0], color=\"black\")\n_ = c.plot_edges(\n    ax=axs[1],\n    directed=True,\n    color=c.arclength,\n    width=0.02,\n)\n_ = c.plot_edges(\n    ax=axs[2],\n    directed=False,\n    color=c.arclength,\n    width=1 / np.abs(c.curvature),\n    scale_width=(1, 10),\n)\n_ = c.plot_points(\n    ax=axs[3],\n    color=c.arclength,\n    size=c.dual_edge_length,\n    scale_sz=(3, 64),\n)\n_ = c.plot_vectors(\n    ax=axs[4],\n    vectors=c.normal,\n    scale=c.curvature,\n    scale_length=(0.2, 1),\n    color=c.arclength,\n    width=0.02,\n)\ntitles = (\n    \"plot\",\n    \"plot_edges[directed]\",\n    \"plot_edges[undirected]\",\n    \"plot_points\",\n    \"plot_vectors\",\n)\nfor ax, ttl in zip(axs, titles):\n    ax.set_title(ttl, fontsize=\"10\")\n    ax.axis(\"off\")\n    ax.axis(\"scaled\")\n\nfig.tight_layout()\n</pre> c = Curve.ellipse(n=20, ra=1, rb=2) fig, axs = plt.subplots(1, 5, figsize=(8, 3), sharex=True, sharey=True)  _ = c.plot(ax=axs[0], color=\"black\") _ = c.plot_edges(     ax=axs[1],     directed=True,     color=c.arclength,     width=0.02, ) _ = c.plot_edges(     ax=axs[2],     directed=False,     color=c.arclength,     width=1 / np.abs(c.curvature),     scale_width=(1, 10), ) _ = c.plot_points(     ax=axs[3],     color=c.arclength,     size=c.dual_edge_length,     scale_sz=(3, 64), ) _ = c.plot_vectors(     ax=axs[4],     vectors=c.normal,     scale=c.curvature,     scale_length=(0.2, 1),     color=c.arclength,     width=0.02, ) titles = (     \"plot\",     \"plot_edges[directed]\",     \"plot_edges[undirected]\",     \"plot_points\",     \"plot_vectors\", ) for ax, ttl in zip(axs, titles):     ax.set_title(ttl, fontsize=\"10\")     ax.axis(\"off\")     ax.axis(\"scaled\")  fig.tight_layout() In\u00a0[14]: Copied! <pre>c0 = Curve.star(n=6, r0=1, r1=1.5)\nc1 = c0.with_data(name=\"mystar\", max_radius=1.5)\nc2 = c1.scale(2).with_data(max_radius=3)\nfor c in (c0, c1, c2):\n    print(c)\n</pre> c0 = Curve.star(n=6, r0=1, r1=1.5) c1 = c0.with_data(name=\"mystar\", max_radius=1.5) c2 = c1.scale(2).with_data(max_radius=3) for c in (c0, c1, c2):     print(c) <pre>Curve(n=12)\nCurve(n=12, name=mystar, max_radius=1.5)\nCurve(n=12, name=mystar, max_radius=3)\n</pre> <p>Metadata can be accessed by indexing by the property name:</p> In\u00a0[15]: Copied! <pre>c1[\"max_radius\"]\n</pre> c1[\"max_radius\"] Out[15]: <pre>1.5</pre> <p>Or as a read-only <code>dict</code> via the <code>Curve.data</code> property:</p> In\u00a0[16]: Copied! <pre>c0.data\n</pre> c0.data Out[16]: <pre>mappingproxy({})</pre> In\u00a0[17]: Copied! <pre>n = 5\ncurves = Curves(\n    Curve.circle(20, r=r).with_data(radius=r, shape=\"circle\") for r in np.linspace(1, 2, n)\n)\ncurves\n</pre> n = 5 curves = Curves(     Curve.circle(20, r=r).with_data(radius=r, shape=\"circle\") for r in np.linspace(1, 2, n) ) curves Out[17]: <pre>Curves(n=5, data={idx, radius, shape})</pre> <p><code>Curves.subplots</code> constructs subplots for quick inspection:</p> In\u00a0[18]: Copied! <pre>_ = curves.subplots(subtitle=\"radius\", figsize=(8, 3))\n</pre> _ = curves.subplots(subtitle=\"radius\", figsize=(8, 3)) <p><code>Curves.superimposed</code> does the same thing in a single axis:</p> In\u00a0[19]: Copied! <pre>_ = curves.superimposed(color=\"radius\")  # Color by the metadata property 'radius'\n</pre> _ = curves.superimposed(color=\"radius\")  # Color by the metadata property 'radius' <p><code>Curves</code> can be iterated over:</p> In\u00a0[20]: Copied! <pre>for c in curves:\n    print(c)\n</pre> for c in curves:     print(c) <pre>Curve(n=20, radius=1.0, shape=circle, idx=0)\nCurve(n=20, radius=1.25, shape=circle, idx=1)\nCurve(n=20, radius=1.5, shape=circle, idx=2)\nCurve(n=20, radius=1.75, shape=circle, idx=3)\nCurve(n=20, radius=2.0, shape=circle, idx=4)\n</pre> <p>and can be indexed like lists or numpy arrays, e.g. <code>curves[1]</code> returns the second dict and <code>curves[::2]</code> returns a new <code>Curves</code> containing every second curve in the original. Curve metadata can be collected by indexing with the property name:`</p> In\u00a0[21]: Copied! <pre>curves[\"radius\"]\n</pre> curves[\"radius\"] Out[21]: <pre>array([1.  , 1.25, 1.5 , 1.75, 2.  ])</pre> <p>or a function:</p> In\u00a0[22]: Copied! <pre>curves[lambda c: 2 * c.length]\n</pre> curves[lambda c: 2 * c.length] Out[22]: <pre>array([12.5147572 , 15.6434465 , 18.7721358 , 21.90082511, 25.02951441])</pre> <p>or more generally with <code>Curves.get_data</code> in order to supply default values if not all curves have the requested metadata.</p>"},{"location":"tutorial/introduction/#introduction","title":"Introduction\u00b6","text":""},{"location":"tutorial/introduction/#basics","title":"Basics\u00b6","text":""},{"location":"tutorial/introduction/#plotting","title":"Plotting\u00b6","text":""},{"location":"tutorial/introduction/#metadata","title":"Metadata\u00b6","text":"<p><code>Curve.with_data</code> can be used to attach or overwrite arbitrary metadata to a curve, which persists through transformations.</p>"},{"location":"tutorial/introduction/#curves","title":"Curves\u00b6","text":"<p>The <code>Curves</code> class is used for storing multiple curves. The constructor accepts an iterator of <code>Curve</code>s.</p>"},{"location":"tutorial/shape_structure_dataset/","title":"Shape structure dataset","text":"In\u00a0[1]: Copied! <pre>import numpy as np\nfrom matplotlib import pyplot as plt\nfrom curvey.shape_structure_dataset import ShapeStructureDataset\n</pre> import numpy as np from matplotlib import pyplot as plt from curvey.shape_structure_dataset import ShapeStructureDataset <p>The 2D Shape Structure Dataset makes for a useful source of curves for testing shape interpolation.</p> <p>Download the shapes zip file here. It does not need to be unzipped.</p> In\u00a0[2]: Copied! <pre>dataset = ShapeStructureDataset(\"~/Downloads/ShapesJSON.zip\")\n</pre> dataset = ShapeStructureDataset(\"~/Downloads/ShapesJSON.zip\") <p>All classes in the dataset:</p> In\u00a0[3]: Copied! <pre>print(\", \".join(dataset.class_names))\n</pre> print(\", \".join(dataset.class_names)) <pre>apple, bat, beetle, bell, bird, bone, bottle, brick, butterfly, camel, car, carriage, cattle, cellular_phone, chicken, children, chopper, classic, comma, crown, cup, deer, device, dino, dog, elephant, face, fish, flatfish, fly, fork, fountain, frog, glas, guitar, hammer, hat, hcircle, heart, horse, horseshoe, image, jar, key, lizzard, lmfish, misk, octopus, pencil, personal_car, pocket, rat, ray, sea_snake, shoe, spoon, spring, stef, teddy, tree, turtle, watch\n</pre> <p>For each class, there are (usually) multiple exemplars:</p> In\u00a0[4]: Copied! <pre>print(\", \".join(dataset.names_by_class[\"apple\"]))\n</pre> print(\", \".join(dataset.names_by_class[\"apple\"])) <pre>apple-1, apple-10, apple-11, apple-12, apple-13, apple-14, apple-15, apple-16, apple-17, apple-18, apple-19, apple-2, apple-20, apple-3, apple-4, apple-5, apple-6, apple-7, apple-8, apple-9\n</pre> <p>Load a curve either by its full name or its class and index:</p> In\u00a0[5]: Copied! <pre>dataset.load_curve(\"apple\", 6)\n</pre> dataset.load_curve(\"apple\", 6) Out[5]: <pre>Curve(n=103, ssd_name=apple-15)</pre> <p>Plot the first exemplar in each class:</p> In\u00a0[6]: Copied! <pre>n = len(dataset.class_names)\nn_cols = 10\nn_rows = int(np.ceil(n / n_cols))\nfig, ax = plt.subplots(figsize=(12, 1.2 * n_rows))\n\nfor i, class_name in enumerate(dataset.class_names):\n    c = dataset.load_curve(class_name, 0).translate(\"center\")\n    max_r = np.linalg.norm(c.points, axis=1).max()\n    c = c.scale(0.35 / max_r)\n    y = i // n_cols  # This is correct\n    x = i - y * n_cols\n\n    c.translate([x, -y]).plot(color=\"black\")\n    plt.text(x, 0.4 - y, class_name, horizontalalignment=\"center\")\n\nax.axis(\"equal\")\nax.axis(\"off\")\nax.set_ylim((-(n_rows - 0.5), 0.75));\n</pre> n = len(dataset.class_names) n_cols = 10 n_rows = int(np.ceil(n / n_cols)) fig, ax = plt.subplots(figsize=(12, 1.2 * n_rows))  for i, class_name in enumerate(dataset.class_names):     c = dataset.load_curve(class_name, 0).translate(\"center\")     max_r = np.linalg.norm(c.points, axis=1).max()     c = c.scale(0.35 / max_r)     y = i // n_cols  # This is correct     x = i - y * n_cols      c.translate([x, -y]).plot(color=\"black\")     plt.text(x, 0.4 - y, class_name, horizontalalignment=\"center\")  ax.axis(\"equal\") ax.axis(\"off\") ax.set_ylim((-(n_rows - 0.5), 0.75));"}]}